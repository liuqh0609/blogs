<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>时间复杂度&amp;空间复杂度</title>
      <link href="2021/02/04/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>2021/02/04/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度&amp;空间复杂度"></a>时间复杂度&amp;空间复杂度</h1><h2 id="复杂度的作用"><a href="#复杂度的作用" class="headerlink" title="复杂度的作用"></a>复杂度的作用</h2><p>一般我们会从两个维度去考虑一段代码的质量：</p><ol><li>时间复杂度</li><li>空间复杂度</li></ol><p>顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。</p><p>所以时间复杂度和空间复杂度一般是用来衡量一段代码的优劣的。</p><p>那么我们应该怎么来定义复杂度呢？<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1606953725697-beedfd24-126b-4e4f-97cc-28d93d2321e1.png#align=left&display=inline&height=78&margin=%5Bobject%20Object%5D&name=image.png&originHeight=155&originWidth=198&size=27501&status=done&style=none&width=99" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1606953725697-beedfd24-126b-4e4f-97cc-28d93d2321e1.png#align=left&display=inline&height=78&margin=%5Bobject%20Object%5D&name=image.png&originHeight=155&originWidth=198&size=27501&status=done&style=none&width=99" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="复杂度的定义与特点"><a href="#复杂度的定义与特点" class="headerlink" title="复杂度的定义与特点"></a>复杂度的定义与特点</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>复杂度是一个关于输入量 n 的函数。<br>eg：假设你的代码复杂度是 f(n),那么用大写字母 O 将其括起来就可以表示复杂度了 — O(f(n))</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="与常系数无关"><a href="#与常系数无关" class="headerlink" title="与常系数无关"></a>与常系数无关</h4><blockquote><p>例如 O(n) + O(n) = O(2n), 其实 O(n)复杂度和 O(2n)复杂度是一样的，我们通常会忽略常系数对复杂度的影响</p></blockquote><h4 id="多项式级相加的复杂度，会取结果最大的那一个作为最后的结果"><a href="#多项式级相加的复杂度，会取结果最大的那一个作为最后的结果" class="headerlink" title="多项式级相加的复杂度，会取结果最大的那一个作为最后的结果"></a>多项式级相加的复杂度，会取结果最大的那一个作为最后的结果</h4><blockquote><p>O(n^2) + O(n)，明显 n^2 在输入量 n 逐渐变大的情况下，变化会更大，所以我们就说复杂度是 O(n^2)即可</p></blockquote><h4 id="O-1-是一个特殊的复杂度：输入量-n-与消耗的资源无关"><a href="#O-1-是一个特殊的复杂度：输入量-n-与消耗的资源无关" class="headerlink" title="O(1)是一个特殊的复杂度：输入量 n 与消耗的资源无关"></a>O(1)是一个特殊的复杂度：输入量 n 与消耗的资源无关</h4><blockquote><p>O（1）表示的是当前复杂度和输入 n 无关。例如你的代码处理 100 条数据是消耗 3 个时间单元和 1 个空间单元，处理 500 条数据依然还是消耗 3 个时间单元和 1 个空间单元，那么就是输入量与消耗资源无</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612220986085-7033d2c5-66bb-4608-8177-b3105aa878a9.png#align=left&display=inline&height=337&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1346&originWidth=1412&size=1576566&status=done&style=none&width=353" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612220986085-7033d2c5-66bb-4608-8177-b3105aa878a9.png#align=left&display=inline&height=337&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1346&originWidth=1412&size=1576566&status=done&style=none&width=353" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">num += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)<br>空间复杂度：O(1)</p><h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i++; i &lt; n) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><blockquote><p>单个变量所占的空间永远都是一个常量所以是 O(1)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i++; i &lt; n) &#123;</span><br><span class="line">  arr.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><blockquote><p>这段代码相当于我们给数组 arr 中添加了 n 个元素，所以占用了 n 个内存单元，因此空间复杂度为 O(n)</p></blockquote><h3 id="O-logn"><a href="#O-logn" class="headerlink" title="O(logn)"></a>O(logn)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">  i *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><blockquote><p>这段代码相当于是在计算 2&lt;=n，也就是 x 次之后循环结束那么 x=logn</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码效率优化方法论</title>
      <link href="2021/02/04/%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
      <url>2021/02/04/%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="代码效率优化方法论"><a href="#代码效率优化方法论" class="headerlink" title="代码效率优化方法论"></a>代码效率优化方法论</h1><h2 id="如何衡量一段代码的优劣呢？"><a href="#如何衡量一段代码的优劣呢？" class="headerlink" title="如何衡量一段代码的优劣呢？"></a>如何衡量一段代码的优劣呢？</h2><p>一般我们会从两个维度去考虑一段代码的质量：</p><ol><li>时间复杂度</li><li>空间复杂度</li></ol><p>顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。<br>那么我们应该怎么取舍这两个标准呢？</p><h2 id="提高代码效率的方法"><a href="#提高代码效率的方法" class="headerlink" title="提高代码效率的方法"></a>提高代码效率的方法</h2><p>我们从上面已经知道了衡量代码效率的方法，那么我们应该怎么着手去优化提高我们代码的效率呢？</p><p>总的策略就是降低代码的时间复杂度和空间复杂度。</p><p>但是对于一段代码来说往往时间和空间两个是互斥的，如果我们想要降低时间复杂度，那么无疑就会增加空间复杂度。<br>举一个生活中的 🌰，就像我们平时生活中开车过红绿灯，如果只有这一条路（空间）那么我们就只能在这等着红灯，当车越来越多的时候，就会消耗大家很多时间，但是当我们修建了立交桥之后，就会有更多的选择空间，就会大大减少等待红灯的时间。<br><img src="https://cdn.nlark.com/yuque/0/2020/gif/2705850/1606953443121-946ba365-7a49-4689-8090-5e820840f5eb.gif#align=left&display=inline&height=720" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/2705850/1606953443121-946ba365-7a49-4689-8090-5e820840f5eb.gif#align=left&display=inline&height=720" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="CgqCHl7CRMaAO_oEAJfz6fjfMNQ403.gif"><br>（图片来自拉钩教育-公瑾老师的重学算法与数据结构一课中）<br>而对我们来说，时间永远都要比空间更加重要，因为时间拿钱买不来，而空间我们起码可以拿钱来进行扩容。<br><strong>空间是廉价的，时间是昂贵的</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1606953817114-7e1a263e-6acb-4bf2-9110-da34521c23f8.png#align=left&display=inline&height=76" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1606953817114-7e1a263e-6acb-4bf2-9110-da34521c23f8.png#align=left&display=inline&height=76" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></strong></p><ol><li>暴力解法：在没有任何时间和空间的限制下，将目标达成</li><li>剔除无效操作：将代码中没有必要的计算、无效的存储删除来优化时间和空间复杂度</li><li>时空转换：设计合理的数据结构，将时间向空间转换</li></ol><h2 id="增删查：数据的基本操作"><a href="#增删查：数据的基本操作" class="headerlink" title="增删查：数据的基本操作"></a>增删查：数据的基本操作</h2><p>一般一段算法的实现最常设计的三个操作就是：增、删、查。<br>而我们对一个算法的优化和实现只要围绕这三个为重心去思考展开即可：</p><ol><li>分析这段代码对数据进行了那些操作</li><li>这些操作中有哪些操作是最消耗性能的，对时间复杂度的损耗是最高的？</li><li>考虑有哪种数据结构可以帮助提高数据操作的使用效率。</li></ol><p>以上三点就是构成我们实现代码效率优化的方法论。</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ol><li>按照元素索引查找<ul><li>对于数组这些天生拥有索引的数据结构来说十分简单</li><li>对于链表这种，通过指针进行连接的就需要知道前面一个元素</li></ul></li><li>按照元素特征值查找<ul><li>对于字典类型的数据来说，key 就相当是特征，value 就是值，查找起来非常方便</li><li>对于数组和链表来说就需要循环对比每个元素来进行比较值的特征是否符合</li></ul></li></ol><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ol><li>在复杂数据结构的末尾添加数据<ul><li>不会影响数据的原始位置</li></ul></li><li>在复杂数据结构的中间添加数据<ul><li>会影响到数据原始的位置</li></ul></li></ol><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ol><li>在复杂数据结构的末尾删除<ul><li>不会影响到原先数据的位置</li></ul></li><li>在复杂数据结构的中间位置进行删除<ul><li>会影响到之前数据的原始位置</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈 - 基础知识</title>
      <link href="2021/02/04/%E6%A0%88/"/>
      <url>2021/02/04/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612236925054-f7e99dfb-004a-4be1-aee6-aacfbdabd331.png#align=left&display=inline&height=314&margin=%5Bobject%20Object%5D&name=image.png&originHeight=314&originWidth=342&size=23754&status=done&style=none&width=342" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612236925054-f7e99dfb-004a-4be1-aee6-aacfbdabd331.png#align=left&display=inline&height=314&margin=%5Bobject%20Object%5D&name=image.png&originHeight=314&originWidth=342&size=23754&status=done&style=none&width=342" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一种<strong>后进先出</strong>的数据结构。 类似于一个麻袋，先装进去的就在袋子的最底部，所以只能先拿出来最上面的</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="push：-入栈"><a href="#push：-入栈" class="headerlink" title="push： 入栈"></a>push： 入栈</h3><h3 id="pop：-出栈"><a href="#pop：-出栈" class="headerlink" title="pop： 出栈"></a>pop： 出栈</h3><h3 id="top：栈顶"><a href="#top：栈顶" class="headerlink" title="top：栈顶"></a>top：栈顶</h3><h2 id="JavaScript-中的栈"><a href="#JavaScript-中的栈" class="headerlink" title="JavaScript 中的栈"></a>JavaScript 中的栈</h2><p>在 js 中是没用栈这种数据结构的，不过我们可以利用<strong>数组</strong>来模拟。<br>而且在 js 中也是有对应的 <code>push</code>  和 <code>pop</code>  方法的:</p><p>push: 向数组末尾添加一个元素，返回值是数组的长度<br>pop：移除数组的第一个元素，返回值是移除的元素</p><h2 id="什么场景下用栈？"><a href="#什么场景下用栈？" class="headerlink" title="什么场景下用栈？"></a>什么场景下用栈？</h2><blockquote><p>最直白的讲就是需要<strong>后进先出</strong>的场景</p></blockquote><h3 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612245130432-6b1613e8-13ae-4f96-a691-47f68394f3bb.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&name=image.png&originHeight=259&originWidth=379&size=80976&status=done&style=none&width=379" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612245130432-6b1613e8-13ae-4f96-a691-47f68394f3bb.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&name=image.png&originHeight=259&originWidth=379&size=80976&status=done&style=none&width=379" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>我们计算十进制转二进制时，就是不断除以 2，然后取余数<br>然后将最后一位的余数与第一位的余数拼成二进制</p><p>这样的后进先出的手法有没有想到栈！</p><h3 id="判断字符串的括号是否有效"><a href="#判断字符串的括号是否有效" class="headerlink" title="判断字符串的括号是否有效"></a>判断字符串的括号是否有效</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612245247309-b9ef1209-3935-4573-acd5-3b11b1e44384.png#align=left&display=inline&height=228&margin=%5Bobject%20Object%5D&name=image.png&originHeight=228&originWidth=275&size=30754&status=done&style=none&width=275" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612245247309-b9ef1209-3935-4573-acd5-3b11b1e44384.png#align=left&display=inline&height=228&margin=%5Bobject%20Object%5D&name=image.png&originHeight=228&originWidth=275&size=30754&status=done&style=none&width=275" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>我们验证括号是否有效其实就是在验证是不是能够凑齐一对完整的闭合括号。</p><p>而且我们可以发现一个规律，越靠左的左括号，它对应的右括号就越靠右。反之也就是最后面的左括号，对应的必定是出现的第一个右括号。</p><p>所以我们就可以在遇到左括号时就入栈，遇到右括号时就与栈顶的括号就行配对比较，若果符合配对规则则出栈，否则就不符合规则直接判定无效。匹配到最后结如果栈内是空就证明可以完整闭合</p><h3 id="函数调用栈等"><a href="#函数调用栈等" class="headerlink" title="函数调用栈等"></a>函数调用栈等</h3><p>这个可以看浏览器，js 的解释器就是通过调用栈的形式实现的<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612249568954-7f2f8a5c-6c50-4eb5-bb44-c98e9dd0490b.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=305&size=43181&status=done&style=none&width=305" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612249568954-7f2f8a5c-6c50-4eb5-bb44-c98e9dd0490b.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=305&size=43181&status=done&style=none&width=305" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612249579751-d03a29ca-0a7a-4a44-896b-2bb23a79b6ed.png#align=left&display=inline&height=130&margin=%5Bobject%20Object%5D&name=image.png&originHeight=182&originWidth=470&size=38332&status=done&style=none&width=335" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612249579751-d03a29ca-0a7a-4a44-896b-2bb23a79b6ed.png#align=left&display=inline&height=130&margin=%5Bobject%20Object%5D&name=image.png&originHeight=182&originWidth=470&size=38332&status=done&style=none&width=335" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><p>执行 fun1 时先将 fun1 入栈，然后调用 fun2，入栈；然后调用 fun3 入栈。</p><p>fun3 执行完毕出栈<br>fun2 执行完毕出栈<br>fun1 执行完毕出栈<br>程序执行完毕</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈 - 基础知识</title>
      <link href="2021/02/04/%E6%B5%8B%E8%AF%95/"/>
      <url>2021/02/04/%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>测试首页图片是否能正常显示以及文章描述</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo+Github Action+腾讯云函数+yuque-hexo打造自动化博客部署方案</title>
      <link href="2021/02/04/yuque/%E4%BD%BF%E7%94%A8Hexo+Github%20Action+%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0+yuque-hexo%E6%89%93%E9%80%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/"/>
      <url>2021/02/04/yuque/%E4%BD%BF%E7%94%A8Hexo+Github%20Action+%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0+yuque-hexo%E6%89%93%E9%80%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>tags: [hexo, github]<br>categories: [fe]<br>cover: <a href="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612418500562-e844caa3-bb3e-4b5d-8b27-573fd7f1d7ab.png">https://cdn.nlark.com/yuque/0/2021/png/2705850/1612418500562-e844caa3-bb3e-4b5d-8b27-573fd7f1d7ab.png</a></p><hr><p>本文将会一步一步的带你打造一套自动化部署的博客系统。<br>从语雀发布文章后自动同步到 Github page 的静态博客。</p><a id="more"></a><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612418500562-e844caa3-bb3e-4b5d-8b27-573fd7f1d7ab.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=image.png&originHeight=300&originWidth=534&size=349027&status=done&style=none&width=267" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612418500562-e844caa3-bb3e-4b5d-8b27-573fd7f1d7ab.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=image.png&originHeight=300&originWidth=534&size=349027&status=done&style=none&width=267" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="Hexo-创建静态博客"><a href="#Hexo-创建静态博客" class="headerlink" title="Hexo 创建静态博客"></a>Hexo 创建静态博客</h2><p>好第一步就这样完成了</p><h2 id="Github-Action-yuque-hexo-实现-CI-流程"><a href="#Github-Action-yuque-hexo-实现-CI-流程" class="headerlink" title="Github Action + yuque-hexo 实现 CI 流程"></a>Github Action + yuque-hexo 实现 CI 流程</h2><p>接下来我们进行第二步<br>…<br>恩，第二步也快了的完成了，那我们继续第三部吧~</p><h2 id="腾讯云函数监听语雀事件触发-Action"><a href="#腾讯云函数监听语雀事件触发-Action" class="headerlink" title="腾讯云函数监听语雀事件触发 Action"></a>腾讯云函数监听语雀事件触发 Action</h2><p>大功告成，来在语雀上试一下把~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>语雀测试文档</title>
      <link href="2021/02/03/yuque/%E8%AF%AD%E9%9B%80%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3/"/>
      <url>2021/02/03/yuque/%E8%AF%AD%E9%9B%80%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612410294674-95772a68-2c02-460a-8a79-ef6f289a69ab.png#align=left&display=inline&height=366&margin=%5Bobject%20Object%5D&name=image.png&originHeight=731&originWidth=500&size=837151&status=done&style=none&width=250" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612410294674-95772a68-2c02-460a-8a79-ef6f289a69ab.png#align=left&display=inline&height=366&margin=%5Bobject%20Object%5D&name=image.png&originHeight=731&originWidth=500&size=837151&status=done&style=none&width=250" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="2021/02/02/yuque/%E6%A0%88/"/>
      <url>2021/02/02/yuque/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612236925054-f7e99dfb-004a-4be1-aee6-aacfbdabd331.png#align=left&display=inline&height=314&margin=%5Bobject%20Object%5D&name=image.png&originHeight=314&originWidth=342&size=23754&status=done&style=none&width=342" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612236925054-f7e99dfb-004a-4be1-aee6-aacfbdabd331.png#align=left&display=inline&height=314&margin=%5Bobject%20Object%5D&name=image.png&originHeight=314&originWidth=342&size=23754&status=done&style=none&width=342" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一种<strong>后进先出</strong>的数据结构。 类似于一个麻袋，先装进去的就在袋子的最底部，所以只能先拿出来最上面的</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="push：-入栈"><a href="#push：-入栈" class="headerlink" title="push： 入栈"></a>push： 入栈</h3><h3 id="pop：-出栈"><a href="#pop：-出栈" class="headerlink" title="pop： 出栈"></a>pop： 出栈</h3><h3 id="top：栈顶"><a href="#top：栈顶" class="headerlink" title="top：栈顶"></a>top：栈顶</h3><h2 id="JavaScript-中的栈"><a href="#JavaScript-中的栈" class="headerlink" title="JavaScript 中的栈"></a>JavaScript 中的栈</h2><p>在 js 中是没用栈这种数据结构的，不过我们可以利用<strong>数组</strong>来模拟。<br>而且在 js 中也是有对应的 <code>push</code>  和 <code>pop</code>  方法的:</p><p>push: 向数组末尾添加一个元素，返回值是数组的长度<br>pop：移除数组的第一个元素，返回值是移除的元素</p><h2 id="什么场景下用栈？"><a href="#什么场景下用栈？" class="headerlink" title="什么场景下用栈？"></a>什么场景下用栈？</h2><blockquote><p>最直白的讲就是需要<strong>后进先出</strong>的场景</p></blockquote><h3 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612245130432-6b1613e8-13ae-4f96-a691-47f68394f3bb.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&name=image.png&originHeight=259&originWidth=379&size=80976&status=done&style=none&width=379" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612245130432-6b1613e8-13ae-4f96-a691-47f68394f3bb.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&name=image.png&originHeight=259&originWidth=379&size=80976&status=done&style=none&width=379" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>我们计算十进制转二进制时，就是不断除以 2，然后取余数<br>然后将最后一位的余数与第一位的余数拼成二进制</p><p>这样的后进先出的手法有没有想到栈！</p><h3 id="判断字符串的括号是否有效"><a href="#判断字符串的括号是否有效" class="headerlink" title="判断字符串的括号是否有效"></a>判断字符串的括号是否有效</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612245247309-b9ef1209-3935-4573-acd5-3b11b1e44384.png#align=left&display=inline&height=228&margin=%5Bobject%20Object%5D&name=image.png&originHeight=228&originWidth=275&size=30754&status=done&style=none&width=275" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612245247309-b9ef1209-3935-4573-acd5-3b11b1e44384.png#align=left&display=inline&height=228&margin=%5Bobject%20Object%5D&name=image.png&originHeight=228&originWidth=275&size=30754&status=done&style=none&width=275" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>我们验证括号是否有效其实就是在验证是不是能够凑齐一对完整的闭合括号。</p><p>而且我们可以发现一个规律，越靠左的左括号，它对应的右括号就越靠右。反之也就是最后面的左括号，对应的必定是出现的第一个右括号。</p><p>所以我们就可以在遇到左括号时就入栈，遇到右括号时就与栈顶的括号就行配对比较，若果符合配对规则则出栈，否则就不符合规则直接判定无效。匹配到最后结如果栈内是空就证明可以完整闭合</p><h3 id="函数调用栈等"><a href="#函数调用栈等" class="headerlink" title="函数调用栈等"></a>函数调用栈等</h3><p>这个可以看浏览器，js 的解释器就是通过调用栈的形式实现的<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612249568954-7f2f8a5c-6c50-4eb5-bb44-c98e9dd0490b.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=305&size=43181&status=done&style=none&width=305" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612249568954-7f2f8a5c-6c50-4eb5-bb44-c98e9dd0490b.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=305&size=43181&status=done&style=none&width=305" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612249579751-d03a29ca-0a7a-4a44-896b-2bb23a79b6ed.png#align=left&display=inline&height=130&margin=%5Bobject%20Object%5D&name=image.png&originHeight=182&originWidth=470&size=38332&status=done&style=none&width=335" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612249579751-d03a29ca-0a7a-4a44-896b-2bb23a79b6ed.png#align=left&display=inline&height=130&margin=%5Bobject%20Object%5D&name=image.png&originHeight=182&originWidth=470&size=38332&status=done&style=none&width=335" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><p>执行 fun1 时先将 fun1 入栈，然后调用 fun2，入栈；然后调用 fun3 入栈。</p><p>fun3 执行完毕出栈<br>fun2 执行完毕出栈<br>fun1 执行完毕出栈<br>程序执行完毕</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度&amp;空间复杂度</title>
      <link href="2021/02/02/yuque/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>2021/02/02/yuque/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="复杂度的作用"><a href="#复杂度的作用" class="headerlink" title="复杂度的作用"></a>复杂度的作用</h2><p>一般我们会从两个维度去考虑一段代码的质量：</p><ol><li>时间复杂度</li><li>空间复杂度</li></ol><p>顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。</p><p>所以时间复杂度和空间复杂度一般是用来衡量一段代码的优劣的。</p><p>那么我们应该怎么来定义复杂度呢？<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1606953725697-beedfd24-126b-4e4f-97cc-28d93d2321e1.png#align=left&display=inline&height=78&margin=%5Bobject%20Object%5D&name=image.png&originHeight=155&originWidth=198&size=27501&status=done&style=none&width=99" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1606953725697-beedfd24-126b-4e4f-97cc-28d93d2321e1.png#align=left&display=inline&height=78&margin=%5Bobject%20Object%5D&name=image.png&originHeight=155&originWidth=198&size=27501&status=done&style=none&width=99" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="复杂度的定义与特点"><a href="#复杂度的定义与特点" class="headerlink" title="复杂度的定义与特点"></a>复杂度的定义与特点</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>复杂度是一个关于输入量 n 的函数。<br>eg：假设你的代码复杂度是 f(n),那么用大写字母 O 将其括起来就可以表示复杂度了 — O(f(n))</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="与常系数无关"><a href="#与常系数无关" class="headerlink" title="与常系数无关"></a>与常系数无关</h4><blockquote><p>例如 O(n) + O(n) = O(2n), 其实 O(n)复杂度和 O(2n)复杂度是一样的，我们通常会忽略常系数对复杂度的影响</p></blockquote><h4 id="多项式级相加的复杂度，会取结果最大的那一个作为最后的结果"><a href="#多项式级相加的复杂度，会取结果最大的那一个作为最后的结果" class="headerlink" title="多项式级相加的复杂度，会取结果最大的那一个作为最后的结果"></a>多项式级相加的复杂度，会取结果最大的那一个作为最后的结果</h4><blockquote><p>O(n^2) + O(n)，明显 n^2 在输入量 n 逐渐变大的情况下，变化会更大，所以我们就说复杂度是 O(n^2)即可</p></blockquote><h4 id="O-1-是一个特殊的复杂度：输入量-n-与消耗的资源无关"><a href="#O-1-是一个特殊的复杂度：输入量-n-与消耗的资源无关" class="headerlink" title="O(1)是一个特殊的复杂度：输入量 n 与消耗的资源无关"></a>O(1)是一个特殊的复杂度：输入量 n 与消耗的资源无关</h4><blockquote><p>O（1）表示的是当前复杂度和输入 n 无关。例如你的代码处理 100 条数据是消耗 3 个时间单元和 1 个空间单元，处理 500 条数据依然还是消耗 3 个时间单元和 1 个空间单元，那么就是输入量与消耗资源无</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612220986085-7033d2c5-66bb-4608-8177-b3105aa878a9.png#align=left&display=inline&height=337&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1346&originWidth=1412&size=1576566&status=done&style=none&width=353" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612220986085-7033d2c5-66bb-4608-8177-b3105aa878a9.png#align=left&display=inline&height=337&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1346&originWidth=1412&size=1576566&status=done&style=none&width=353" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">num += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)<br>空间复杂度：O(1)</p><h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i++; i &lt; n) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><blockquote><p>单个变量所占的空间永远都是一个常量所以是 O(1)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i++; i &lt; n) &#123;</span><br><span class="line">  arr.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><blockquote><p>这段代码相当于我们给数组 arr 中添加了 n 个元素，所以占用了 n 个内存单元，因此空间复杂度为 O(n)</p></blockquote><h3 id="O-logn"><a href="#O-logn" class="headerlink" title="O(logn)"></a>O(logn)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">  i *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><blockquote><p>这段代码相当于是在计算 2&lt;=n，也就是 x 次之后循环结束那么 x=logn</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[红宝书质检厂]看看读完红宝书的你，到底学废了吗？</title>
      <link href="2021/01/26/yuque/%5B%E7%BA%A2%E5%AE%9D%E4%B9%A6%E8%B4%A8%E6%A3%80%E5%8E%82%5D%E7%9C%8B%E7%9C%8B%E8%AF%BB%E5%AE%8C%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%9A%84%E4%BD%A0%EF%BC%8C%E5%88%B0%E5%BA%95%E5%AD%A6%E5%BA%9F%E4%BA%86%E5%90%97%EF%BC%9F/"/>
      <url>2021/01/26/yuque/%5B%E7%BA%A2%E5%AE%9D%E4%B9%A6%E8%B4%A8%E6%A3%80%E5%8E%82%5D%E7%9C%8B%E7%9C%8B%E8%AF%BB%E5%AE%8C%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%9A%84%E4%BD%A0%EF%BC%8C%E5%88%B0%E5%BA%95%E5%AD%A6%E5%BA%9F%E4%BA%86%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>对于技术类的书籍，我认为我们在阅读的时候应该是带着问题又目的性的阅读，当我们读完一个章节或者一部分之后就回头问问自己是否了解或者掌握了这其中的知识点，以问题的形式来回顾和检查自己的理解程度。</p><p>本篇文章我就以这种角度来带大家检查一下自己阅读红宝书的质量到底如何</p><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="你眼里的-JavaScript-是什么？"><a href="#你眼里的-JavaScript-是什么？" class="headerlink" title="你眼里的 JavaScript 是什么？"></a>你眼里的 JavaScript 是什么？</h3><p>在前端的远古时代（95 年之前）为了验证一个输入字段是否有效，就需要与服务器进行一次往返的通信，极其浪费时间。而 JavaScript 当时的出现就是为了解决这种前端的数据验证问题，但是随着自身的发展，现在 Js 能做的事情已经越来越多了，也就成为了现在我们所认识的主流编程语言。<br>完整的 JavaScript 由 3 部分组成：</p><ol><li>ECMAScript</li><li>DOM</li><li>BOM</li></ol><h3 id="那你能分别介绍一下这三部分吗？"><a href="#那你能分别介绍一下这三部分吗？" class="headerlink" title="那你能分别介绍一下这三部分吗？"></a>那你能分别介绍一下这三部分吗？</h3><p>ECMAScript：由国际标准化组织制定的一种标准，定义了这门语言的一些词法、语法和类型等一系列的标准<br>DOM：全称是 Document Object Model，也就是文档对象模型，是用来让我们对 HTML 文档中的元素结构进行增删改查的<br>BOM：Brower Object Model，浏览器对象模型，实现了一系列的浏览器 API，以方便我们去操作浏览器相关的操作，常用的有 window 对象，navigator 对象，XMLRequest，操作 Cookie 的等等</p><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1611704341145-747ae015-7564-441d-bef2-7f8cb22d0b1c.png#align=left&display=inline&height=425&margin=%5Bobject%20Object%5D&name=image.png&originHeight=850&originWidth=2438&size=361309&status=done&style=none&width=1219" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1611704341145-747ae015-7564-441d-bef2-7f8cb22d0b1c.png#align=left&display=inline&height=425&margin=%5Bobject%20Object%5D&name=image.png&originHeight=850&originWidth=2438&size=361309&status=done&style=none&width=1219" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="能说一下-script-标签的-defer-和-async-属性吗？"><a href="#能说一下-script-标签的-defer-和-async-属性吗？" class="headerlink" title="能说一下 script 标签的 defer 和 async 属性吗？"></a>能说一下 script 标签的 defer 和 async 属性吗？</h3><h3 id="上面你提到的-load-和-DOMContentLoad-事件能解释一下吗？"><a href="#上面你提到的-load-和-DOMContentLoad-事件能解释一下吗？" class="headerlink" title="上面你提到的 load 和 DOMContentLoad 事件能解释一下吗？"></a>上面你提到的 load 和 DOMContentLoad 事件能解释一下吗？</h3><h3 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>标签语义化</title>
      <link href="2020/12/30/yuque/%E6%A0%87%E7%AD%BE%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
      <url>2020/12/30/yuque/%E6%A0%87%E7%AD%BE%E8%AF%AD%E4%B9%89%E5%8C%96/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动画与绘制</title>
      <link href="2020/12/27/yuque/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%88%B6/"/>
      <url>2020/12/27/yuque/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><ul><li>@keyframes 定义<ul><li>可以使用百分比表示进度</li><li>也可以使用 from、to</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> mykf&#123;</span><br><span class="line"><span class="selector-tag">form</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: red</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: blue</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>animation：使用</p><ul><li>animation-name     动画名称</li><li>animation-duration     动画的时长</li><li>animation-timing-function     动画的时间曲线<ul><li>贝塞尔曲线：<a href="https://cubic-bezier.com/#.17,.67,.83,.67">https://cubic-bezier.com/#.17,.67,.83,.67</a></li><li>一次贝塞尔曲线（直线）</li><li>二次贝塞尔曲线</li><li>三次贝塞尔曲线（常用）</li></ul></li><li>animation-delay     动画开始前的延迟</li><li>animation-iteration-count     动画的播放次数</li><li>animation-rirection     动画的方向</li></ul></li><li><p>transition</p><ul><li>transition-property 需要变换的属性</li><li>transition-duration 变换的时长</li><li>transition-timing-function 时间曲线</li><li>transition-delay 延迟</li></ul></li></ul><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1609074986965-f439f290-534a-4e1c-ab66-5c49265301b7.png#align=left&display=inline&height=298&margin=%5Bobject%20Object%5D&name=image.png&originHeight=596&originWidth=742&size=98359&status=done&style=none&width=371" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1609074986965-f439f290-534a-4e1c-ab66-5c49265301b7.png#align=left&display=inline&height=298&margin=%5Bobject%20Object%5D&name=image.png&originHeight=596&originWidth=742&size=98359&status=done&style=none&width=371" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>在自然界中我们看到的光都是混色光，极少有纯色光（激光笔可以达到纯色光）<br>正常人类看到的光的波长在 400~760nm。</p><p>人眼内有三种视锥细胞，这三种细胞分别用来识别三种颜色：红绿蓝（RGB）</p><h3 id="HSL-和-HSV"><a href="#HSL-和-HSV" class="headerlink" title="HSL 和 HSV"></a>HSL 和 HSV</h3><ul><li>Hue： 色相（将颜色分成一个色盘，然后我们通过制定一个色盘中的角度，来决定他的颜色）</li><li>Ssturation：纯度</li><li>Lightness： 亮度（到达 100 是白色，到达 0 是黑色，中间的才是纯色）</li><li>Value：明度 （value 到达 100%时，就相当于是一个纯色）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1609075457053-ef9ba5ca-8060-40bf-a17b-f4a2c5f4f7ce.png#align=left&display=inline&height=237&margin=%5Bobject%20Object%5D&name=image.png&originHeight=250&originWidth=640&size=189658&status=done&style=none&width=607" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1609075457053-ef9ba5ca-8060-40bf-a17b-f4a2c5f4f7ce.png#align=left&display=inline&height=237&margin=%5Bobject%20Object%5D&name=image.png&originHeight=250&originWidth=640&size=189658&status=done&style=none&width=607" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>（HSL： W3C 采用的标准）</p><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><h3 id="几何图形"><a href="#几何图形" class="headerlink" title="几何图形"></a>几何图形</h3><ul><li>border</li><li>box-shadow</li><li>border-radius</li></ul><h3 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h3><ul><li>font</li><li>text-decoration</li></ul><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><ul><li>background-image</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS排版</title>
      <link href="2020/12/21/yuque/CSS%E6%8E%92%E7%89%88/"/>
      <url>2020/12/21/yuque/CSS%E6%8E%92%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h2 id="盒（Box"><a href="#盒（Box" class="headerlink" title="盒（Box)"></a>盒（Box)</h2><blockquote><p>HTML 代码中可以书写开始标签，结束标签，和自封闭标签<br>一对起止标签，表示一个元素<br>DOM 树中存储的是元素和其他类型的节点（Node)<br>CSS 选择器选中的是元素<br>CSS 选择器选中的元素，在排版时可能产生多个盒<br>排版和渲染的基本单位是盒</p></blockquote><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/2705850/1608507917849-976f9a05-930c-4cd1-9ce0-3c9417f3bc20.jpeg#align=left&display=inline&height=316&margin=%5Bobject%20Object%5D&name=IMG_F9E013A8321B-1.jpeg&originHeight=962&originWidth=1195&size=1274496&status=done&style=none&width=393" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/jpeg/2705850/1608507917849-976f9a05-930c-4cd1-9ce0-3c9417f3bc20.jpeg#align=left&display=inline&height=316&margin=%5Bobject%20Object%5D&name=IMG_F9E013A8321B-1.jpeg&originHeight=962&originWidth=1195&size=1274496&status=done&style=none&width=393" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="IMG_F9E013A8321B-1.jpeg"><br>盒模型分为两种：</p><blockquote><p>可以通过 box-sizing 来设置不同的盒模型<br>box-sizing 默认值是 content-box</p></blockquote><ol><li>怪异盒模型（border-box)： <code>box-width = content + padding + border</code></li><li>标准盒模型 (content-box)： <code>box-width = content</code><blockquote><p>标准盒模型在增加 padding 和 border 的宽度时，会保持原有的 box-width 而去对应减少 content 的 width 的所占空间</p></blockquote></li></ol><h2 id="正常流"><a href="#正常流" class="headerlink" title="正常流"></a>正常流</h2><p>正常流的排版：</p><ol><li>收集盒和文字进行计算</li><li>计算盒和文字在行中的排布</li><li>计算行的排布</li></ol><p>IFC：行内级格式化上下文（从左到右排列）<br>BFC：块级格式化上下（从上到下排列）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608591685793-2521eba0-5803-466b-89a6-763608883ac7.png#align=left&display=inline&height=960&margin=%5Bobject%20Object%5D&name=image.png&originHeight=960&originWidth=2226&size=303741&status=done&style=none&width=2226" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608591685793-2521eba0-5803-466b-89a6-763608883ac7.png#align=left&display=inline&height=960&margin=%5Bobject%20Object%5D&name=image.png&originHeight=960&originWidth=2226&size=303741&status=done&style=none&width=2226" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="正常流的行级排布（IFC）"><a href="#正常流的行级排布（IFC）" class="headerlink" title="正常流的行级排布（IFC）"></a>正常流的行级排布（IFC）</h2><h3 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h3><p>下图中黄色的线就是基线，文字是基于<strong>基线</strong>来对齐的。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608592017818-80fa1342-32b6-4329-8d26-f87285f9454b.png#align=left&display=inline&height=62&margin=%5Bobject%20Object%5D&name=image.png&originHeight=248&originWidth=738&size=149484&status=done&style=none&width=185" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608592017818-80fa1342-32b6-4329-8d26-f87285f9454b.png#align=left&display=inline&height=62&margin=%5Bobject%20Object%5D&name=image.png&originHeight=248&originWidth=738&size=149484&status=done&style=none&width=185" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><p>底层软件定义的文字<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608592161826-fb417db4-a214-46c9-a569-a667cbf53176.png#align=left&display=inline&height=169&margin=%5Bobject%20Object%5D&name=image.png&originHeight=676&originWidth=1034&size=367041&status=done&style=none&width=259" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608592161826-fb417db4-a214-46c9-a569-a667cbf53176.png#align=left&display=inline&height=169&margin=%5Bobject%20Object%5D&name=image.png&originHeight=676&originWidth=1034&size=367041&status=done&style=none&width=259" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><ul><li>origin：基线的原点</li><li>advance：排版中文字占据的空间</li><li>bearingX：文字之间的间距</li><li>yMin：文字基线距离文字底部的距离</li></ul><h3 id="行模型"><a href="#行模型" class="headerlink" title="行模型"></a>行模型</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608592669392-5b688eca-283f-4dcb-a9c6-e2d8b49d9a05.png#align=left&display=inline&height=210&margin=%5Bobject%20Object%5D&name=image.png&originHeight=838&originWidth=1276&size=241489&status=done&style=none&width=319" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608592669392-5b688eca-283f-4dcb-a9c6-e2d8b49d9a05.png#align=left&display=inline&height=210&margin=%5Bobject%20Object%5D&name=image.png&originHeight=838&originWidth=1276&size=241489&status=done&style=none&width=319" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><ul><li><p>base-line：基线，文字默认对齐的线</p></li><li><p>text-top、text-bottom：文字的上下边缘线</p><blockquote><p>只要字体的大小不变，text-top 和 text-bottom 就是不变的<br>如果用了多种字体混排的话，那么这个文字的上下边缘就是有 font-size 最大的字体决定的。<br>我们基本可以认为这两条线是固定不变的</p></blockquote></li><li><p>line-top、line-bottom：行的上下边缘线</p><blockquote><p>这两条线的产生是因为行高大于文字的高度</p></blockquote></li></ul><h3 id="文字和盒混排时产生的问题"><a href="#文字和盒混排时产生的问题" class="headerlink" title="文字和盒混排时产生的问题"></a>文字和盒混排时产生的问题</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608593084262-c9db1a4c-cc9d-4337-a842-b06660122bd6.png#align=left&display=inline&height=238&margin=%5Bobject%20Object%5D&name=image.png&originHeight=950&originWidth=1854&size=397540&status=done&style=none&width=464" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608593084262-c9db1a4c-cc9d-4337-a842-b06660122bd6.png#align=left&display=inline&height=238&margin=%5Bobject%20Object%5D&name=image.png&originHeight=950&originWidth=1854&size=397540&status=done&style=none&width=464" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>当一个行内盒是按照 text-bottom 来对齐的话，它就会撑开该行的高度，造成偏移的情况。</p><blockquote><p>当没有蓝色的行内盒的时候，只有文字那么该盒是只有 text-top 和 text-bottom 的高度时，文字看起来排版就比较正常，但是当蓝色盒子出现的时候撑开了 line-top，导致该行整体高度都被撑开了，那么文字相较之前的就会看起来偏下了许多。</p></blockquote><p>Eg：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 50px; line-height: 100px; background-color: bisque&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello good 国<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  &lt;div</span><br><span class="line">    style=&quot;</span><br><span class="line">          display: inline-block;</span><br><span class="line">          line-height: 70px;</span><br><span class="line">          width: 100px;</span><br><span class="line">          height: 150px;</span><br><span class="line">          background-color: cadetblue;</span><br><span class="line">        &quot;</span><br><span class="line">  &gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：<br>文字正常情况按照基线对齐：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608594613929-d627e469-a14d-43ac-8262-8bf03832cfc2.png#align=left&display=inline&height=121&margin=%5Bobject%20Object%5D&name=image.png&originHeight=242&originWidth=722&size=51691&status=done&style=none&width=361" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608594613929-d627e469-a14d-43ac-8262-8bf03832cfc2.png#align=left&display=inline&height=121&margin=%5Bobject%20Object%5D&name=image.png&originHeight=242&originWidth=722&size=51691&status=done&style=none&width=361" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>当我们添加一个行内盒的时候：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608594091726-0caea8c5-9407-453f-b4b4-e5c209ff6a65.png#align=left&display=inline&height=93&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=1092&size=82717&status=done&style=none&width=273" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608594091726-0caea8c5-9407-453f-b4b4-e5c209ff6a65.png#align=left&display=inline&height=93&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=1092&size=82717&status=done&style=none&width=273" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>蓝色的线是 line-top，就被撑开了（该行的整体高度被撑开）。绿色的线是 text-top，行内盒不会影响 text 的边缘线高度。<br>当我们在行内盒添加上一个文字时：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608594403003-766b921d-5f40-4926-abfc-4ecfbc4da80c.png#align=left&display=inline&height=90&margin=%5Bobject%20Object%5D&name=image.png&originHeight=358&originWidth=1006&size=87363&status=done&style=none&width=252" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608594403003-766b921d-5f40-4926-abfc-4ecfbc4da80c.png#align=left&display=inline&height=90&margin=%5Bobject%20Object%5D&name=image.png&originHeight=358&originWidth=1006&size=87363&status=done&style=none&width=252" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>这种情况就相当于，当一个行内盒中有了文字之后，那么对齐的时候就会按照文字的基线去对齐<br>当我们呢在行内盒再添加一个换行和文字时：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608594527028-d79e9601-b55a-46f6-bf8c-42d524096579.png#align=left&display=inline&height=89&margin=%5Bobject%20Object%5D&name=image.png&originHeight=354&originWidth=964&size=94340&status=done&style=none&width=241" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608594527028-d79e9601-b55a-46f6-bf8c-42d524096579.png#align=left&display=inline&height=89&margin=%5Bobject%20Object%5D&name=image.png&originHeight=354&originWidth=964&size=94340&status=done&style=none&width=241" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>会按照最下面文字的基线去进行对齐<br>上面的演示代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 50px; line-height: 100px; background-color: bisque&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- line-top --&gt;</span></span><br><span class="line">  &lt;div</span><br><span class="line">    style=&quot;</span><br><span class="line">          vertical-align: top;</span><br><span class="line">          width: 1px;</span><br><span class="line">          height: 1px;</span><br><span class="line">          display: inline-block;</span><br><span class="line">        &quot;</span><br><span class="line">  &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100vw; height: 1px; background-color: blue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- text-top --&gt;</span></span><br><span class="line">  &lt;div</span><br><span class="line">    style=&quot;</span><br><span class="line">          vertical-align: text-top;</span><br><span class="line">          width: 1px;</span><br><span class="line">          height: 1px;</span><br><span class="line">          display: inline-block;</span><br><span class="line">        &quot;</span><br><span class="line">  &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100vw; height: 1px; background-color: green&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 基线 --&gt;</span></span><br><span class="line">  &lt;div</span><br><span class="line">    style=&quot;</span><br><span class="line">          vertical-align: baseline;</span><br><span class="line">          width: 1px;</span><br><span class="line">          height: 1px;</span><br><span class="line">          display: inline-block;</span><br><span class="line">        &quot;</span><br><span class="line">  &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100vw; height: 1px; background-color: red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- text-bottom --&gt;</span></span><br><span class="line">  &lt;div</span><br><span class="line">    style=&quot;</span><br><span class="line">          vertical-align: text-bottom;</span><br><span class="line">          width: 1px;</span><br><span class="line">          height: 1px;</span><br><span class="line">          display: inline-block;</span><br><span class="line">        &quot;</span><br><span class="line">  &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100vw; height: 1px; background-color: green&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- line-bottom --&gt;</span></span><br><span class="line">  &lt;div</span><br><span class="line">    style=&quot;</span><br><span class="line">          vertical-align: bottom;</span><br><span class="line">          width: 1px;</span><br><span class="line">          height: 1px;</span><br><span class="line">          display: inline-block;</span><br><span class="line">        &quot;</span><br><span class="line">  &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100vw; height: 1px; background-color: blue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello good 国<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  &lt;div</span><br><span class="line">    style=&quot;</span><br><span class="line">          display: inline-block;</span><br><span class="line">          line-height: 70px;</span><br><span class="line">          width: 100px;</span><br><span class="line">          height: 150px;</span><br><span class="line">          background-color: cadetblue;</span><br><span class="line">        &quot;</span><br><span class="line">  &gt;</span><br><span class="line">    M N</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="正常流的块级排布（BFC"><a href="#正常流的块级排布（BFC" class="headerlink" title="正常流的块级排布（BFC)"></a>正常流的块级排布（BFC)</h2><h3 id="float-和-clear"><a href="#float-和-clear" class="headerlink" title="float 和 clear"></a>float 和 clear</h3><p>float：</p><ul><li>严格来说是已经脱离文档流的，他在排列时可以完成图文环绕排的形式。</li><li>多个 float 元素会依次排列，不会占据对方的空间</li><li><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608854033824-58eec322-5bd5-4d17-a5b4-c8d43b51202c.png#align=left&display=inline&height=66&margin=%5Bobject%20Object%5D&name=image.png&originHeight=264&originWidth=1400&size=15569&status=done&style=none&width=350" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608854033824-58eec322-5bd5-4d17-a5b4-c8d43b51202c.png#align=left&display=inline&height=66&margin=%5Bobject%20Object%5D&name=image.png&originHeight=264&originWidth=1400&size=15569&status=done&style=none&width=350" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></li><li>float 会造成重排的问题</li></ul><p>clear：与其说是清除浮动，不如说是在某个方向上找个干净的地方去完成浮动的排列</p><ul><li>与上面同样的代码，只要给第二个 float 的红色 div 设置 <code>clear: right</code>  就可以实现下面这种效果</li><li><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608854110759-07d731d4-93c2-4726-97bf-81e708a9a0f3.png#align=left&display=inline&height=60&margin=%5Bobject%20Object%5D&name=image.png&originHeight=242&originWidth=1405&size=14317&status=done&style=none&width=351" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608854110759-07d731d4-93c2-4726-97bf-81e708a9a0f3.png#align=left&display=inline&height=60&margin=%5Bobject%20Object%5D&name=image.png&originHeight=242&originWidth=1405&size=14317&status=done&style=none&width=351" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></li><li>所以说 clear 更像是在右面找了一个干净的地方进行浮动排列</li></ul><h3 id="margin-折叠"><a href="#margin-折叠" class="headerlink" title="margin 折叠"></a>margin 折叠</h3><p>这种现象只会发生在正常流中，在正常流中只有 BFC 才会有！</p><p>上下两个块级元素都有 margin 的情况下，在排列的时候会选取一个 margin 的最大值作为其最终排版的结果<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608854541877-e2831a64-ad81-4f32-a22f-9b377bd8495f.png#align=left&display=inline&height=188&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1212&originWidth=1650&size=172874&status=done&style=none&width=256" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608854541877-e2831a64-ad81-4f32-a22f-9b377bd8495f.png#align=left&display=inline&height=188&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1212&originWidth=1650&size=172874&status=done&style=none&width=256" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png">  =====&gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608854549792-733a8918-101f-4602-bcbf-2c216a5fe612.png#align=left&display=inline&height=188&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1098&originWidth=1714&size=173370&status=done&style=none&width=294" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608854549792-733a8918-101f-4602-bcbf-2c216a5fe612.png#align=left&display=inline&height=188&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1098&originWidth=1714&size=173370&status=done&style=none&width=294" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="BFC-合并"><a href="#BFC-合并" class="headerlink" title="BFC 合并"></a>BFC 合并</h3><ul><li>Block Container： 里面有 BFC<ul><li>能容纳正常流的盒，里面就有 BFC</li></ul></li><li>BLock-level Box： 外面有 BFC 的</li><li>Block Box = Block container + Block-level Box：里外都有 BFC 的</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pseudo-element: 伪元素</title>
      <link href="2020/12/20/yuque/Pseudo-element!%20%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
      <url>2020/12/20/yuque/Pseudo-element!%20%E4%BC%AA%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<ul><li>::before</li><li>::after</li><li>::first-line 选中第一行</li><li>::first-letter 选中第一个字母</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &lt;::before/&gt; content content content content content content content content</span><br><span class="line">  &lt;::after/&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &lt;::first-letter&gt;c&lt;/::first-letter&gt;ontent content content content</span><br><span class="line">  content content content content</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>first-line 和 first-letter 支持的 css 属性设置：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608462752667-ab307525-ef39-4e99-a142-3fff7b41e87f.png#align=left&display=inline&height=726&margin=%5Bobject%20Object%5D&name=image.png&originHeight=726&originWidth=1638&size=537528&status=done&style=none&width=1638" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608462752667-ab307525-ef39-4e99-a142-3fff7b41e87f.png#align=left&display=inline&height=726&margin=%5Bobject%20Object%5D&name=image.png&originHeight=726&originWidth=1638&size=537528&status=done&style=none&width=1638" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Calculating specificity：计算优先级</title>
      <link href="2020/12/20/yuque/Calculating%20specificity%EF%BC%9A%E8%AE%A1%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>2020/12/20/yuque/Calculating%20specificity%EF%BC%9A%E8%AE%A1%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><p>为给定元素计算它的优先级，遵循以下原则：</p><ul><li>计算 ID 选择器的值  A</li><li>计算类选择、属性选择器、伪类选择器的值  B</li><li>计算标签选择器和伪元素选择器的值  C</li><li>忽略通用选择器*</li></ul><ol><li><p>:is()、:not()、:has(),这三个伪类选择器的计算值将被其中优先级最高的值所代替</p><blockquote><p>eg:<br>:is(#id)   [1,0,0] 伪类的优先级值 B 被 id 的高优先值所代替</p></blockquote></li><li><p>类似的, :nth-child()、：nth-last-child()的计算值是一个伪类的值加上参数的计算值之和。</p><blockquote><p>eg:<br>:nth-child(.item)  [0,2,0]   伪类的值加上参数.item 的值</p></blockquote></li><li><p>:where() 伪类的计算值为 0</p><blockquote><p>eg:<br>.item:where(em,#foo)  [0,1,0]  where 伪类的值为 0</p></blockquote></li></ol><p>【A，B，C】</p><blockquote><ul><li>/_ a=0 b=0 c=0 <em>/<br>LI                                      /</em> a=0 b=0 c=1 <em>/<br>UL LI                                  /</em> a=0 b=0 c=2 <em>/<br>UL OL+LI                           /</em> a=0 b=0 c=3 _/<br>H1 + <em>[REL=up]                  /</em> a=0 b=1 c=1 <em>/<br>UL OL LI.red                      /</em> a=0 b=1 c=3 <em>/<br>LI.red.level                        /</em> a=0 b=2 c=1 <em>/<br>#x34y                               /</em> a=1 b=0 c=0 <em>/<br>#s12:not(FOO)                   /</em> a=1 b=0 c=1 <em>/<br>.foo :is(.bar, #baz)             /</em> a=1 b=1 c=0 */</li></ul></blockquote><p>官方文档是按照 3 位来计算优先级的，就是上图中的：<br>[A, B, C]<br>还有一种计算方式是按照四位来计算的，最高位表示是否为行内样式：<br>[ L, A, B, C]</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-id">#a</span><span class="selector-class">.b</span> <span class="selector-class">.c</span><span class="selector-attr">[id=x]</span> <span class="selector-attr">[0, 1, 3, 1]</span></span><br><span class="line"><span class="selector-id">#a</span><span class="selector-pseudo">:not(</span><span class="selector-id">#b</span>) <span class="selector-attr">[0, 2, 0, 0]</span></span><br><span class="line">*<span class="selector-class">.a</span> <span class="selector-attr">[0, 0, 1, 0]</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.a</span> <span class="selector-attr">[0, 0, 1, 1]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pseudo-Class：伪类</title>
      <link href="2020/12/20/yuque/Pseudo-Class%EF%BC%9A%E4%BC%AA%E7%B1%BB/"/>
      <url>2020/12/20/yuque/Pseudo-Class%EF%BC%9A%E4%BC%AA%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="链接-行为"><a href="#链接-行为" class="headerlink" title="链接/行为"></a>链接/行为</h2><p>之前这些伪类的实现都是为了超链接设计的，但是现在有很多伪类都可以用到其他元素上了。</p><ul><li><p>:any-link 任何超链接</p></li><li><p>:link 没有访问过的超链接</p></li><li><p>:visited     已经访问过的超链接</p><blockquote><p>any-link 可以看做是 link 和 visited 的结合<br>Tips：<br>一旦使用了 link 或者 visited 伪类之后，就没有办法去修改除了颜色以外的 css 属性了。<br>这样做是为了浏览器安全考虑的。因为一旦你更改了像 visited 超链接的大小的时候，就可以让别人明显感受到你访问过哪些网站，这对于用户来说是不太容易接受的，就像泄漏了隐私一样，也不符合浏览器安全的相关策略。</p></blockquote></li><li><p>:hover</p></li><li><p>:active</p></li><li><p>:focus</p></li><li><p>:target</p></li></ul><h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><ul><li>:empty</li><li>:nth-child()     从前让后数</li><li>:nth-last-child() 从后往前数</li><li>:first-child</li><li>:last-child</li><li>:only-child</li></ul><h2 id="逻辑型"><a href="#逻辑型" class="headerlink" title="逻辑型"></a>逻辑型</h2><ul><li>:not 伪类</li><li>:where</li><li>:has</li></ul><p>在 css 书写过程中，我们不应该写过于复杂的选择器，这样一是对性能不好，二是可能自己 HTML 结构设计的有问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Selector: 选择器</title>
      <link href="2020/12/20/yuque/Selector!%20%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>2020/12/20/yuque/Selector!%20%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h3><ul><li>-</li><li>div、svg、a</li><li>.class</li><li>#id</li><li>[attr=value]</li><li>:hover</li><li>::before</li></ul><h3 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h3><ul><li>&lt;简单选择器&gt;&lt;简单选择器&gt;&lt;简单选择器&gt;</li><li><ul><li>或者 div 必须写在最前面</li></ul></li></ul><h3 id="复杂选择器"><a href="#复杂选择器" class="headerlink" title="复杂选择器"></a>复杂选择器</h3><ul><li>&lt;复合选择器&gt;<sp>&lt;复合选择器&gt;</li><li>&lt;复合选择器&gt;”&gt;”&lt;复合选择器&gt;</li><li>&lt;复合选择器&gt;”~”&lt;复合选择器&gt;</li><li>&lt;复合选择器&gt;”+”&lt;复合选择器&gt;</li><li>&lt;复合选择器&gt;”||”&lt;复合选择器&gt;</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>翻译记录</title>
      <link href="2020/12/15/yuque/%E7%BF%BB%E8%AF%91%E8%AE%B0%E5%BD%95/"/>
      <url>2020/12/15/yuque/%E7%BF%BB%E8%AF%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Selectors-Level-4"><a href="#Selectors-Level-4" class="headerlink" title="Selectors Level 4"></a>Selectors Level 4</h2><h3 id="Selector-syntax-选择器语法）"><a href="#Selector-syntax-选择器语法）" class="headerlink" title="Selector syntax(选择器语法）"></a>Selector syntax(选择器语法）</h3><p>一个选择器是由一个或者多个简单选择器序列组合而成的，他们通过<strong>连接符（Combinators）</strong>分割开。并且在一个选择器中的最后一个简单选择器的末尾可以添加一个伪元素。</p><p>简单选择器序列（sequences of simple selectors)：由一连串没有使用<strong>连接符（Combinators）</strong>分割开来的简单选择器组合而成。通常是由标签选择器（h1、div）和通用选择器（*）作为开头。在简单选择器序列中不允许其他的标签选择器或者是通用选择器。</p><p>简单选择器（simple selectors）：</p><ul><li>标签选择器(h1)</li><li>通用选择器(*)</li><li>属性选择器（[])</li><li>类选择器(.)</li><li>id 选择器(#)</li><li>伪类选择器（::)</li></ul><p>连接符（Combinators）：</p><ul><li>whitespace 空格</li><li><blockquote></blockquote></li><li>-</li><li>~</li></ul><h2 id="Calculating-a-selector’s-specificity-计算选择器的优先级）"><a href="#Calculating-a-selector’s-specificity-计算选择器的优先级）" class="headerlink" title="Calculating a selector’s specificity(计算选择器的优先级）"></a>Calculating a selector’s specificity(计算选择器的优先级）</h2><p>为给定元素计算它的优先级，遵循以下原则：</p><ul><li>计算 ID 选择器的值 A</li><li>计算类选择、属性选择器、伪类选择器的值 B</li><li>计算标签选择器和伪元素选择器的值 C</li><li>忽略通用选择器*</li></ul><ol><li><p>:is()、:not()、:has(),这三个伪类选择器的计算值将被其中优先级最高的值所代替</p><blockquote><p>eg:<br>:is(#id) [1,0,0] 伪类的优先级值 B 被 id 的高优先值所代替</p></blockquote></li><li><p>类似的, :nth-child()、：nth-last-child()的计算值是一个伪类的值加上参数的计算值之和。</p><blockquote><p>eg:<br>:nth-child(.item) [0,2,0] 伪类的值加上参数.item 的值</p></blockquote></li><li><p>:where() 伪类的计算值为 0</p><blockquote><p>eg:<br>.item:where(em,#foo) [0,1,0] where 伪类的值为 0</p></blockquote></li></ol><p>【A，B，C】</p><blockquote><ul><li>/_ a=0 b=0 c=0 <em>/<br>LI                                      /</em> a=0 b=0 c=1 <em>/<br>UL LI                                  /</em> a=0 b=0 c=2 _/</li></ul></blockquote><blockquote><p>UL OL+LI                           /_ a=0 b=0 c=3 _/</p></blockquote><blockquote><p>H1 + <em>[REL=up]                  /</em> a=0 b=1 c=1 */</p></blockquote><blockquote><p>UL OL LI.red                      /_ a=0 b=1 c=3 _/</p></blockquote><blockquote><p>LI.red.level                        /_ a=0 b=2 c=1 _/</p></blockquote><blockquote><p>#x34y                               /_ a=1 b=0 c=0 _/</p></blockquote><blockquote><p>#s12:not(FOO)                   /_ a=1 b=0 c=1 _/</p></blockquote><blockquote><p>.foo :is(.bar, #baz)             /_ a=1 b=1 c=0 _/</p></blockquote><h2 id="Grammar"><a href="#Grammar" class="headerlink" title="Grammar"></a>Grammar</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS结构</title>
      <link href="2020/12/14/yuque/CSS%E7%BB%93%E6%9E%84/"/>
      <url>2020/12/14/yuque/CSS%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>因为找不到一个明确的语法线索，所以我们这里根据 2.1 版本的语法来进行学习。<br>现版本 css 多了很多 css3 的语法，但是不影响我们理解他的语法结构。</p><h2 id="CSS2-1-语法"><a href="#CSS2-1-语法" class="headerlink" title="CSS2.1 语法"></a>CSS2.1 语法</h2><ul><li><a href="http://www.ayqy.net/doc/css2-1/grammar.html">css2.1Grammar 中文对照版</a></li></ul><h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p>一个样式文件从上到下的顺序结构：</p><ol><li><p>@charset</p><blockquote><p><code>@charset &#39;UTF-8&#39;;</code> <br>声明 css 文件的字符编码标准。</p><ul><li>必须在样式表的第一行声明</li><li>如果有多个@charset 声明，那么只有第一个会生效</li><li>无法在 HTML 的 style 标签里使用该 at-rule 规则</li></ul><p>Tip:<br>在样式表中声明字符编码有很多种方式，浏览器会按照以下顺序去尝试确定文件的编码方式（只要找到一种就会停止并得出结果）：</p><ol><li>文件开头的  <a href="http://en.wikipedia.org/wiki/Byte_order_mark">Unicode byte-order</a>  字符值</li><li>由 Content-type 确定：HTTP 协议中的  charset 属性给出的值或用于提供样式表的协议中的等效值</li><li>CSS @rule 规则：@charset</li><li>假设文档上是 UTF-8 的格式</li></ol></blockquote></li><li><p>@import</p></li><li><p>rules （这部分是我们日常最常用到的部分）</p><ol><li>@media</li><li>@page</li><li>rule</li></ol></li></ol><h2 id="CSS-规则的结构"><a href="#CSS-规则的结构" class="headerlink" title="CSS 规则的结构"></a>CSS 规则的结构</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="comment">/* selector */</span> &#123;</span><br><span class="line">  <span class="comment">/* key */</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="comment">/* value */</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的 css 代码可以明确 css 规则的结构分为以下两个部分：</p><ol><li>Selector（选择器）</li><li>Declare（声明）<ol><li>key</li><li>value</li></ol></li></ol><h2 id="爬取-w3c-的-css-规则"><a href="#爬取-w3c-的-css-规则" class="headerlink" title="爬取 w3c 的 css 规则"></a>爬取 w3c 的 css 规则</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(</span><br><span class="line">  <span class="built_in">Array</span>.prototype.slice</span><br><span class="line">    .call(<span class="built_in">document</span>.querySelector(<span class="string">&quot;#container&quot;</span>).children)</span><br><span class="line">    .filter(<span class="function">(<span class="params">e</span>) =&gt;</span> e.getAttribute(<span class="string">&quot;data-tag&quot;</span>).match(<span class="regexp">/css/</span>))</span><br><span class="line">    .map(<span class="function">(<span class="params">e</span>) =&gt;</span> (&#123;</span><br><span class="line">      name: e.children[<span class="number">1</span>].children[<span class="number">0</span>].innerText,</span><br><span class="line">      url: e.children[<span class="number">1</span>].children[<span class="number">0</span>].href,</span><br><span class="line">    &#125;))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/2705850/1608424173469-cf7b1df7-98e3-4d61-aa22-74c472f7e380.jpeg" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/jpeg/2705850/1608424173469-cf7b1df7-98e3-4d61-aa22-74c472f7e380.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>链表篇</title>
      <link href="2020/12/10/yuque/%E9%93%BE%E8%A1%A8%E7%AF%87/"/>
      <url>2020/12/10/yuque/%E9%93%BE%E8%A1%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>本次升级之路分模块，逐个击破。</p><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607580712472-aa946439-2c33-4dd1-ad35-728f50aba1f6.png#align=left&display=inline&height=319&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=918&size=22654&status=done&style=none&width=918" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607580712472-aa946439-2c33-4dd1-ad35-728f50aba1f6.png#align=left&display=inline&height=319&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=918&size=22654&status=done&style=none&width=918" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>这是个经典的链表问题，其实这个问题的关键就在于要<strong>提前保存下一个节点</strong>的值。</p></blockquote><blockquote><p>因为你在让当前节点指向上一个节点的过程中，就会把当前节点的 next 指向改变，如果不提前保存当前节点的 next 值的话，就会找不到原有的当前节点的 next 值。</p></blockquote><ol><li>迭代大法<ol><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> reverList = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cur = head;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">  <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">    <span class="comment">// 记录当前节点的下一个节点</span></span><br><span class="line">    tmp = cur.next;</span><br><span class="line">    <span class="comment">// 改变当前节点的next指针指向</span></span><br><span class="line">    cur.next = prev;</span><br><span class="line">    <span class="comment">// 更新上一个节点的值</span></span><br><span class="line">    prev = cur;</span><br><span class="line">    <span class="comment">// 更新当前节点</span></span><br><span class="line">    cur = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>递归方法<ol><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverList = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> rever = <span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 严谨性判断，当cur为空时链表翻转结束</span></span><br><span class="line">    <span class="keyword">if</span> (!cur) <span class="keyword">return</span> prev;</span><br><span class="line">    <span class="comment">// 提前保存上一个节点的值</span></span><br><span class="line">    <span class="keyword">const</span> tmp = cur.next;</span><br><span class="line">    cur.next = prev;</span><br><span class="line">    <span class="keyword">return</span> rever(cur, tmp);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> rever(<span class="literal">null</span>, head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="2020/12/10/yuque/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>2020/12/10/yuque/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>线性表是 n 个元素的<strong>有限</strong>序列，最常用的是<strong>链式表达式，</strong>通常也叫作<strong>线性链表</strong>或者<strong>链表。</strong><br>**<br>在链表中存储的数据元素也叫作*<em>节点，\</em>*一个节点存储的就是一条数据记录。<br>每个节点的结构包括两个部分：</p><ol><li>具体的数据值</li><li>指向下一个节点的指针</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607567010381-356ba543-6cba-4ef6-91ab-f86c874b14e8.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=159&size=910&status=done&style=none&width=159" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607567010381-356ba543-6cba-4ef6-91ab-f86c874b14e8.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=159&size=910&status=done&style=none&width=159" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>在链表的最前面通常有一个<strong>头指针</strong>用来指向第一个节点。<br>对于链表的最后一个节点，由于在他之后没有下一个节点，因此它的指针是一个<strong>空指针。</strong><br>**</p><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607566998007-7eb2e286-606b-4997-aed6-2e7934b20015.png#align=left&display=inline&height=106&margin=%5Bobject%20Object%5D&name=image.png&originHeight=131&originWidth=721&size=5098&status=done&style=none&width=584" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607566998007-7eb2e286-606b-4997-aed6-2e7934b20015.png#align=left&display=inline&height=106&margin=%5Bobject%20Object%5D&name=image.png&originHeight=131&originWidth=721&size=5098&status=done&style=none&width=584" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><blockquote><p>如上图所示：只能通过上一个节点的指针找到下一个节点，而不能通过下一个节点去找到上一个节点</p></blockquote><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607568508498-ae10d7f7-ae94-4fca-94c4-0e91af21feeb.png#align=left&display=inline&height=107&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=666&size=5026&status=done&style=none&width=573" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607568508498-ae10d7f7-ae94-4fca-94c4-0e91af21feeb.png#align=left&display=inline&height=107&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=666&size=5026&status=done&style=none&width=573" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><blockquote><p>让最后一个元素的指针指向第一个元素，就形成了循环链表</p></blockquote><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607568635088-458b72fc-2265-4c16-ac27-766a45c35168.png#align=left&display=inline&height=94&margin=%5Bobject%20Object%5D&name=image.png&originHeight=111&originWidth=691&size=4776&status=done&style=none&width=584" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607568635088-458b72fc-2265-4c16-ac27-766a45c35168.png#align=left&display=inline&height=94&margin=%5Bobject%20Object%5D&name=image.png&originHeight=111&originWidth=691&size=4776&status=done&style=none&width=584" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><blockquote><p>给每个元素增加一个指向上一个元素的指针就形成了双向链表<br>双向链表可以通过自身查找到上一个元素，也可以查找到下一个元素</p></blockquote><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><blockquote><p>同样的还可以将双向链表和循环链表相结合，形成双向循环链表</p></blockquote><h2 id="单向链表的增删查"><a href="#单向链表的增删查" class="headerlink" title="单向链表的增删查"></a>单向链表的增删查</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>当我们想要在一个链表<strong>A</strong>节点和<strong>B</strong>节点的中间增加节点<strong>C</strong>时，需要进行以下两步：</p><ol><li>使 C 节点的 net 等于 A 节点的 next</li><li>改变 A 节点的 next 等于 C 节点<blockquote><p>第一步和第二步的顺序不能调换，如果先执行第一步的话，那么就没办法获取到指向 B 节点的指针了，除非是新建一个变量提前缓存该指针</p></blockquote></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607571219091-ccbdcb0d-d048-463b-8b86-9aca0faad5ac.png#align=left&display=inline&height=175&margin=%5Bobject%20Object%5D&name=image.png&originHeight=202&originWidth=692&size=7827&status=done&style=none&width=601" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607571219091-ccbdcb0d-d048-463b-8b86-9aca0faad5ac.png#align=left&display=inline&height=175&margin=%5Bobject%20Object%5D&name=image.png&originHeight=202&originWidth=692&size=7827&status=done&style=none&width=601" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C.next = A.next;</span><br><span class="line">A.next = C;</span><br></pre></td></tr></table></figure><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>当我们想要在一个链表中删除<strong>B</strong>节点时，需要进行以下一步：</p><ol><li>使 A 的 next 等于 B 的 next<blockquote><p>这里需要注意，A.next = B， 所以我们在处理这一步的时候，完全可以写成 <code>A.next = A.next.next</code> ;</p></blockquote></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.next = A.next.next;</span><br></pre></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>链表这种数据结构对于查找操作来说是<strong>弱项。</strong><br>因为链表的查找只能从第一个节点开始，逐个查找。</p><p>通过上面的增删查操作我们可以明显感知到，链表这种数据结构在<strong>增、删</strong>的操作上是比较方便的，可以在<strong>O(1)的时间复杂度</strong>内完成，但是<strong>查</strong>的话就是<strong>O(n)的时间复杂度</strong>了。<br>但是链表在增删上的优势并不明显，因为我们在增删的时候往往会伴随着查找的动作，比如我们在第五个节点后面添加一个新的节点，就会有这样的过程：</p><ol><li>查找到链表中的第 5 个节点</li><li>在他后面新增节点</li></ol><p>那这么说链表就没什么用了吗？</p><p>当然不是，链表的真正价值在于它存储的数据方式是按照顺序进行关联存储的，如果对于元素个数不确定，并且经常进行增删的数据来说，链表是比较合适的</p><blockquote><p>链表在内存中可以存储在不连续的内存空间内<br>因为链表的顺序关联是通过指针进行关联的<br>所以对于不确定元素个数的数据来说，存储在内存空间中的各个位置，然后通过 next 指针关联是较好的</p></blockquote><p>对于元素个数确定的数据，那么数组就是比较好的选择了</p><blockquote><p>数组在内存中开辟的是一块固定的连续内存空间</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>useCallback</title>
      <link href="2020/12/08/yuque/useCallback/"/>
      <url>2020/12/08/yuque/useCallback/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Toy-Brower</title>
      <link href="2020/12/02/yuque/Toy-Brower/"/>
      <url>2020/12/02/yuque/Toy-Brower/</url>
      
        <content type="html"><![CDATA[<p>为了更加了解浏览器的工作原理，我们来自己用代码搞一个浏览器玩一下。</p><h2 id="基本功能描述"><a href="#基本功能描述" class="headerlink" title="基本功能描述"></a>基本功能描述</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607396985290-ee9fbd15-7e2e-4ab0-9f71-7adf34a29f88.png#align=left&display=inline&height=178&margin=%5Bobject%20Object%5D&name=image.png&originHeight=178&originWidth=1506&size=163962&status=done&style=none&width=1506" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607396985290-ee9fbd15-7e2e-4ab0-9f71-7adf34a29f88.png#align=left&display=inline&height=178&margin=%5Bobject%20Object%5D&name=image.png&originHeight=178&originWidth=1506&size=163962&status=done&style=none&width=1506" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="HTTP-实现"><a href="#HTTP-实现" class="headerlink" title="HTTP 实现"></a>HTTP 实现</h3><p>为了实现浏览器发送网络请求的这一部分，需要梳理一下这部分所需要的功能。</p><ol><li><p>构建请求信息（请求方法、请求行、请求头、请求体）</p></li><li><p>建立网络连接（net.createServer()）</p></li><li><p>接收响应结果</p></li><li><p>处理响应结果</p><ol><li>处理响应头</li><li>处理响应体 - 利用单独的子类进行 body text 的处理</li></ol></li><li><p>构造一个发送请求的类 <code>Request</code></p><blockquote><p>思考：这个类都需要什么东西？</p><ul><li>首先需要一些发送请求时需要配置的基本配置项（options）<ul><li>url    请求路径</li><li>port     请求端口</li><li>method     请求方法</li><li>headers     请求头</li><li>body     请求体</li></ul></li><li>其次需要一个发送该请求的方法（send）<ul><li>该方法返回一个 promise 对象，该对象是请求回来的结果</li><li>该方法的功能：<ul><li>构造请求并发送，发送前需要拼接上请求行、请求头、换行、请求体等信息。</li><li>接受请求结果</li></ul></li></ul></li></ul></blockquote></li><li><p>构造一个解析响应的类 <code>ResponseParse</code></p><blockquote><ul><li>response 返回的结果需要分段来进行处理，所以我们需要一个 ResponseParse 来进行装配</li><li>ResponseParse 来分段处理返回的结果，我们用有限状态机来记录完成这一个过程</li><li>针对 response body 中的内容采用另一个方法进行分段解析</li></ul></blockquote></li><li><p>构造一个类 <code>TrunkedBodyParser</code></p><blockquote><ul><li>response body 针对不通的 Content-type 类型会有不同的处理方法</li><li>我们这里针对 chunk 类型进行解析</li></ul></blockquote></li></ol><hr><h3 id="HTML-解析的实现"><a href="#HTML-解析的实现" class="headerlink" title="HTML 解析的实现"></a>HTML 解析的实现</h3><ol><li>接收响应体进行解析</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607643059789-38ccd590-7e2b-42a1-8852-b7b75fa9d219.png#align=left&display=inline&height=64&margin=%5Bobject%20Object%5D&name=image.png&originHeight=128&originWidth=1108&size=79721&status=done&style=none&width=554" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607643059789-38ccd590-7e2b-42a1-8852-b7b75fa9d219.png#align=left&display=inline&height=64&margin=%5Bobject%20Object%5D&name=image.png&originHeight=128&originWidth=1108&size=79721&status=done&style=none&width=554" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><ol start="2"><li><p>构造状态机进行标签解析</p><ol><li>开始标签<ol><li><code>&lt;</code>  开始标签的标志</li><li><code>/n/t </code>  空格标志后面是标签属性</li></ol></li><li>结束标签<ol><li><code>/</code>  结束标签的标志</li><li><code>&gt;</code>  标签解析结束，开始下一个标签解析</li></ol></li><li>自封闭标签<ol><li><code>&lt;/</code>  自闭和标签的标志</li></ol></li></ol></li><li><p>利用 currentToken 变量接受解析结果</p><ol><li><code>text</code>文本类型</li><li><code>statTag</code>开始标签类型</li><li><code>endTag</code>结束标签类型</li><li><code>isSelfCloseTag</code>自闭和标签标志<blockquote><p>每次当前标签结束时需要<code>emit(currentToken)</code>来触发当前标签结束的事件</p></blockquote></li></ol></li><li><p>解析标签属性</p><ol><li>氛围 attributeName 和 value 两部分进行解析</li><li>解析完成之后 emit 对应数据</li></ol></li><li><p>构建 DOM 树</p><ol><li>使用栈进行构造</li><li>遇到开始标签就处理好相关属性和元素名入栈</li><li>遇到自闭和标签就相当入栈后立即出栈</li><li>遇到闭合标签就找到对应标签出栈</li></ol></li></ol><h3 id="CSS-计算"><a href="#CSS-计算" class="headerlink" title="CSS 计算"></a>CSS 计算</h3><ol><li>遇到 style 标签时，将 css 规则保存起来，使用 css parser 解析规则</li><li>当创建一个元素后应立即计算 css<ol><li>理论上当我们分析一个元素时，是假设这个元素的 css 规则已经全部收集完毕的</li></ol></li><li>在 computedCss 函数中，我们需要知道所有元素的父元素才可以去判断元素是否与规则匹配<ol><li>由于我们首先获取的是当前元素，所以我们获得和计算父元素匹配的顺序是由内到外的</li></ol></li><li>选择器也是由内向外匹配排列的</li><li>根据选择器的类型和元素属性，计算是否当前的元素匹配</li><li>元素匹配完成就应用选择器到元素上，形成 computedSty</li><li>css 规则具有优先级，我们利用 specificity 特征去进行判断比较<ol><li>specificity 是一个四元组，越左边权重越重<ol><li>[0,0,0,]</li><li>inline、id、class、tag</li></ol></li><li>css 规则的 specificity 是根据所包含的简单选择器相加形成的<br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/2705850/1607825664969-8a234679-ac32-4c70-a494-6f6a7a466227.jpeg" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/jpeg/2705850/1607825664969-8a234679-ac32-4c70-a494-6f6a7a466227.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码效率优化方法论</title>
      <link href="2020/12/02/yuque/%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
      <url>2020/12/02/yuque/%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="如何衡量一段代码的优劣呢？"><a href="#如何衡量一段代码的优劣呢？" class="headerlink" title="如何衡量一段代码的优劣呢？"></a>如何衡量一段代码的优劣呢？</h2><p>一般我们会从两个维度去考虑一段代码的质量：</p><ol><li>时间复杂度</li><li>空间复杂度</li></ol><p>顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。<br>那么我们应该怎么取舍这两个标准呢？</p><h2 id="提高代码效率的方法"><a href="#提高代码效率的方法" class="headerlink" title="提高代码效率的方法"></a>提高代码效率的方法</h2><p>我们从上面已经知道了衡量代码效率的方法，那么我们应该怎么着手去优化提高我们代码的效率呢？</p><p>总的策略就是降低代码的时间复杂度和空间复杂度。</p><p>但是对于一段代码来说往往时间和空间两个是互斥的，如果我们想要降低时间复杂度，那么无疑就会增加空间复杂度。<br>举一个生活中的 🌰，就像我们平时生活中开车过红绿灯，如果只有这一条路（空间）那么我们就只能在这等着红灯，当车越来越多的时候，就会消耗大家很多时间，但是当我们修建了立交桥之后，就会有更多的选择空间，就会大大减少等待红灯的时间。<br><img src="https://cdn.nlark.com/yuque/0/2020/gif/2705850/1606953443121-946ba365-7a49-4689-8090-5e820840f5eb.gif#align=left&display=inline&height=720&margin=%5Bobject%20Object%5D&name=CgqCHl7CRMaAO_oEAJfz6fjfMNQ403.gif&originHeight=720&originWidth=1280&size=9958377&status=done&style=none&width=1280" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/2705850/1606953443121-946ba365-7a49-4689-8090-5e820840f5eb.gif#align=left&display=inline&height=720&margin=%5Bobject%20Object%5D&name=CgqCHl7CRMaAO_oEAJfz6fjfMNQ403.gif&originHeight=720&originWidth=1280&size=9958377&status=done&style=none&width=1280" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="CgqCHl7CRMaAO_oEAJfz6fjfMNQ403.gif"><br>（图片来自拉钩教育-公瑾老师的重学算法与数据结构一课中）<br>而对我们来说，时间永远都要比空间更加重要，因为时间拿钱买不来，而空间我们起码可以拿钱来进行扩容。<br><strong>空间是廉价的，时间是昂贵的</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1606953817114-7e1a263e-6acb-4bf2-9110-da34521c23f8.png#align=left&display=inline&height=76&margin=%5Bobject%20Object%5D&name=image.png&originHeight=152&originWidth=142&size=26430&status=done&style=none&width=71" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1606953817114-7e1a263e-6acb-4bf2-9110-da34521c23f8.png#align=left&display=inline&height=76&margin=%5Bobject%20Object%5D&name=image.png&originHeight=152&originWidth=142&size=26430&status=done&style=none&width=71" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></strong></p><ol><li>暴力解法：在没有任何时间和空间的限制下，将目标达成</li><li>剔除无效操作：将代码中没有必要的计算、无效的存储删除来优化时间和空间复杂度</li><li>时空转换：设计合理的数据结构，将时间向空间转换</li></ol><h2 id="增删查：数据的基本操作"><a href="#增删查：数据的基本操作" class="headerlink" title="增删查：数据的基本操作"></a>增删查：数据的基本操作</h2><p>一般一段算法的实现最常设计的三个操作就是：增、删、查。<br>而我们对一个算法的优化和实现只要围绕这三个为重心去思考展开即可：</p><ol><li>分析这段代码对数据进行了那些操作</li><li>这些操作中有哪些操作是最消耗性能的，对时间复杂度的损耗是最高的？</li><li>考虑有哪种数据结构可以帮助提高数据操作的使用效率。</li></ol><p>以上三点就是构成我们实现代码效率优化的方法论。</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ol><li>按照元素索引查找<ul><li>对于数组这些天生拥有索引的数据结构来说十分简单</li><li>对于链表这种，通过指针进行连接的就需要知道前面一个元素</li></ul></li><li>按照元素特征值查找<ul><li>对于字典类型的数据来说，key 就相当是特征，value 就是值，查找起来非常方便</li><li>对于数组和链表来说就需要循环对比每个元素来进行比较值的特征是否符合</li></ul></li></ol><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ol><li>在复杂数据结构的末尾添加数据<ul><li>不会影响数据的原始位置</li></ul></li><li>在复杂数据结构的中间添加数据<ul><li>会影响到数据原始的位置</li></ul></li></ol><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ol><li>在复杂数据结构的末尾删除<ul><li>不会影响到原先数据的位置</li></ul></li><li>在复杂数据结构的中间位置进行删除<ul><li>会影响到之前数据的原始位置</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

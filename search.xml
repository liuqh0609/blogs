<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>代码效率优化方法论</title>
      <link href="2021/04/08/%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
      <url>2021/04/08/%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="代码效率优化方法论"><a href="#代码效率优化方法论" class="headerlink" title="代码效率优化方法论"></a>代码效率优化方法论</h1><h2 id="如何衡量一段代码的优劣呢？"><a href="#如何衡量一段代码的优劣呢？" class="headerlink" title="如何衡量一段代码的优劣呢？"></a>如何衡量一段代码的优劣呢？</h2><p>一般我们会从两个维度去考虑一段代码的质量：</p><ol><li>时间复杂度</li><li>空间复杂度</li></ol><p>顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。<br>那么我们应该怎么取舍这两个标准呢？</p><h2 id="提高代码效率的方法"><a href="#提高代码效率的方法" class="headerlink" title="提高代码效率的方法"></a>提高代码效率的方法</h2><p>我们从上面已经知道了衡量代码效率的方法，那么我们应该怎么着手去优化提高我们代码的效率呢？</p><p>总的策略就是降低代码的时间复杂度和空间复杂度。</p><p>但是对于一段代码来说往往时间和空间两个是互斥的，如果我们想要降低时间复杂度，那么无疑就会增加空间复杂度。<br>举一个生活中的 🌰，就像我们平时生活中开车过红绿灯，如果只有这一条路（空间）那么我们就只能在这等着红灯，当车越来越多的时候，就会消耗大家很多时间，但是当我们修建了立交桥之后，就会有更多的选择空间，就会大大减少等待红灯的时间。<br><img src="https://cdn.nlark.com/yuque/0/2020/gif/2705850/1606953443121-946ba365-7a49-4689-8090-5e820840f5eb.gif#align=left&display=inline&height=720" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/2705850/1606953443121-946ba365-7a49-4689-8090-5e820840f5eb.gif#align=left&display=inline&height=720" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="CgqCHl7CRMaAO_oEAJfz6fjfMNQ403.gif"><br>（图片来自拉钩教育-公瑾老师的重学算法与数据结构一课中）<br>而对我们来说，时间永远都要比空间更加重要，因为时间拿钱买不来，而空间我们起码可以拿钱来进行扩容。<br><strong>空间是廉价的，时间是昂贵的</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1606953817114-7e1a263e-6acb-4bf2-9110-da34521c23f8.png#align=left&display=inline&height=76" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1606953817114-7e1a263e-6acb-4bf2-9110-da34521c23f8.png#align=left&display=inline&height=76" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></strong></p><ol><li>暴力解法：在没有任何时间和空间的限制下，将目标达成</li><li>剔除无效操作：将代码中没有必要的计算、无效的存储删除来优化时间和空间复杂度</li><li>时空转换：设计合理的数据结构，将时间向空间转换</li></ol><h2 id="增删查：数据的基本操作"><a href="#增删查：数据的基本操作" class="headerlink" title="增删查：数据的基本操作"></a>增删查：数据的基本操作</h2><p>一般一段算法的实现最常设计的三个操作就是：增、删、查。<br>而我们对一个算法的优化和实现只要围绕这三个为重心去思考展开即可：</p><ol><li>分析这段代码对数据进行了那些操作</li><li>这些操作中有哪些操作是最消耗性能的，对时间复杂度的损耗是最高的？</li><li>考虑有哪种数据结构可以帮助提高数据操作的使用效率。</li></ol><p>以上三点就是构成我们实现代码效率优化的方法论。</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ol><li>按照元素索引查找<ul><li>对于数组这些天生拥有索引的数据结构来说十分简单</li><li>对于链表这种，通过指针进行连接的就需要知道前面一个元素</li></ul></li><li>按照元素特征值查找<ul><li>对于字典类型的数据来说，key 就相当是特征，value 就是值，查找起来非常方便</li><li>对于数组和链表来说就需要循环对比每个元素来进行比较值的特征是否符合</li></ul></li></ol><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ol><li>在复杂数据结构的末尾添加数据<ul><li>不会影响数据的原始位置</li></ul></li><li>在复杂数据结构的中间添加数据<ul><li>会影响到数据原始的位置</li></ul></li></ol><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ol><li>在复杂数据结构的末尾删除<ul><li>不会影响到原先数据的位置</li></ul></li><li>在复杂数据结构的中间位置进行删除<ul><li>会影响到之前数据的原始位置</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度&amp;空间复杂度</title>
      <link href="2021/04/08/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>2021/04/08/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度&amp;空间复杂度"></a>时间复杂度&amp;空间复杂度</h1><h2 id="复杂度的作用"><a href="#复杂度的作用" class="headerlink" title="复杂度的作用"></a>复杂度的作用</h2><p>一般我们会从两个维度去考虑一段代码的质量：</p><ol><li>时间复杂度</li><li>空间复杂度</li></ol><p>顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。</p><p>所以时间复杂度和空间复杂度一般是用来衡量一段代码的优劣的。</p><p>那么我们应该怎么来定义复杂度呢？<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1606953725697-beedfd24-126b-4e4f-97cc-28d93d2321e1.png#align=left&display=inline&height=78&margin=%5Bobject%20Object%5D&name=image.png&originHeight=155&originWidth=198&size=27501&status=done&style=none&width=99" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1606953725697-beedfd24-126b-4e4f-97cc-28d93d2321e1.png#align=left&display=inline&height=78&margin=%5Bobject%20Object%5D&name=image.png&originHeight=155&originWidth=198&size=27501&status=done&style=none&width=99" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="复杂度的定义与特点"><a href="#复杂度的定义与特点" class="headerlink" title="复杂度的定义与特点"></a>复杂度的定义与特点</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>复杂度是一个关于输入量 n 的函数。<br>eg：假设你的代码复杂度是 f(n),那么用大写字母 O 将其括起来就可以表示复杂度了 — O(f(n))</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="与常系数无关"><a href="#与常系数无关" class="headerlink" title="与常系数无关"></a>与常系数无关</h4><blockquote><p>例如 O(n) + O(n) = O(2n), 其实 O(n)复杂度和 O(2n)复杂度是一样的，我们通常会忽略常系数对复杂度的影响</p></blockquote><h4 id="多项式级相加的复杂度，会取结果最大的那一个作为最后的结果"><a href="#多项式级相加的复杂度，会取结果最大的那一个作为最后的结果" class="headerlink" title="多项式级相加的复杂度，会取结果最大的那一个作为最后的结果"></a>多项式级相加的复杂度，会取结果最大的那一个作为最后的结果</h4><blockquote><p>O(n^2) + O(n)，明显 n^2 在输入量 n 逐渐变大的情况下，变化会更大，所以我们就说复杂度是 O(n^2)即可</p></blockquote><h4 id="O-1-是一个特殊的复杂度：输入量-n-与消耗的资源无关"><a href="#O-1-是一个特殊的复杂度：输入量-n-与消耗的资源无关" class="headerlink" title="O(1)是一个特殊的复杂度：输入量 n 与消耗的资源无关"></a>O(1)是一个特殊的复杂度：输入量 n 与消耗的资源无关</h4><blockquote><p>O（1）表示的是当前复杂度和输入 n 无关。例如你的代码处理 100 条数据是消耗 3 个时间单元和 1 个空间单元，处理 500 条数据依然还是消耗 3 个时间单元和 1 个空间单元，那么就是输入量与消耗资源无</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612220986085-7033d2c5-66bb-4608-8177-b3105aa878a9.png#align=left&display=inline&height=337&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1346&originWidth=1412&size=1576566&status=done&style=none&width=353" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612220986085-7033d2c5-66bb-4608-8177-b3105aa878a9.png#align=left&display=inline&height=337&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1346&originWidth=1412&size=1576566&status=done&style=none&width=353" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">num += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)<br>空间复杂度：O(1)</p><h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i++; i &lt; n) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><blockquote><p>单个变量所占的空间永远都是一个常量所以是 O(1)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i++; i &lt; n) &#123;</span><br><span class="line">  arr.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><blockquote><p>这段代码相当于我们给数组 arr 中添加了 n 个元素，所以占用了 n 个内存单元，因此空间复杂度为 O(n)</p></blockquote><h3 id="O-logn"><a href="#O-logn" class="headerlink" title="O(logn)"></a>O(logn)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">  i *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><blockquote><p>这段代码相当于是在计算 2&lt;=n，也就是 x 次之后循环结束那么 x=logn</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈 - 基础知识</title>
      <link href="2021/04/08/%E6%A0%88/"/>
      <url>2021/04/08/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612236925054-f7e99dfb-004a-4be1-aee6-aacfbdabd331.png#align=left&display=inline&height=314&margin=%5Bobject%20Object%5D&name=image.png&originHeight=314&originWidth=342&size=23754&status=done&style=none&width=342" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612236925054-f7e99dfb-004a-4be1-aee6-aacfbdabd331.png#align=left&display=inline&height=314&margin=%5Bobject%20Object%5D&name=image.png&originHeight=314&originWidth=342&size=23754&status=done&style=none&width=342" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一种<strong>后进先出</strong>的数据结构。 类似于一个麻袋，先装进去的就在袋子的最底部，所以只能先拿出来最上面的</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="push：-入栈"><a href="#push：-入栈" class="headerlink" title="push： 入栈"></a>push： 入栈</h3><h3 id="pop：-出栈"><a href="#pop：-出栈" class="headerlink" title="pop： 出栈"></a>pop： 出栈</h3><h3 id="top：栈顶"><a href="#top：栈顶" class="headerlink" title="top：栈顶"></a>top：栈顶</h3><h2 id="JavaScript-中的栈"><a href="#JavaScript-中的栈" class="headerlink" title="JavaScript 中的栈"></a>JavaScript 中的栈</h2><p>在 js 中是没用栈这种数据结构的，不过我们可以利用<strong>数组</strong>来模拟。<br>而且在 js 中也是有对应的 <code>push</code>  和 <code>pop</code>  方法的:</p><p>push: 向数组末尾添加一个元素，返回值是数组的长度<br>pop：移除数组的第一个元素，返回值是移除的元素</p><h2 id="什么场景下用栈？"><a href="#什么场景下用栈？" class="headerlink" title="什么场景下用栈？"></a>什么场景下用栈？</h2><blockquote><p>最直白的讲就是需要<strong>后进先出</strong>的场景</p></blockquote><h3 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612245130432-6b1613e8-13ae-4f96-a691-47f68394f3bb.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&name=image.png&originHeight=259&originWidth=379&size=80976&status=done&style=none&width=379" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612245130432-6b1613e8-13ae-4f96-a691-47f68394f3bb.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&name=image.png&originHeight=259&originWidth=379&size=80976&status=done&style=none&width=379" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>我们计算十进制转二进制时，就是不断除以 2，然后取余数<br>然后将最后一位的余数与第一位的余数拼成二进制</p><p>这样的后进先出的手法有没有想到栈！</p><h3 id="判断字符串的括号是否有效"><a href="#判断字符串的括号是否有效" class="headerlink" title="判断字符串的括号是否有效"></a>判断字符串的括号是否有效</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612245247309-b9ef1209-3935-4573-acd5-3b11b1e44384.png#align=left&display=inline&height=228&margin=%5Bobject%20Object%5D&name=image.png&originHeight=228&originWidth=275&size=30754&status=done&style=none&width=275" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612245247309-b9ef1209-3935-4573-acd5-3b11b1e44384.png#align=left&display=inline&height=228&margin=%5Bobject%20Object%5D&name=image.png&originHeight=228&originWidth=275&size=30754&status=done&style=none&width=275" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>我们验证括号是否有效其实就是在验证是不是能够凑齐一对完整的闭合括号。</p><p>而且我们可以发现一个规律，越靠左的左括号，它对应的右括号就越靠右。反之也就是最后面的左括号，对应的必定是出现的第一个右括号。</p><p>所以我们就可以在遇到左括号时就入栈，遇到右括号时就与栈顶的括号就行配对比较，若果符合配对规则则出栈，否则就不符合规则直接判定无效。匹配到最后结如果栈内是空就证明可以完整闭合</p><h3 id="函数调用栈等"><a href="#函数调用栈等" class="headerlink" title="函数调用栈等"></a>函数调用栈等</h3><p>这个可以看浏览器，js 的解释器就是通过调用栈的形式实现的<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612249568954-7f2f8a5c-6c50-4eb5-bb44-c98e9dd0490b.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=305&size=43181&status=done&style=none&width=305" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612249568954-7f2f8a5c-6c50-4eb5-bb44-c98e9dd0490b.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=305&size=43181&status=done&style=none&width=305" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612249579751-d03a29ca-0a7a-4a44-896b-2bb23a79b6ed.png#align=left&display=inline&height=130&margin=%5Bobject%20Object%5D&name=image.png&originHeight=182&originWidth=470&size=38332&status=done&style=none&width=335" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612249579751-d03a29ca-0a7a-4a44-896b-2bb23a79b6ed.png#align=left&display=inline&height=130&margin=%5Bobject%20Object%5D&name=image.png&originHeight=182&originWidth=470&size=38332&status=done&style=none&width=335" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><p>执行 fun1 时先将 fun1 入栈，然后调用 fun2，入栈；然后调用 fun3 入栈。</p><p>fun3 执行完毕出栈<br>fun2 执行完毕出栈<br>fun1 执行完毕出栈<br>程序执行完毕</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈 - 基础知识</title>
      <link href="2021/04/08/%E6%B5%8B%E8%AF%95/"/>
      <url>2021/04/08/%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>测试首页图片是否能正常显示以及文章描述</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、设计原则</title>
      <link href="2021/04/08/yuque/%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>2021/04/08/yuque/%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="何为设计？"><a href="#何为设计？" class="headerlink" title="何为设计？"></a>何为设计？</h2><ul><li>即按照哪一种思路或者标准来实现功能</li><li>功能相同，可以有不同的设计方案来实现</li><li>伴随着需求增加，设计的作用才能体现出来</li></ul><p><strong>《UNIX/LINUX 设计哲学》一书中提出了几个设计的准则：</strong></p><ol><li>准则 1： 小即是美</li><li>准则 2： 让每个程序只做好一件事</li><li>准则 3： 快速建立原型</li><li>准则 4： 舍弃高效率而取可移植性</li><li>准则 5： 采用纯文本来存储数据（可读性）</li><li>准则 6： 充分利用软件的杠杆效应（复用性）</li><li>准则 7： 使用 shell 脚本来提高杠杆效应和可移植性</li><li>准则 8： 避免强制性的用户界面</li><li>准则 9： 让每个程序都成为过滤器</li></ol><p>几个小准则：</p><ol><li>允许用户定制环境</li><li>尽量使操作系统内核小而轻量化</li><li>使用小写字母和简写</li><li>沉默是金</li><li>各部分之和大于整体</li><li>寻求 90%的解决方案（100 个人里只需要满足 90 个用户的需求 - 28 准则）</li></ol><h2 id="S-O-L-I-D-五大设计原则"><a href="#S-O-L-I-D-五大设计原则" class="headerlink" title="S O L I D 五大设计原则**"></a>S O L I D 五大设计原则**</h2><table><thead><tr><th>S</th><th>单一职责</th></tr></thead><tbody><tr><td>O</td><td>开放封闭（对扩展开放，对修改封闭）</td></tr><tr><td>L</td><td>李氏置换</td></tr><tr><td>I</td><td>接口独立</td></tr><tr><td>D</td><td>依赖导致</td></tr></tbody></table><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><ul><li>一个函数只负责一件事</li><li>专职专用</li></ul><h3 id="开放封闭"><a href="#开放封闭" class="headerlink" title="开放封闭"></a>开放封闭</h3><ul><li>对扩展开放，对修改封闭</li><li>增加需求时，应该是增加代码，而不是去修改已有的代码</li></ul><h3 id="李氏置换"><a href="#李氏置换" class="headerlink" title="李氏置换"></a>李氏置换</h3><ul><li>子类能覆盖父类</li><li>父类能出现的地方子类就能出现</li><li>JS 中使用较少（弱类型 &amp; 继承使用较少）</li></ul><h3 id="接口独立"><a href="#接口独立" class="headerlink" title="接口独立"></a>接口独立</h3><ul><li>保持接口的单一独立，避免出现“胖接口”</li><li>JS 中是没有接口接口的，使用较少</li><li>类似于单一职责，但是更关注接口</li></ul><h3 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h3><ul><li>面向接口编程，只关注接口而不关注具体类的实现</li><li>JS 中使用较少</li></ul><h2 id="23-种设计模式"><a href="#23-种设计模式" class="headerlink" title="23 种设计模式"></a>23 种设计模式</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/2705850/1617863510719-18264df3-e47b-425b-a5c5-e9b7a2f01697.jpeg" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/jpeg/2705850/1617863510719-18264df3-e47b-425b-a5c5-e9b7a2f01697.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一、面向对象</title>
      <link href="2021/04/08/yuque/%E4%B8%80%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>2021/04/08/yuque/%E4%B8%80%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h2><p>概念：</p><ol><li><strong>类：</strong> 抽象出来的一个具有一些通用特征的模板</li><li><strong>实例：</strong> 通过类构造出来的的具体对象</li></ol><p>三要素：</p><ol><li><strong>继承：</strong>子类继承父类</li><li><strong>封装：</strong>数据的权限和保密</li><li><strong>多态：</strong>统一接口的不同实现</li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类继承父类。</p><p>在 js 中实现继承的方式是通过原型链的方式实现的，大概有六种，详情可以看这里<a href="https://www.notion.so/callmew/JavaScript-c6f0e1fea7d845a298dbb8f773fd1d66">https://www.notion.so/callmew/JavaScript-c6f0e1fea7d845a298dbb8f773fd1d66</a></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li>public 完成开发</li><li>protected 对子类开放</li><li>private 对自己开放</li></ul><p><a href="https://www.typescriptlang.org/play?ssl=1&ssc=1&pln=30&pc=1#code/MYGwhgzhAEAKCmB7ADie0DeAoa0B2YAtvANw7RgDmp5yATogC7zDMAm0A7vAJaUAWjEtAD0I6ICvlQJ-agBW1A3j6AbRUAA+lnLBEeCIzoBXVojoAKAsQBcWujzyUANBWqm8OwgCN4dAJSZyuRvx4QAHQm6AC8+EQ0uL7+QVRh9lHRfgGB3HyC0OEAjABMAAxkuAC+WKVYoJAwAMqMOmzweIzQ8AAezHhsMAgoaN64Tq7uRdD0PABuYMzQlDx0IABilo1swmKSUoBXgYCPukqAfKZqGhZ6jAbGkebaVraJjs5udHaDD3dDnv3REDrI7ufEdvEPCMYqlnu4svh7sMfNAUkFZvMljwVhCAOQAGR4IAAnqiRuVcNRGAB1XgCRiGLzYaLQdSaRBoQIgRCUQxwtJkwRA8ilcp0rTQVo8MCIACy1wheHgnGgtXqjQpqMA8DqAWBVUXZsgAOOwFblCkXi6yBImkjIUvXCsXXY1zRbLTpkIA">TS Playground - An online editor for exploring TypeScript and JavaScript</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class People &#123;</span><br><span class="line">  name;</span><br><span class="line">  age;</span><br><span class="line">  protected weight; &#x2F;&#x2F; 只对子类公开</span><br><span class="line"></span><br><span class="line">  constructor(name: string, age: number) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.weight &#x3D; 120;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends People &#123;</span><br><span class="line">  number;</span><br><span class="line">  private girlFriend; &#x2F;&#x2F; 只对自己开放</span><br><span class="line">  constructor(name: string, age: number, number: number) &#123;</span><br><span class="line">    super(name, age);</span><br><span class="line">    this.number &#x3D; number;</span><br><span class="line">    this.girlFriend &#x3D; &quot;Lily&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getWeight() &#123;</span><br><span class="line">    console.log(this.weight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const xiaoMing &#x3D; new Student(&quot;小名&quot;, 18, 20);</span><br><span class="line">xiaoMing.getWeight();</span><br><span class="line">xiaoMing.girlFriend; &#x2F;&#x2F; 私有变量，只能在类内部访问，不能在实例中访问</span><br></pre></td></tr></table></figure><p>封装总结：</p><ul><li>减少耦合，不该外露的不外露</li><li>利于数据、接口的权限管理</li><li>ES6 目前不支持，一般认为_开头的属性是 private</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>同一个接口不同的表现</li><li>保持子类的开放性和灵活性</li><li>面向接口编程</li></ul><p>需要和重载进行区分：</p><p>重载：允许存在多个同名函数，然后通过不同的参数来进行调用对应的方法</p><p>多态：是对父类的方法进行重新定义，定义一个接口，然后在子类中完成不同的功能</p><h2 id="为什么要使用面向对象？"><a href="#为什么要使用面向对象？" class="headerlink" title="为什么要使用面向对象？"></a>为什么要使用面向对象？</h2><p>编程应该： 简单 &amp; 抽象</p><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1617851649253-5e061b43-074c-432f-aa75-57e35e8e2d51.png#align=left&display=inline&height=311&margin=%5Bobject%20Object%5D&name=image.png&originHeight=622&originWidth=1016&size=448909&status=done&style=none&width=508" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1617851649253-5e061b43-074c-432f-aa75-57e35e8e2d51.png#align=left&display=inline&height=311&margin=%5Bobject%20Object%5D&name=image.png&originHeight=622&originWidth=1016&size=448909&status=done&style=none&width=508" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="2021/02/06/yuque/%E9%98%9F%E5%88%97/"/>
      <url>2021/02/06/yuque/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>具体请移步<a href="https://github.com/liuqh0609/algorithm">git 仓库查看</a></p></blockquote><h2 id="【933】最近的请求次数"><a href="#【933】最近的请求次数" class="headerlink" title="【933】最近的请求次数"></a>【933】最近的请求次数</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><strong><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612593180074-e57677a0-d4dc-4064-8bcd-0b4e732e2194.png#align=left&display=inline&height=280&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1118&originWidth=1302&size=185312&status=done&style=none&width=326" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612593180074-e57677a0-d4dc-4064-8bcd-0b4e732e2194.png#align=left&display=inline&height=280&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1118&originWidth=1302&size=185312&status=done&style=none&width=326" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></strong><br><strong>这道题可能读起来有点难懂，我们这里先来梳理一下题意：</strong><br>我们配合示例来看，首先输入是两个数组</p><ol><li>第一个数组是字符串组成的，这个字符串其实对应的是方法的调用</li><li>第二个数组是由数字组成的，这个就是在调用的第一个数组时传入的参数</li><li>两个数组两两对应</li></ol><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RecentCounter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建缓存队列</span></span><br><span class="line">  <span class="built_in">this</span>.q = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">t</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RecentCounter.prototype.ping = <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将传入的每一个参数入队</span></span><br><span class="line">  <span class="built_in">this</span>.q.push(t);</span><br><span class="line">  <span class="comment">// 判断队列的首元素是否在当前参数的值到3000之间[t-3000,t]</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">this</span>.q[<span class="number">0</span>] &lt; t - <span class="number">3000</span>) &#123;</span><br><span class="line">    <span class="comment">// 不在就剔除队列中</span></span><br><span class="line">    <span class="built_in">this</span>.q.shift();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回队列的长度</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.q.length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new RecentCounter()</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.ping(t)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="2021/02/02/yuque/%E6%A0%88/"/>
      <url>2021/02/02/yuque/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>具体请移步<a href="https://github.com/liuqh0609/algorithm">git 仓库查看</a></p></blockquote><h2 id="【20】有效的括号"><a href="#【20】有效的括号" class="headerlink" title="【20】有效的括号"></a>【20】有效的括号</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’  的字符串 s ，判断字符串是否有效。</p></blockquote><blockquote><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul><p><strong>提示：</strong></p><ul><li>** ** 1 &lt;= s.length &lt;= 10</li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul></blockquote><blockquote><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">链接</a></p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ol><li>首先要明确一点，<strong>最后出现的左括号一定是匹配第一次出现的右括号</strong>（这就可以从栈的<strong>后进先出</strong>去匹配遇到右括号时是否能和栈顶的左括号相匹配）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果字符长度是奇数直接返回false</span></span><br><span class="line">  <span class="keyword">if</span> (s.length % <span class="number">2</span> === <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 构建map字典</span></span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&quot;)&quot;</span>, <span class="string">&quot;(&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;&#125;&quot;</span>, <span class="string">&quot;&#123;&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;]&quot;</span>, <span class="string">&quot;[&quot;</span>],</span><br><span class="line">  ]);</span><br><span class="line">  <span class="comment">// 创建缓存栈</span></span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="comment">// 循环字符串</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="comment">// 符合左括号规则入栈</span></span><br><span class="line">    <span class="keyword">if</span> (val === <span class="string">&quot;(&quot;</span> || val === <span class="string">&quot;[&quot;</span> || val === <span class="string">&quot;&#123;&quot;</span>) &#123;</span><br><span class="line">      stack.push(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 判断右括号是否和栈顶的左括号匹配</span></span><br><span class="line">      <span class="keyword">const</span> top = stack.pop();</span><br><span class="line">      <span class="comment">// 不匹配直接返回false，匹配循环继续</span></span><br><span class="line">      <span class="keyword">if</span> (map.get(val) !== top) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 字符匹配完毕，判断栈内是否清空</span></span><br><span class="line">  <span class="keyword">return</span> stack.length === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度： O(n） ：一个循环解决的</li><li>空间复杂度：O(n) ：stack 最大可能就是将 s 字符串的所有字符压入，所以为 O(n)</li></ul><h2 id="【144】二叉树的前序遍历-迭代"><a href="#【144】二叉树的前序遍历-迭代" class="headerlink" title="【144】二叉树的前序遍历 - 迭代"></a>【144】二叉树的前序遍历 - 迭代</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><blockquote><p>给你二叉树的根节点  <code>root</code> ，返回它节点值的  <strong>前序</strong>_ _遍历。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612251623472-983623d0-dd7e-44be-b6a6-3532f6f145c2.png#align=left&display=inline&height=427&margin=%5Bobject%20Object%5D&name=image.png&originHeight=427&originWidth=920&size=30145&status=done&style=none&width=920" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612251623472-983623d0-dd7e-44be-b6a6-3532f6f145c2.png#align=left&display=inline&height=427&margin=%5Bobject%20Object%5D&name=image.png&originHeight=427&originWidth=920&size=30145&status=done&style=none&width=920" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"> &gt; <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">链接</a></p></blockquote><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><ol><li><p>首先明确前序遍历的规则：DLR ，即先找自身（D）节点，然后找左（L）节点，最后找右（R）节点</p><blockquote><p>延伸：<br>中序遍历： LDR<br>后续遍历： LRD</p></blockquote></li></ol><p>2.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="comment">// 将根节点首先压入栈中</span></span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="comment">// 取出栈顶元素进行遍历操作,栈顶元素就是根元素即D</span></span><br><span class="line">    <span class="keyword">const</span> d = stack.pop();</span><br><span class="line">    res.push(d.val);</span><br><span class="line">    <span class="comment">//  分别取出左右节点,分别压入栈中</span></span><br><span class="line">    <span class="comment">//  这里需要注意因为栈的特性是后进先出，所以我们前序遍历要先取出左节点，因为这里左节点要最后入栈</span></span><br><span class="line">    <span class="keyword">if</span> (d.right) stack.push(d.right);</span><br><span class="line">    <span class="keyword">if</span> (d.left) stack.push(d.left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="2021/02/02/yuque/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2021/02/02/yuque/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612236925054-f7e99dfb-004a-4be1-aee6-aacfbdabd331.png#align=left&display=inline&height=314&margin=%5Bobject%20Object%5D&name=image.png&originHeight=314&originWidth=342&size=23754&status=done&style=none&width=342" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612236925054-f7e99dfb-004a-4be1-aee6-aacfbdabd331.png#align=left&display=inline&height=314&margin=%5Bobject%20Object%5D&name=image.png&originHeight=314&originWidth=342&size=23754&status=done&style=none&width=342" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一种<strong>后进先出</strong>的数据结构。 类似于一个麻袋，先装进去的就在袋子的最底部，所以只能先拿出来最上面的</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><h4 id="push：-入栈"><a href="#push：-入栈" class="headerlink" title="push： 入栈"></a>push： 入栈</h4><h4 id="pop：-出栈"><a href="#pop：-出栈" class="headerlink" title="pop： 出栈"></a>pop： 出栈</h4><h4 id="top：栈顶"><a href="#top：栈顶" class="headerlink" title="top：栈顶"></a>top：栈顶</h4><h3 id="JavaScript-中的栈"><a href="#JavaScript-中的栈" class="headerlink" title="JavaScript 中的栈"></a>JavaScript 中的栈</h3><p>在 js 中是没用栈这种数据结构的，不过我们可以利用<strong>数组</strong>来模拟。<br>而且在 js 中也是有对应的 <code>push</code>  和 <code>pop</code>  方法的:</p><p>push: 向数组末尾添加一个元素，返回值是数组的长度<br>pop：移除数组的第一个元素，返回值是移除的元素</p><h3 id="什么场景下用栈？"><a href="#什么场景下用栈？" class="headerlink" title="什么场景下用栈？"></a>什么场景下用栈？</h3><blockquote><p>最直白的讲就是需要<strong>后进先出</strong>的场景</p></blockquote><h4 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612245130432-6b1613e8-13ae-4f96-a691-47f68394f3bb.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&name=image.png&originHeight=259&originWidth=379&size=80976&status=done&style=none&width=379" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612245130432-6b1613e8-13ae-4f96-a691-47f68394f3bb.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&name=image.png&originHeight=259&originWidth=379&size=80976&status=done&style=none&width=379" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>我们计算十进制转二进制时，就是不断除以 2，然后取余数<br>然后将最后一位的余数与第一位的余数拼成二进制</p><p>这样的后进先出的手法有没有想到栈！</p><h4 id="判断字符串的括号是否有效"><a href="#判断字符串的括号是否有效" class="headerlink" title="判断字符串的括号是否有效"></a>判断字符串的括号是否有效</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612245247309-b9ef1209-3935-4573-acd5-3b11b1e44384.png#align=left&display=inline&height=228&margin=%5Bobject%20Object%5D&name=image.png&originHeight=228&originWidth=275&size=30754&status=done&style=none&width=275" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612245247309-b9ef1209-3935-4573-acd5-3b11b1e44384.png#align=left&display=inline&height=228&margin=%5Bobject%20Object%5D&name=image.png&originHeight=228&originWidth=275&size=30754&status=done&style=none&width=275" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>我们验证括号是否有效其实就是在验证是不是能够凑齐一对完整的闭合括号。</p><p>而且我们可以发现一个规律，越靠左的左括号，它对应的右括号就越靠右。反之也就是最后面的左括号，对应的必定是出现的第一个右括号。</p><p>所以我们就可以在遇到左括号时就入栈，遇到右括号时就与栈顶的括号就行配对比较，若果符合配对规则则出栈，否则就不符合规则直接判定无效。匹配到最后结如果栈内是空就证明可以完整闭合</p><h4 id="函数调用栈等"><a href="#函数调用栈等" class="headerlink" title="函数调用栈等"></a>函数调用栈等</h4><p>这个可以看浏览器，js 的解释器就是通过调用栈的形式实现的<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612249568954-7f2f8a5c-6c50-4eb5-bb44-c98e9dd0490b.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=305&size=43181&status=done&style=none&width=305" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612249568954-7f2f8a5c-6c50-4eb5-bb44-c98e9dd0490b.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=305&size=43181&status=done&style=none&width=305" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612249579751-d03a29ca-0a7a-4a44-896b-2bb23a79b6ed.png#align=left&display=inline&height=130&margin=%5Bobject%20Object%5D&name=image.png&originHeight=182&originWidth=470&size=38332&status=done&style=none&width=335" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612249579751-d03a29ca-0a7a-4a44-896b-2bb23a79b6ed.png#align=left&display=inline&height=130&margin=%5Bobject%20Object%5D&name=image.png&originHeight=182&originWidth=470&size=38332&status=done&style=none&width=335" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><p>执行 fun1 时先将 fun1 入栈，然后调用 fun2，入栈；然后调用 fun3 入栈。</p><p>fun3 执行完毕出栈<br>fun2 执行完毕出栈<br>fun1 执行完毕出栈<br>程序执行完毕</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612424034523-1b6c1820-6e7c-4fcd-b7f3-a089c8ee61e9.png#align=left&display=inline&height=265&margin=%5Bobject%20Object%5D&name=image.png&originHeight=530&originWidth=868&size=105840&status=done&style=none&width=434" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612424034523-1b6c1820-6e7c-4fcd-b7f3-a089c8ee61e9.png#align=left&display=inline&height=265&margin=%5Bobject%20Object%5D&name=image.png&originHeight=530&originWidth=868&size=105840&status=done&style=none&width=434" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>一种<strong>先进先出</strong>的数据结构，类似一个管道，这边进那边出</p><h3 id="名词解释-1"><a href="#名词解释-1" class="headerlink" title="名词解释"></a>名词解释</h3><h4 id="enqueue-入队"><a href="#enqueue-入队" class="headerlink" title="enqueue: 入队"></a>enqueue: 入队</h4><h4 id="dequeue：出队"><a href="#dequeue：出队" class="headerlink" title="dequeue：出队"></a>dequeue：出队</h4><h3 id="JavaScript-中模拟队列"><a href="#JavaScript-中模拟队列" class="headerlink" title="JavaScript 中模拟队列"></a>JavaScript 中模拟队列</h3><p>JavaScript 中没有队列，但是可以使用数组来模拟</p><ul><li>push</li><li>shift: 移除数组中最后一个个元素，返回值是被移除的元素</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="js-中的异步任务队列"><a href="#js-中的异步任务队列" class="headerlink" title="js 中的异步任务队列"></a>js 中的异步任务队列</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612424912370-54271c5c-8250-4f97-a7d6-daa0d11ec653.png#align=left&display=inline&height=550&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1100&originWidth=1584&size=547418&status=done&style=none&width=792" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612424912370-54271c5c-8250-4f97-a7d6-daa0d11ec653.png#align=left&display=inline&height=550&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1100&originWidth=1584&size=547418&status=done&style=none&width=792" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h4 id="计算最近请求次数"><a href="#计算最近请求次数" class="headerlink" title="计算最近请求次数"></a>计算最近请求次数</h4><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>线性表是 n 个元素的<strong>有限</strong>序列，最常用的是<strong>链式表达式，</strong>通常也叫作<strong>线性链表</strong>或者<strong>链表。</strong><br>**<br>在链表中存储的数据元素也叫作*<em>节点，\</em>*一个节点存储的就是一条数据记录。<br>每个节点的结构包括两个部分：</p><ol><li>具体的数据值</li><li>指向下一个节点的指针</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607567010381-356ba543-6cba-4ef6-91ab-f86c874b14e8.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=159&size=910&status=done&style=none&width=159" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607567010381-356ba543-6cba-4ef6-91ab-f86c874b14e8.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=159&size=910&status=done&style=none&width=159" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>在链表的最前面通常有一个<strong>头指针</strong>用来指向第一个节点。<br>对于链表的最后一个节点，由于在他之后没有下一个节点，因此它的指针是一个<strong>空指针。</strong><br>**</p><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607566998007-7eb2e286-606b-4997-aed6-2e7934b20015.png#align=left&display=inline&height=106&margin=%5Bobject%20Object%5D&name=image.png&originHeight=131&originWidth=721&size=5098&status=done&style=none&width=584" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607566998007-7eb2e286-606b-4997-aed6-2e7934b20015.png#align=left&display=inline&height=106&margin=%5Bobject%20Object%5D&name=image.png&originHeight=131&originWidth=721&size=5098&status=done&style=none&width=584" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><blockquote><p>如上图所示：只能通过上一个节点的指针找到下一个节点，而不能通过下一个节点去找到上一个节点</p></blockquote><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607568508498-ae10d7f7-ae94-4fca-94c4-0e91af21feeb.png#align=left&display=inline&height=107&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=666&size=5026&status=done&style=none&width=573" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607568508498-ae10d7f7-ae94-4fca-94c4-0e91af21feeb.png#align=left&display=inline&height=107&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=666&size=5026&status=done&style=none&width=573" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><blockquote><p>让最后一个元素的指针指向第一个元素，就形成了循环链表</p></blockquote><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607568635088-458b72fc-2265-4c16-ac27-766a45c35168.png#align=left&display=inline&height=94&margin=%5Bobject%20Object%5D&name=image.png&originHeight=111&originWidth=691&size=4776&status=done&style=none&width=584" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607568635088-458b72fc-2265-4c16-ac27-766a45c35168.png#align=left&display=inline&height=94&margin=%5Bobject%20Object%5D&name=image.png&originHeight=111&originWidth=691&size=4776&status=done&style=none&width=584" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><blockquote><p>给每个元素增加一个指向上一个元素的指针就形成了双向链表<br>双向链表可以通过自身查找到上一个元素，也可以查找到下一个元素</p></blockquote><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><blockquote><p>同样的还可以将双向链表和循环链表相结合，形成双向循环链表</p></blockquote><h3 id="单向链表的增删查"><a href="#单向链表的增删查" class="headerlink" title="单向链表的增删查"></a>单向链表的增删查</h3><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>当我们想要在一个链表<strong>A</strong>节点和<strong>B</strong>节点的中间增加节点<strong>C</strong>时，需要进行以下两步：</p><ol><li>使 C 节点的 net 等于 A 节点的 next</li><li>改变 A 节点的 next 等于 C 节点<blockquote><p>第一步和第二步的顺序不能调换，如果先执行第一步的话，那么就没办法获取到指向 B 节点的指针了，除非是新建一个变量提前缓存该指针</p></blockquote></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607571219091-ccbdcb0d-d048-463b-8b86-9aca0faad5ac.png#align=left&display=inline&height=175&margin=%5Bobject%20Object%5D&name=image.png&originHeight=202&originWidth=692&size=7827&status=done&style=none&width=601" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607571219091-ccbdcb0d-d048-463b-8b86-9aca0faad5ac.png#align=left&display=inline&height=175&margin=%5Bobject%20Object%5D&name=image.png&originHeight=202&originWidth=692&size=7827&status=done&style=none&width=601" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C.next = A.next;</span><br><span class="line">A.next = C;</span><br></pre></td></tr></table></figure><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p>当我们想要在一个链表中删除<strong>B</strong>节点时，需要进行以下一步：</p><ol><li>使 A 的 next 等于 B 的 next<blockquote><p>这里需要注意，A.next = B， 所以我们在处理这一步的时候，完全可以写成 <code>A.next = A.next.next</code> ;</p></blockquote></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.next = A.next.next;</span><br></pre></td></tr></table></figure><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>链表这种数据结构对于查找操作来说是<strong>弱项。</strong><br>因为链表的查找只能从第一个节点开始，逐个查找。</p><p>通过上面的增删查操作我们可以明显感知到，链表这种数据结构在<strong>增、删</strong>的操作上是比较方便的，可以在<strong>O(1)的时间复杂度</strong>内完成，但是<strong>查</strong>的话就是<strong>O(n)的时间复杂度</strong>了。<br>但是链表在增删上的优势并不明显，因为我们在增删的时候往往会伴随着查找的动作，比如我们在第五个节点后面添加一个新的节点，就会有这样的过程：</p><ol><li>查找到链表中的第 5 个节点</li><li>在他后面新增节点</li></ol><p>那这么说链表就没什么用了吗？</p><p>当然不是，链表的真正价值在于它存储的数据方式是按照顺序进行关联存储的，如果对于元素个数不确定，并且经常进行增删的数据来说，链表是比较合适的</p><blockquote><p>链表在内存中可以存储在<strong>不连续</strong>的内存空间内<br>因为链表的顺序关联是通过指针进行关联的<br>所以对于不确定元素个数的数据来说，存储在内存空间中的各个位置，然后通过 next 指针关联是较好的</p></blockquote><p>对于元素个数确定的数据，那么数组就是比较好的选择了</p><blockquote><p>数组在内存中开辟的是一块固定的连续内存空间</p></blockquote><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>一种<strong>无序且唯一</strong>的数据结构。</p><h3 id="JavaScript-中的集合"><a href="#JavaScript-中的集合" class="headerlink" title="JavaScript 中的集合"></a>JavaScript 中的集合</h3><ul><li>set</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line"><span class="comment">// 去重</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="comment">// 判断集合中是否有某元素</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set.has(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>去重</li><li>求交集</li><li>判断某元素是否在集合中</li></ol><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>与集合类似，字典也是一种存储唯一值的数据结构，但它是以<strong>键值对</strong>的形式来存储的.</p><h3 id="JavaScript-中的字典"><a href="#JavaScript-中的字典" class="headerlink" title="JavaScript 中的字典"></a>JavaScript 中的字典</h3><ul><li>ES6 中的字典，名为 Map</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增</span></span><br><span class="line">map.set(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">map.set(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;456&quot;</span>);</span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line">map.delete(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">map.clear(); <span class="comment">// 清空字典</span></span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line">map.set(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;233&quot;</span>);</span><br><span class="line"><span class="comment">// 查</span></span><br><span class="line">map.get(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些操作的时间复杂度都为O(1)</span></span><br></pre></td></tr></table></figure><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><ul><li>图是网络结构的抽象模型，是一组由边连接的节点</li><li>图可以表示任何二元关系，比如道路、航班<ul><li>二元关系： 一条边只能连接两个节点</li></ul></li></ul><h3 id="JavaScript-中的图"><a href="#JavaScript-中的图" class="headerlink" title="JavaScript 中的图"></a>JavaScript 中的图</h3><ul><li>js 中没有图，但是可以用 Object 和 Array 构建图</li><li>图的表示法： 邻接矩阵、邻接表、关联矩阵</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1614497230491-ddf68bb5-0e72-49f3-9ba7-f5d1606763c0.png#align=left&display=inline&height=235&margin=%5Bobject%20Object%5D&name=image.png&originHeight=469&originWidth=968&size=109729&status=done&style=none&width=484" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1614497230491-ddf68bb5-0e72-49f3-9ba7-f5d1606763c0.png#align=left&display=inline&height=235&margin=%5Bobject%20Object%5D&name=image.png&originHeight=469&originWidth=968&size=109729&status=done&style=none&width=484" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1614497256424-6dc249db-04d2-4683-b3e4-e7ebbfcddd1e.png#align=left&display=inline&height=232&margin=%5Bobject%20Object%5D&name=image.png&originHeight=464&originWidth=918&size=108810&status=done&style=none&width=459" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1614497256424-6dc249db-04d2-4683-b3e4-e7ebbfcddd1e.png#align=left&display=inline&height=232&margin=%5Bobject%20Object%5D&name=image.png&originHeight=464&originWidth=918&size=108810&status=done&style=none&width=459" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol><li>深度优先遍历<ol><li>访问根节点</li><li>对根节点的<strong>没访问过的相邻节点</strong>挨个进行深度优先遍历</li></ol></li><li>广度优先遍历<ol><li>新建一个队列，将根节点入队</li><li>将队头取出并访问</li><li>把队头的没访问过的相邻节点入队</li><li>重复 2、3、4 步，直到队列为空</li></ol></li></ol><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li>堆是一种特殊的<strong>完全二叉树</strong></li><li>所有的节点都大于等于（最大堆）或者小于等于（最小堆）他的子节点</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1614825697653-6b98a800-54b4-49e2-ad62-c5dfaa200963.png#align=left&display=inline&height=192&margin=%5Bobject%20Object%5D&name=image.png&originHeight=192&originWidth=265&size=26834&status=done&style=none&width=265" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1614825697653-6b98a800-54b4-49e2-ad62-c5dfaa200963.png#align=left&display=inline&height=192&margin=%5Bobject%20Object%5D&name=image.png&originHeight=192&originWidth=265&size=26834&status=done&style=none&width=265" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1614825707257-07017976-2c14-4d75-bf17-05a7131ca873.png#align=left&display=inline&height=192&margin=%5Bobject%20Object%5D&name=image.png&originHeight=192&originWidth=287&size=27057&status=done&style=none&width=287" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1614825707257-07017976-2c14-4d75-bf17-05a7131ca873.png#align=left&display=inline&height=192&margin=%5Bobject%20Object%5D&name=image.png&originHeight=192&originWidth=287&size=27057&status=done&style=none&width=287" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="Javascript-中的堆"><a href="#Javascript-中的堆" class="headerlink" title="Javascript 中的堆"></a>Javascript 中的堆</h3><ul><li>js 中通常用数组表示堆</li><li>左侧子节点的位置是： 2*index+1</li><li>右侧子节点的位置是： 2*index+2</li><li>父节点的位置是： （index-1）/ 2 向下取整</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1614825783062-f3a58038-79c9-4d9a-a6d3-dc143d022502.png#align=left&display=inline&height=350&margin=%5Bobject%20Object%5D&name=image.png&originHeight=350&originWidth=305&size=46867&status=done&style=none&width=305" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1614825783062-f3a58038-79c9-4d9a-a6d3-dc143d022502.png#align=left&display=inline&height=350&margin=%5Bobject%20Object%5D&name=image.png&originHeight=350&originWidth=305&size=46867&status=done&style=none&width=305" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h3><ul><li>高效快速的找到最大或者最小的元素<ul><li>因为堆是有顺序的，不是最大堆就是最小堆</li></ul></li><li>找到最大或者最小的第 K 个元素</li></ul><h3 id="JavaScript-实现最小的堆类"><a href="#JavaScript-实现最小的堆类" class="headerlink" title="JavaScript 实现最小的堆类"></a>JavaScript 实现最小的堆类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.heap = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 交换元素</span></span><br><span class="line">  <span class="function"><span class="title">swap</span>(<span class="params">i1, i2</span>)</span> &#123;</span><br><span class="line">    [<span class="built_in">this</span>.heap[i2], <span class="built_in">this</span>.heap[i1]] = [<span class="built_in">this</span>.heap[i1], <span class="built_in">this</span>.heap[i2]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 元素上移</span></span><br><span class="line">  <span class="function"><span class="title">shiftUp</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 比较到堆顶元素直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> parentIndex = <span class="built_in">this</span>.parentIndex(index);</span><br><span class="line">    <span class="comment">// 比较当前节点与父节点的大小</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.heap[index] &lt; <span class="built_in">this</span>.heap[parentIndex]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.swap(index, parentIndex);</span><br><span class="line">      <span class="comment">// 递归比较下一个节点与父节点</span></span><br><span class="line">      <span class="built_in">this</span>.shiftUp(parentIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 元素下移</span></span><br><span class="line">  <span class="function"><span class="title">shiftDown</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> left = <span class="built_in">this</span>.leftIndex(index);</span><br><span class="line">    <span class="keyword">const</span> right = <span class="built_in">this</span>.rightIndex(index);</span><br><span class="line">    <span class="comment">// 判断左子节点是否比自己小</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.heap[left] &lt; <span class="built_in">this</span>.heap[index]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.swap(left, index);</span><br><span class="line">      <span class="built_in">this</span>.shiftDown(left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断右子节点是否比自己小</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.heap[right] &lt; <span class="built_in">this</span>.heap[index]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.swap(right, index);</span><br><span class="line">      <span class="built_in">this</span>.shiftDown(right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">n</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.heap.push(n);</span><br><span class="line">    <span class="comment">// 插入之后需要考虑将该元素上移</span></span><br><span class="line">    <span class="built_in">this</span>.shiftUp(<span class="built_in">this</span>.heap.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除堆顶</span></span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 用堆底元素替换堆顶元素</span></span><br><span class="line">    <span class="built_in">this</span>.heap[<span class="number">0</span>] = <span class="built_in">this</span>.heap.pop();</span><br><span class="line">    <span class="comment">// 将更新后的堆顶元素向下移动</span></span><br><span class="line">    <span class="built_in">this</span>.shiftDown(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取堆顶元素</span></span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.heap[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取堆的大小</span></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.heap.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取父节点的下标</span></span><br><span class="line">  <span class="function"><span class="title">parentIndex</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor((index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取左侧子节点下标</span></span><br><span class="line">  <span class="function"><span class="title">leftIndex</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取右侧子节点下标</span></span><br><span class="line">  <span class="function"><span class="title">rightIndex</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试是否可以正常运行</span></span><br><span class="line"><span class="keyword">const</span> h = <span class="keyword">new</span> MinHeap();</span><br><span class="line">h.insert(<span class="number">3</span>);</span><br><span class="line">h.insert(<span class="number">2</span>);</span><br><span class="line">h.insert(<span class="number">1</span>);</span><br><span class="line">h.insert(<span class="number">0</span>);</span><br><span class="line">h.pop();</span><br><span class="line"><span class="built_in">console</span>.log(h.heap);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度&amp;空间复杂度</title>
      <link href="2021/02/02/yuque/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>2021/02/02/yuque/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="复杂度的作用"><a href="#复杂度的作用" class="headerlink" title="复杂度的作用"></a>复杂度的作用</h2><p>一般我们会从两个维度去考虑一段代码的质量：</p><ol><li>时间复杂度</li><li>空间复杂度</li></ol><p>顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。</p><p>所以时间复杂度和空间复杂度一般是用来衡量一段代码的优劣的。</p><p>那么我们应该怎么来定义复杂度呢？<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1606953725697-beedfd24-126b-4e4f-97cc-28d93d2321e1.png#align=left&display=inline&height=78&margin=%5Bobject%20Object%5D&name=image.png&originHeight=155&originWidth=198&size=27501&status=done&style=none&width=99" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1606953725697-beedfd24-126b-4e4f-97cc-28d93d2321e1.png#align=left&display=inline&height=78&margin=%5Bobject%20Object%5D&name=image.png&originHeight=155&originWidth=198&size=27501&status=done&style=none&width=99" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="复杂度的定义与特点"><a href="#复杂度的定义与特点" class="headerlink" title="复杂度的定义与特点"></a>复杂度的定义与特点</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>复杂度是一个关于输入量 n 的函数。<br>eg：假设你的代码复杂度是 f(n),那么用大写字母 O 将其括起来就可以表示复杂度了 — O(f(n))</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="与常系数无关"><a href="#与常系数无关" class="headerlink" title="与常系数无关"></a>与常系数无关</h4><blockquote><p>例如 O(n) + O(n) = O(2n), 其实 O(n)复杂度和 O(2n)复杂度是一样的，我们通常会忽略常系数对复杂度的影响</p></blockquote><h4 id="多项式级相加的复杂度，会取结果最大的那一个作为最后的结果"><a href="#多项式级相加的复杂度，会取结果最大的那一个作为最后的结果" class="headerlink" title="多项式级相加的复杂度，会取结果最大的那一个作为最后的结果"></a>多项式级相加的复杂度，会取结果最大的那一个作为最后的结果</h4><blockquote><p>O(n^2) + O(n)，明显 n^2 在输入量 n 逐渐变大的情况下，变化会更大，所以我们就说复杂度是 O(n^2)即可</p></blockquote><h4 id="O-1-是一个特殊的复杂度：输入量-n-与消耗的资源无关"><a href="#O-1-是一个特殊的复杂度：输入量-n-与消耗的资源无关" class="headerlink" title="O(1)是一个特殊的复杂度：输入量 n 与消耗的资源无关"></a>O(1)是一个特殊的复杂度：输入量 n 与消耗的资源无关</h4><blockquote><p>O（1）表示的是当前复杂度和输入 n 无关。例如你的代码处理 100 条数据是消耗 3 个时间单元和 1 个空间单元，处理 500 条数据依然还是消耗 3 个时间单元和 1 个空间单元，那么就是输入量与消耗资源无</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612220986085-7033d2c5-66bb-4608-8177-b3105aa878a9.png#align=left&display=inline&height=337&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1346&originWidth=1412&size=1576566&status=done&style=none&width=353" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612220986085-7033d2c5-66bb-4608-8177-b3105aa878a9.png#align=left&display=inline&height=337&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1346&originWidth=1412&size=1576566&status=done&style=none&width=353" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">num += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)<br>空间复杂度：O(1)</p><h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i++; i &lt; n) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><blockquote><p>单个变量所占的空间永远都是一个常量所以是 O(1)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i++; i &lt; n) &#123;</span><br><span class="line">  arr.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><blockquote><p>这段代码相当于我们给数组 arr 中添加了 n 个元素，所以占用了 n 个内存单元，因此空间复杂度为 O(n)</p></blockquote><h3 id="O-logn"><a href="#O-logn" class="headerlink" title="O(logn)"></a>O(logn)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">  i *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><blockquote><p>这段代码相当于是在计算 2&lt;=n，也就是 x 次之后循环结束那么 x=logn</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[红宝书质检厂]看看读完红宝书的你，到底学废了吗？</title>
      <link href="2021/01/26/yuque/%5B%E7%BA%A2%E5%AE%9D%E4%B9%A6%E8%B4%A8%E6%A3%80%E5%8E%82%5D%E7%9C%8B%E7%9C%8B%E8%AF%BB%E5%AE%8C%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%9A%84%E4%BD%A0%EF%BC%8C%E5%88%B0%E5%BA%95%E5%AD%A6%E5%BA%9F%E4%BA%86%E5%90%97%EF%BC%9F/"/>
      <url>2021/01/26/yuque/%5B%E7%BA%A2%E5%AE%9D%E4%B9%A6%E8%B4%A8%E6%A3%80%E5%8E%82%5D%E7%9C%8B%E7%9C%8B%E8%AF%BB%E5%AE%8C%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%9A%84%E4%BD%A0%EF%BC%8C%E5%88%B0%E5%BA%95%E5%AD%A6%E5%BA%9F%E4%BA%86%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>对于技术类的书籍，我认为我们在阅读的时候应该是带着问题又目的性的阅读，当我们读完一个章节或者一部分之后就回头问问自己是否了解或者掌握了这其中的知识点，以问题的形式来回顾和检查自己的理解程度。</p><p>本篇文章我就以这种角度来带大家检查一下自己阅读红宝书的质量到底如何</p><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="你眼里的-JavaScript-是什么？"><a href="#你眼里的-JavaScript-是什么？" class="headerlink" title="你眼里的 JavaScript 是什么？"></a>你眼里的 JavaScript 是什么？</h3><p>在前端的远古时代（95 年之前）为了验证一个输入字段是否有效，就需要与服务器进行一次往返的通信，极其浪费时间。而 JavaScript 当时的出现就是为了解决这种前端的数据验证问题，但是随着自身的发展，现在 Js 能做的事情已经越来越多了，也就成为了现在我们所认识的主流编程语言。<br>完整的 JavaScript 由 3 部分组成：</p><ol><li>ECMAScript</li><li>DOM</li><li>BOM</li></ol><h3 id="那你能分别介绍一下这三部分吗？"><a href="#那你能分别介绍一下这三部分吗？" class="headerlink" title="那你能分别介绍一下这三部分吗？"></a>那你能分别介绍一下这三部分吗？</h3><p>ECMAScript：由国际标准化组织制定的一种标准，定义了这门语言的一些词法、语法和类型等一系列的标准<br>DOM：全称是 Document Object Model，也就是文档对象模型，是用来让我们对 HTML 文档中的元素结构进行增删改查的<br>BOM：Brower Object Model，浏览器对象模型，实现了一系列的浏览器 API，以方便我们去操作浏览器相关的操作，常用的有 window 对象，navigator 对象，XMLRequest，操作 Cookie 的等等</p><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1611704341145-747ae015-7564-441d-bef2-7f8cb22d0b1c.png#align=left&display=inline&height=425&margin=%5Bobject%20Object%5D&name=image.png&originHeight=850&originWidth=2438&size=361309&status=done&style=none&width=1219" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1611704341145-747ae015-7564-441d-bef2-7f8cb22d0b1c.png#align=left&display=inline&height=425&margin=%5Bobject%20Object%5D&name=image.png&originHeight=850&originWidth=2438&size=361309&status=done&style=none&width=1219" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="能说一下-script-标签的-defer-和-async-属性吗？"><a href="#能说一下-script-标签的-defer-和-async-属性吗？" class="headerlink" title="能说一下 script 标签的 defer 和 async 属性吗？"></a>能说一下 script 标签的 defer 和 async 属性吗？</h3><h3 id="上面你提到的-load-和-DOMContentLoad-事件能解释一下吗？"><a href="#上面你提到的-load-和-DOMContentLoad-事件能解释一下吗？" class="headerlink" title="上面你提到的 load 和 DOMContentLoad 事件能解释一下吗？"></a>上面你提到的 load 和 DOMContentLoad 事件能解释一下吗？</h3><h3 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>标签语义化</title>
      <link href="2020/12/30/yuque/%E6%A0%87%E7%AD%BE%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
      <url>2020/12/30/yuque/%E6%A0%87%E7%AD%BE%E8%AF%AD%E4%B9%89%E5%8C%96/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动画与绘制</title>
      <link href="2020/12/27/yuque/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%88%B6/"/>
      <url>2020/12/27/yuque/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><ul><li>@keyframes 定义<ul><li>可以使用百分比表示进度</li><li>也可以使用 from、to</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> mykf&#123;</span><br><span class="line"><span class="selector-tag">form</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: red</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: blue</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>animation：使用</p><ul><li>animation-name     动画名称</li><li>animation-duration     动画的时长</li><li>animation-timing-function     动画的时间曲线<ul><li>贝塞尔曲线：<a href="https://cubic-bezier.com/#.17,.67,.83,.67">https://cubic-bezier.com/#.17,.67,.83,.67</a></li><li>一次贝塞尔曲线（直线）</li><li>二次贝塞尔曲线</li><li>三次贝塞尔曲线（常用）</li></ul></li><li>animation-delay     动画开始前的延迟</li><li>animation-iteration-count     动画的播放次数</li><li>animation-rirection     动画的方向</li></ul></li><li><p>transition</p><ul><li>transition-property 需要变换的属性</li><li>transition-duration 变换的时长</li><li>transition-timing-function 时间曲线</li><li>transition-delay 延迟</li></ul></li></ul><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1609074986965-f439f290-534a-4e1c-ab66-5c49265301b7.png#align=left&display=inline&height=298&margin=%5Bobject%20Object%5D&name=image.png&originHeight=596&originWidth=742&size=98359&status=done&style=none&width=371" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1609074986965-f439f290-534a-4e1c-ab66-5c49265301b7.png#align=left&display=inline&height=298&margin=%5Bobject%20Object%5D&name=image.png&originHeight=596&originWidth=742&size=98359&status=done&style=none&width=371" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>在自然界中我们看到的光都是混色光，极少有纯色光（激光笔可以达到纯色光）<br>正常人类看到的光的波长在 400~760nm。</p><p>人眼内有三种视锥细胞，这三种细胞分别用来识别三种颜色：红绿蓝（RGB）</p><h3 id="HSL-和-HSV"><a href="#HSL-和-HSV" class="headerlink" title="HSL 和 HSV"></a>HSL 和 HSV</h3><ul><li>Hue： 色相（将颜色分成一个色盘，然后我们通过制定一个色盘中的角度，来决定他的颜色）</li><li>Ssturation：纯度</li><li>Lightness： 亮度（到达 100 是白色，到达 0 是黑色，中间的才是纯色）</li><li>Value：明度 （value 到达 100%时，就相当于是一个纯色）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1609075457053-ef9ba5ca-8060-40bf-a17b-f4a2c5f4f7ce.png#align=left&display=inline&height=237&margin=%5Bobject%20Object%5D&name=image.png&originHeight=250&originWidth=640&size=189658&status=done&style=none&width=607" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1609075457053-ef9ba5ca-8060-40bf-a17b-f4a2c5f4f7ce.png#align=left&display=inline&height=237&margin=%5Bobject%20Object%5D&name=image.png&originHeight=250&originWidth=640&size=189658&status=done&style=none&width=607" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>（HSL： W3C 采用的标准）</p><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><h3 id="几何图形"><a href="#几何图形" class="headerlink" title="几何图形"></a>几何图形</h3><ul><li>border</li><li>box-shadow</li><li>border-radius</li></ul><h3 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h3><ul><li>font</li><li>text-decoration</li></ul><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><ul><li>background-image</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS排版</title>
      <link href="2020/12/21/yuque/CSS%E6%8E%92%E7%89%88/"/>
      <url>2020/12/21/yuque/CSS%E6%8E%92%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h2 id="盒（Box"><a href="#盒（Box" class="headerlink" title="盒（Box)"></a>盒（Box)</h2><blockquote><p>HTML 代码中可以书写开始标签，结束标签，和自封闭标签<br>一对起止标签，表示一个元素<br>DOM 树中存储的是元素和其他类型的节点（Node)<br>CSS 选择器选中的是元素<br>CSS 选择器选中的元素，在排版时可能产生多个盒<br>排版和渲染的基本单位是盒</p></blockquote><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/2705850/1608507917849-976f9a05-930c-4cd1-9ce0-3c9417f3bc20.jpeg#align=left&display=inline&height=316&margin=%5Bobject%20Object%5D&name=IMG_F9E013A8321B-1.jpeg&originHeight=962&originWidth=1195&size=1274496&status=done&style=none&width=393" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/jpeg/2705850/1608507917849-976f9a05-930c-4cd1-9ce0-3c9417f3bc20.jpeg#align=left&display=inline&height=316&margin=%5Bobject%20Object%5D&name=IMG_F9E013A8321B-1.jpeg&originHeight=962&originWidth=1195&size=1274496&status=done&style=none&width=393" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="IMG_F9E013A8321B-1.jpeg"><br>盒模型分为两种：</p><blockquote><p>可以通过 box-sizing 来设置不同的盒模型<br>box-sizing 默认值是 content-box</p></blockquote><ol><li>怪异盒模型（border-box)： <code>box-width = content + padding + border</code></li><li>标准盒模型 (content-box)： <code>box-width = content</code><blockquote><p>怪异盒模型在增加 padding 和 border 的宽度时，会保持原有的 box-width 而去对应减少 content 的 width 的所占空间</p></blockquote></li></ol><h2 id="正常流"><a href="#正常流" class="headerlink" title="正常流"></a>正常流</h2><p>正常流的排版：</p><ol><li>收集盒和文字进行计算</li><li>计算盒和文字在行中的排布</li><li>计算行的排布</li></ol><p>IFC：行内级格式化上下文（从左到右排列）<br>BFC：块级格式化上下（从上到下排列）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608591685793-2521eba0-5803-466b-89a6-763608883ac7.png#align=left&display=inline&height=960&margin=%5Bobject%20Object%5D&name=image.png&originHeight=960&originWidth=2226&size=303741&status=done&style=none&width=2226" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608591685793-2521eba0-5803-466b-89a6-763608883ac7.png#align=left&display=inline&height=960&margin=%5Bobject%20Object%5D&name=image.png&originHeight=960&originWidth=2226&size=303741&status=done&style=none&width=2226" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="正常流的行级排布（IFC）"><a href="#正常流的行级排布（IFC）" class="headerlink" title="正常流的行级排布（IFC）"></a>正常流的行级排布（IFC）</h2><h3 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h3><p>下图中黄色的线就是基线，文字是基于<strong>基线</strong>来对齐的。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608592017818-80fa1342-32b6-4329-8d26-f87285f9454b.png#align=left&display=inline&height=62&margin=%5Bobject%20Object%5D&name=image.png&originHeight=248&originWidth=738&size=149484&status=done&style=none&width=185" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608592017818-80fa1342-32b6-4329-8d26-f87285f9454b.png#align=left&display=inline&height=62&margin=%5Bobject%20Object%5D&name=image.png&originHeight=248&originWidth=738&size=149484&status=done&style=none&width=185" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><p>底层软件定义的文字<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608592161826-fb417db4-a214-46c9-a569-a667cbf53176.png#align=left&display=inline&height=169&margin=%5Bobject%20Object%5D&name=image.png&originHeight=676&originWidth=1034&size=367041&status=done&style=none&width=259" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608592161826-fb417db4-a214-46c9-a569-a667cbf53176.png#align=left&display=inline&height=169&margin=%5Bobject%20Object%5D&name=image.png&originHeight=676&originWidth=1034&size=367041&status=done&style=none&width=259" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><ul><li>origin：基线的原点</li><li>advance：排版中文字占据的空间</li><li>bearingX：文字之间的间距</li><li>yMin：文字基线距离文字底部的距离</li></ul><h3 id="行模型"><a href="#行模型" class="headerlink" title="行模型"></a>行模型</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608592669392-5b688eca-283f-4dcb-a9c6-e2d8b49d9a05.png#align=left&display=inline&height=210&margin=%5Bobject%20Object%5D&name=image.png&originHeight=838&originWidth=1276&size=241489&status=done&style=none&width=319" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608592669392-5b688eca-283f-4dcb-a9c6-e2d8b49d9a05.png#align=left&display=inline&height=210&margin=%5Bobject%20Object%5D&name=image.png&originHeight=838&originWidth=1276&size=241489&status=done&style=none&width=319" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><ul><li><p>base-line：基线，文字默认对齐的线</p></li><li><p>text-top、text-bottom：文字的上下边缘线</p><blockquote><p>只要字体的大小不变，text-top 和 text-bottom 就是不变的<br>如果用了多种字体混排的话，那么这个文字的上下边缘就是有 font-size 最大的字体决定的。<br>我们基本可以认为这两条线是固定不变的</p></blockquote></li><li><p>line-top、line-bottom：行的上下边缘线</p><blockquote><p>这两条线的产生是因为行高大于文字的高度</p></blockquote></li></ul><h3 id="文字和盒混排时产生的问题"><a href="#文字和盒混排时产生的问题" class="headerlink" title="文字和盒混排时产生的问题"></a>文字和盒混排时产生的问题</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608593084262-c9db1a4c-cc9d-4337-a842-b06660122bd6.png#align=left&display=inline&height=238&margin=%5Bobject%20Object%5D&name=image.png&originHeight=950&originWidth=1854&size=397540&status=done&style=none&width=464" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608593084262-c9db1a4c-cc9d-4337-a842-b06660122bd6.png#align=left&display=inline&height=238&margin=%5Bobject%20Object%5D&name=image.png&originHeight=950&originWidth=1854&size=397540&status=done&style=none&width=464" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>当一个行内盒是按照 text-bottom 来对齐的话，它就会撑开该行的高度，造成偏移的情况。</p><blockquote><p>当没有蓝色的行内盒的时候，只有文字那么该盒是只有 text-top 和 text-bottom 的高度时，文字看起来排版就比较正常，但是当蓝色盒子出现的时候撑开了 line-top，导致该行整体高度都被撑开了，那么文字相较之前的就会看起来偏下了许多。</p></blockquote><p>Eg：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 50px; line-height: 100px; background-color: bisque&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello good 国<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  &lt;div</span><br><span class="line">    style=&quot;</span><br><span class="line">          display: inline-block;</span><br><span class="line">          line-height: 70px;</span><br><span class="line">          width: 100px;</span><br><span class="line">          height: 150px;</span><br><span class="line">          background-color: cadetblue;</span><br><span class="line">        &quot;</span><br><span class="line">  &gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：<br>文字正常情况按照基线对齐：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608594613929-d627e469-a14d-43ac-8262-8bf03832cfc2.png#align=left&display=inline&height=121&margin=%5Bobject%20Object%5D&name=image.png&originHeight=242&originWidth=722&size=51691&status=done&style=none&width=361" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608594613929-d627e469-a14d-43ac-8262-8bf03832cfc2.png#align=left&display=inline&height=121&margin=%5Bobject%20Object%5D&name=image.png&originHeight=242&originWidth=722&size=51691&status=done&style=none&width=361" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>当我们添加一个行内盒的时候：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608594091726-0caea8c5-9407-453f-b4b4-e5c209ff6a65.png#align=left&display=inline&height=93&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=1092&size=82717&status=done&style=none&width=273" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608594091726-0caea8c5-9407-453f-b4b4-e5c209ff6a65.png#align=left&display=inline&height=93&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=1092&size=82717&status=done&style=none&width=273" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>蓝色的线是 line-top，就被撑开了（该行的整体高度被撑开）。绿色的线是 text-top，行内盒不会影响 text 的边缘线高度。<br>当我们在行内盒添加上一个文字时：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608594403003-766b921d-5f40-4926-abfc-4ecfbc4da80c.png#align=left&display=inline&height=90&margin=%5Bobject%20Object%5D&name=image.png&originHeight=358&originWidth=1006&size=87363&status=done&style=none&width=252" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608594403003-766b921d-5f40-4926-abfc-4ecfbc4da80c.png#align=left&display=inline&height=90&margin=%5Bobject%20Object%5D&name=image.png&originHeight=358&originWidth=1006&size=87363&status=done&style=none&width=252" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>这种情况就相当于，当一个行内盒中有了文字之后，那么对齐的时候就会按照文字的基线去对齐<br>当我们呢在行内盒再添加一个换行和文字时：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608594527028-d79e9601-b55a-46f6-bf8c-42d524096579.png#align=left&display=inline&height=89&margin=%5Bobject%20Object%5D&name=image.png&originHeight=354&originWidth=964&size=94340&status=done&style=none&width=241" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608594527028-d79e9601-b55a-46f6-bf8c-42d524096579.png#align=left&display=inline&height=89&margin=%5Bobject%20Object%5D&name=image.png&originHeight=354&originWidth=964&size=94340&status=done&style=none&width=241" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>会按照最下面文字的基线去进行对齐<br>上面的演示代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 50px; line-height: 100px; background-color: bisque&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- line-top --&gt;</span></span><br><span class="line">  &lt;div</span><br><span class="line">    style=&quot;</span><br><span class="line">          vertical-align: top;</span><br><span class="line">          width: 1px;</span><br><span class="line">          height: 1px;</span><br><span class="line">          display: inline-block;</span><br><span class="line">        &quot;</span><br><span class="line">  &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100vw; height: 1px; background-color: blue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- text-top --&gt;</span></span><br><span class="line">  &lt;div</span><br><span class="line">    style=&quot;</span><br><span class="line">          vertical-align: text-top;</span><br><span class="line">          width: 1px;</span><br><span class="line">          height: 1px;</span><br><span class="line">          display: inline-block;</span><br><span class="line">        &quot;</span><br><span class="line">  &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100vw; height: 1px; background-color: green&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 基线 --&gt;</span></span><br><span class="line">  &lt;div</span><br><span class="line">    style=&quot;</span><br><span class="line">          vertical-align: baseline;</span><br><span class="line">          width: 1px;</span><br><span class="line">          height: 1px;</span><br><span class="line">          display: inline-block;</span><br><span class="line">        &quot;</span><br><span class="line">  &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100vw; height: 1px; background-color: red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- text-bottom --&gt;</span></span><br><span class="line">  &lt;div</span><br><span class="line">    style=&quot;</span><br><span class="line">          vertical-align: text-bottom;</span><br><span class="line">          width: 1px;</span><br><span class="line">          height: 1px;</span><br><span class="line">          display: inline-block;</span><br><span class="line">        &quot;</span><br><span class="line">  &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100vw; height: 1px; background-color: green&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- line-bottom --&gt;</span></span><br><span class="line">  &lt;div</span><br><span class="line">    style=&quot;</span><br><span class="line">          vertical-align: bottom;</span><br><span class="line">          width: 1px;</span><br><span class="line">          height: 1px;</span><br><span class="line">          display: inline-block;</span><br><span class="line">        &quot;</span><br><span class="line">  &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100vw; height: 1px; background-color: blue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello good 国<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  &lt;div</span><br><span class="line">    style=&quot;</span><br><span class="line">          display: inline-block;</span><br><span class="line">          line-height: 70px;</span><br><span class="line">          width: 100px;</span><br><span class="line">          height: 150px;</span><br><span class="line">          background-color: cadetblue;</span><br><span class="line">        &quot;</span><br><span class="line">  &gt;</span><br><span class="line">    M N</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="正常流的块级排布（BFC"><a href="#正常流的块级排布（BFC" class="headerlink" title="正常流的块级排布（BFC)"></a>正常流的块级排布（BFC)</h2><h3 id="float-和-clear"><a href="#float-和-clear" class="headerlink" title="float 和 clear"></a>float 和 clear</h3><p>float：</p><ul><li>严格来说是已经脱离文档流的，他在排列时可以完成图文环绕排的形式。</li><li>多个 float 元素会依次排列，不会占据对方的空间</li><li><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608854033824-58eec322-5bd5-4d17-a5b4-c8d43b51202c.png#align=left&display=inline&height=66&margin=%5Bobject%20Object%5D&name=image.png&originHeight=264&originWidth=1400&size=15569&status=done&style=none&width=350" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608854033824-58eec322-5bd5-4d17-a5b4-c8d43b51202c.png#align=left&display=inline&height=66&margin=%5Bobject%20Object%5D&name=image.png&originHeight=264&originWidth=1400&size=15569&status=done&style=none&width=350" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></li><li>float 会造成重排的问题</li></ul><p>clear：与其说是清除浮动，不如说是在某个方向上找个干净的地方去完成浮动的排列</p><ul><li>与上面同样的代码，只要给第二个 float 的红色 div 设置 <code>clear: right</code>  就可以实现下面这种效果</li><li><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608854110759-07d731d4-93c2-4726-97bf-81e708a9a0f3.png#align=left&display=inline&height=60&margin=%5Bobject%20Object%5D&name=image.png&originHeight=242&originWidth=1405&size=14317&status=done&style=none&width=351" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608854110759-07d731d4-93c2-4726-97bf-81e708a9a0f3.png#align=left&display=inline&height=60&margin=%5Bobject%20Object%5D&name=image.png&originHeight=242&originWidth=1405&size=14317&status=done&style=none&width=351" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></li><li>所以说 clear 更像是在右面找了一个干净的地方进行浮动排列</li></ul><h3 id="margin-折叠"><a href="#margin-折叠" class="headerlink" title="margin 折叠"></a>margin 折叠</h3><p>这种现象只会发生在正常流中，在正常流中只有 BFC 才会有！</p><p>上下两个块级元素都有 margin 的情况下，在排列的时候会选取一个 margin 的最大值作为其最终排版的结果<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608854541877-e2831a64-ad81-4f32-a22f-9b377bd8495f.png#align=left&display=inline&height=188&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1212&originWidth=1650&size=172874&status=done&style=none&width=256" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608854541877-e2831a64-ad81-4f32-a22f-9b377bd8495f.png#align=left&display=inline&height=188&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1212&originWidth=1650&size=172874&status=done&style=none&width=256" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png">  =====&gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608854549792-733a8918-101f-4602-bcbf-2c216a5fe612.png#align=left&display=inline&height=188&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1098&originWidth=1714&size=173370&status=done&style=none&width=294" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608854549792-733a8918-101f-4602-bcbf-2c216a5fe612.png#align=left&display=inline&height=188&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1098&originWidth=1714&size=173370&status=done&style=none&width=294" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="BFC-合并"><a href="#BFC-合并" class="headerlink" title="BFC 合并"></a>BFC 合并</h3><ul><li>Block Container： 里面有 BFC<ul><li>能容纳正常流的盒，里面就有 BFC</li></ul></li><li>BLock-level Box： 外面有 BFC 的</li><li>Block Box = Block container + Block-level Box：里外都有 BFC 的</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pseudo-element: 伪元素</title>
      <link href="2020/12/20/yuque/Pseudo-element!%20%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
      <url>2020/12/20/yuque/Pseudo-element!%20%E4%BC%AA%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<ul><li>::before</li><li>::after</li><li>::first-line 选中第一行</li><li>::first-letter 选中第一个字母</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &lt;::before/&gt; content content content content content content content content</span><br><span class="line">  &lt;::after/&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &lt;::first-letter&gt;c&lt;/::first-letter&gt;ontent content content content</span><br><span class="line">  content content content content</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>first-line 和 first-letter 支持的 css 属性设置：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608462752667-ab307525-ef39-4e99-a142-3fff7b41e87f.png#align=left&display=inline&height=726&margin=%5Bobject%20Object%5D&name=image.png&originHeight=726&originWidth=1638&size=537528&status=done&style=none&width=1638" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1608462752667-ab307525-ef39-4e99-a142-3fff7b41e87f.png#align=left&display=inline&height=726&margin=%5Bobject%20Object%5D&name=image.png&originHeight=726&originWidth=1638&size=537528&status=done&style=none&width=1638" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Calculating specificity：计算优先级</title>
      <link href="2020/12/20/yuque/Calculating%20specificity%EF%BC%9A%E8%AE%A1%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>2020/12/20/yuque/Calculating%20specificity%EF%BC%9A%E8%AE%A1%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><p>为给定元素计算它的优先级，遵循以下原则：</p><ul><li>计算 ID 选择器的值  A</li><li>计算类选择、属性选择器、伪类选择器的值  B</li><li>计算标签选择器和伪元素选择器的值  C</li><li>忽略通用选择器*</li></ul><ol><li><p>:is()、:not()、:has(),这三个伪类选择器的计算值将被其中优先级最高的值所代替</p><blockquote><p>eg:<br>:is(#id)   [1,0,0] 伪类的优先级值 B 被 id 的高优先值所代替</p></blockquote></li><li><p>类似的, :nth-child()、：nth-last-child()的计算值是一个伪类的值加上参数的计算值之和。</p><blockquote><p>eg:<br>:nth-child(.item)  [0,2,0]   伪类的值加上参数.item 的值</p></blockquote></li><li><p>:where() 伪类的计算值为 0</p><blockquote><p>eg:<br>.item:where(em,#foo)  [0,1,0]  where 伪类的值为 0</p></blockquote></li></ol><p>【A，B，C】</p><blockquote><ul><li>/_ a=0 b=0 c=0 <em>/<br>LI                                      /</em> a=0 b=0 c=1 <em>/<br>UL LI                                  /</em> a=0 b=0 c=2 <em>/<br>UL OL+LI                           /</em> a=0 b=0 c=3 _/<br>H1 + <em>[REL=up]                  /</em> a=0 b=1 c=1 <em>/<br>UL OL LI.red                      /</em> a=0 b=1 c=3 <em>/<br>LI.red.level                        /</em> a=0 b=2 c=1 <em>/<br>#x34y                               /</em> a=1 b=0 c=0 <em>/<br>#s12:not(FOO)                   /</em> a=1 b=0 c=1 <em>/<br>.foo :is(.bar, #baz)             /</em> a=1 b=1 c=0 */</li></ul></blockquote><p>官方文档是按照 3 位来计算优先级的，就是上图中的：<br>[A, B, C]<br>还有一种计算方式是按照四位来计算的，最高位表示是否为行内样式：<br>[ L, A, B, C]</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-id">#a</span><span class="selector-class">.b</span> <span class="selector-class">.c</span><span class="selector-attr">[id=x]</span> <span class="selector-attr">[0, 1, 3, 1]</span></span><br><span class="line"><span class="selector-id">#a</span><span class="selector-pseudo">:not</span>(<span class="selector-id">#b</span>) <span class="selector-attr">[0, 2, 0, 0]</span></span><br><span class="line">*<span class="selector-class">.a</span> <span class="selector-attr">[0, 0, 1, 0]</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.a</span> <span class="selector-attr">[0, 0, 1, 1]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pseudo-Class：伪类</title>
      <link href="2020/12/20/yuque/Pseudo-Class%EF%BC%9A%E4%BC%AA%E7%B1%BB/"/>
      <url>2020/12/20/yuque/Pseudo-Class%EF%BC%9A%E4%BC%AA%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="链接-行为"><a href="#链接-行为" class="headerlink" title="链接/行为"></a>链接/行为</h2><p>之前这些伪类的实现都是为了超链接设计的，但是现在有很多伪类都可以用到其他元素上了。</p><ul><li><p>:any-link 任何超链接</p></li><li><p>:link 没有访问过的超链接</p></li><li><p>:visited     已经访问过的超链接</p><blockquote><p>any-link 可以看做是 link 和 visited 的结合<br>Tips：<br>一旦使用了 link 或者 visited 伪类之后，就没有办法去修改除了颜色以外的 css 属性了。<br>这样做是为了浏览器安全考虑的。因为一旦你更改了像 visited 超链接的大小的时候，就可以让别人明显感受到你访问过哪些网站，这对于用户来说是不太容易接受的，就像泄漏了隐私一样，也不符合浏览器安全的相关策略。</p></blockquote></li><li><p>:hover</p></li><li><p>:active</p></li><li><p>:focus</p></li><li><p>:target</p></li></ul><h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><ul><li>:empty</li><li>:nth-child()     从前让后数</li><li>:nth-last-child() 从后往前数</li><li>:first-child</li><li>:last-child</li><li>:only-child</li></ul><h2 id="逻辑型"><a href="#逻辑型" class="headerlink" title="逻辑型"></a>逻辑型</h2><ul><li>:not 伪类</li><li>:where</li><li>:has</li></ul><p>在 css 书写过程中，我们不应该写过于复杂的选择器，这样一是对性能不好，二是可能自己 HTML 结构设计的有问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Selector: 选择器</title>
      <link href="2020/12/20/yuque/Selector!%20%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>2020/12/20/yuque/Selector!%20%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h3><ul><li>-</li><li>div、svg、a</li><li>.class</li><li>#id</li><li>[attr=value]</li><li>:hover</li><li>::before</li></ul><h3 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h3><ul><li>&lt;简单选择器&gt;&lt;简单选择器&gt;&lt;简单选择器&gt;</li><li><ul><li>或者 div 必须写在最前面</li></ul></li></ul><h3 id="复杂选择器"><a href="#复杂选择器" class="headerlink" title="复杂选择器"></a>复杂选择器</h3><ul><li>&lt;复合选择器&gt;<sp>&lt;复合选择器&gt;</li><li>&lt;复合选择器&gt;”&gt;”&lt;复合选择器&gt;</li><li>&lt;复合选择器&gt;”~”&lt;复合选择器&gt;</li><li>&lt;复合选择器&gt;”+”&lt;复合选择器&gt;</li><li>&lt;复合选择器&gt;”||”&lt;复合选择器&gt;</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>翻译记录</title>
      <link href="2020/12/15/yuque/%E7%BF%BB%E8%AF%91%E8%AE%B0%E5%BD%95/"/>
      <url>2020/12/15/yuque/%E7%BF%BB%E8%AF%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Selectors-Level-4"><a href="#Selectors-Level-4" class="headerlink" title="Selectors Level 4"></a>Selectors Level 4</h2><h3 id="Selector-syntax-选择器语法）"><a href="#Selector-syntax-选择器语法）" class="headerlink" title="Selector syntax(选择器语法）"></a>Selector syntax(选择器语法）</h3><p>一个选择器是由一个或者多个简单选择器序列组合而成的，他们通过<strong>连接符（Combinators）</strong>分割开。并且在一个选择器中的最后一个简单选择器的末尾可以添加一个伪元素。</p><p>简单选择器序列（sequences of simple selectors)：由一连串没有使用<strong>连接符（Combinators）</strong>分割开来的简单选择器组合而成。通常是由标签选择器（h1、div）和通用选择器（*）作为开头。在简单选择器序列中不允许其他的标签选择器或者是通用选择器。</p><p>简单选择器（simple selectors）：</p><ul><li>标签选择器(h1)</li><li>通用选择器(*)</li><li>属性选择器（[])</li><li>类选择器(.)</li><li>id 选择器(#)</li><li>伪类选择器（::)</li></ul><p>连接符（Combinators）：</p><ul><li>whitespace 空格</li><li><blockquote></blockquote></li><li>-</li><li>~</li></ul><h2 id="Calculating-a-selector’s-specificity-计算选择器的优先级）"><a href="#Calculating-a-selector’s-specificity-计算选择器的优先级）" class="headerlink" title="Calculating a selector’s specificity(计算选择器的优先级）"></a>Calculating a selector’s specificity(计算选择器的优先级）</h2><p>为给定元素计算它的优先级，遵循以下原则：</p><ul><li>计算 ID 选择器的值 A</li><li>计算类选择、属性选择器、伪类选择器的值 B</li><li>计算标签选择器和伪元素选择器的值 C</li><li>忽略通用选择器*</li></ul><ol><li><p>:is()、:not()、:has(),这三个伪类选择器的计算值将被其中优先级最高的值所代替</p><blockquote><p>eg:<br>:is(#id) [1,0,0] 伪类的优先级值 B 被 id 的高优先值所代替</p></blockquote></li><li><p>类似的, :nth-child()、：nth-last-child()的计算值是一个伪类的值加上参数的计算值之和。</p><blockquote><p>eg:<br>:nth-child(.item) [0,2,0] 伪类的值加上参数.item 的值</p></blockquote></li><li><p>:where() 伪类的计算值为 0</p><blockquote><p>eg:<br>.item:where(em,#foo) [0,1,0] where 伪类的值为 0</p></blockquote></li></ol><p>【A，B，C】</p><blockquote><ul><li>/_ a=0 b=0 c=0 <em>/<br>LI                                      /</em> a=0 b=0 c=1 <em>/<br>UL LI                                  /</em> a=0 b=0 c=2 _/</li></ul></blockquote><blockquote><p>UL OL+LI                           /_ a=0 b=0 c=3 _/</p></blockquote><blockquote><p>H1 + <em>[REL=up]                  /</em> a=0 b=1 c=1 */</p></blockquote><blockquote><p>UL OL LI.red                      /_ a=0 b=1 c=3 _/</p></blockquote><blockquote><p>LI.red.level                        /_ a=0 b=2 c=1 _/</p></blockquote><blockquote><p>#x34y                               /_ a=1 b=0 c=0 _/</p></blockquote><blockquote><p>#s12:not(FOO)                   /_ a=1 b=0 c=1 _/</p></blockquote><blockquote><p>.foo :is(.bar, #baz)             /_ a=1 b=1 c=0 _/</p></blockquote><h2 id="Grammar"><a href="#Grammar" class="headerlink" title="Grammar"></a>Grammar</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS结构</title>
      <link href="2020/12/14/yuque/CSS%E7%BB%93%E6%9E%84/"/>
      <url>2020/12/14/yuque/CSS%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>因为找不到一个明确的语法线索，所以我们这里根据 2.1 版本的语法来进行学习。<br>现版本 css 多了很多 css3 的语法，但是不影响我们理解他的语法结构。</p><h2 id="CSS2-1-语法"><a href="#CSS2-1-语法" class="headerlink" title="CSS2.1 语法"></a>CSS2.1 语法</h2><ul><li><a href="http://www.ayqy.net/doc/css2-1/grammar.html">css2.1Grammar 中文对照版</a></li></ul><h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p>一个样式文件从上到下的顺序结构：</p><ol><li><p>@charset</p><blockquote><p><code>@charset &#39;UTF-8&#39;;</code> <br>声明 css 文件的字符编码标准。</p><ul><li>必须在样式表的第一行声明</li><li>如果有多个@charset 声明，那么只有第一个会生效</li><li>无法在 HTML 的 style 标签里使用该 at-rule 规则</li></ul><p>Tip:<br>在样式表中声明字符编码有很多种方式，浏览器会按照以下顺序去尝试确定文件的编码方式（只要找到一种就会停止并得出结果）：</p><ol><li>文件开头的  <a href="http://en.wikipedia.org/wiki/Byte_order_mark">Unicode byte-order</a>  字符值</li><li>由 Content-type 确定：HTTP 协议中的  charset 属性给出的值或用于提供样式表的协议中的等效值</li><li>CSS @rule 规则：@charset</li><li>假设文档上是 UTF-8 的格式</li></ol></blockquote></li><li><p>@import</p></li><li><p>rules （这部分是我们日常最常用到的部分）</p><ol><li>@media</li><li>@page</li><li>rule</li></ol></li></ol><h2 id="CSS-规则的结构"><a href="#CSS-规则的结构" class="headerlink" title="CSS 规则的结构"></a>CSS 规则的结构</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="comment">/* selector */</span> &#123;</span><br><span class="line">  <span class="comment">/* key */</span></span><br><span class="line">  <span class="attribute">background-color</span>: /* value */ red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的 css 代码可以明确 css 规则的结构分为以下两个部分：</p><ol><li>Selector（选择器）</li><li>Declare（声明）<ol><li>key</li><li>value</li></ol></li></ol><h2 id="爬取-w3c-的-css-规则"><a href="#爬取-w3c-的-css-规则" class="headerlink" title="爬取 w3c 的 css 规则"></a>爬取 w3c 的 css 规则</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(</span><br><span class="line">  <span class="built_in">Array</span>.prototype.slice</span><br><span class="line">    .call(<span class="built_in">document</span>.querySelector(<span class="string">&quot;#container&quot;</span>).children)</span><br><span class="line">    .filter(<span class="function">(<span class="params">e</span>) =&gt;</span> e.getAttribute(<span class="string">&quot;data-tag&quot;</span>).match(<span class="regexp">/css/</span>))</span><br><span class="line">    .map(<span class="function">(<span class="params">e</span>) =&gt;</span> (&#123;</span><br><span class="line">      name: e.children[<span class="number">1</span>].children[<span class="number">0</span>].innerText,</span><br><span class="line">      url: e.children[<span class="number">1</span>].children[<span class="number">0</span>].href,</span><br><span class="line">    &#125;))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/2705850/1608424173469-cf7b1df7-98e3-4d61-aa22-74c472f7e380.jpeg" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/jpeg/2705850/1608424173469-cf7b1df7-98e3-4d61-aa22-74c472f7e380.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>链表篇</title>
      <link href="2020/12/10/yuque/%E9%93%BE%E8%A1%A8%E7%AF%87/"/>
      <url>2020/12/10/yuque/%E9%93%BE%E8%A1%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="【206】反转链表"><a href="#【206】反转链表" class="headerlink" title="【206】反转链表"></a>【206】反转链表</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><blockquote><p>反转一个单链表。</p></blockquote><blockquote><p><strong>示例:</strong> &gt; <strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br><strong>输出:</strong> 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这是个经典的链表问题，其实这个问题的关键就在于要<strong>提前保存下一个节点</strong>的值。<br>因为你在让当前节点指向上一个节点的过程中，就会把当前节点的 next 指向改变，如果不提前保存当前节点的 next 值的话，就会找不到原有的当前节点的 next 值。</p><h4 id="迭代大法"><a href="#迭代大法" class="headerlink" title="迭代大法"></a>迭代大法</h4><ol><li> 时间复杂度：O(n)</li><li> 空间复杂度：O(1)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> reverList = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cur = head;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">  <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">    <span class="comment">// 记录当前节点的下一个节点</span></span><br><span class="line">    tmp = cur.next;</span><br><span class="line">    <span class="comment">// 改变当前节点的next指针指向</span></span><br><span class="line">    cur.next = prev;</span><br><span class="line">    <span class="comment">// 更新上一个节点的值</span></span><br><span class="line">    prev = cur;</span><br><span class="line">    <span class="comment">// 更新当前节点</span></span><br><span class="line">    cur = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h4><ol><li> 时间复杂度：O(n)</li><li> 空间复杂度：O(1)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverList = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> rever = <span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 严谨性判断，当cur为空时链表翻转结束</span></span><br><span class="line">    <span class="keyword">if</span> (!cur) <span class="keyword">return</span> prev;</span><br><span class="line">    <span class="comment">// 提前保存上一个节点的值</span></span><br><span class="line">    <span class="keyword">const</span> tmp = cur.next;</span><br><span class="line">    cur.next = prev;</span><br><span class="line">    <span class="keyword">return</span> rever(cur, tmp);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> rever(<span class="literal">null</span>, head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="【237】删除链表中的节点"><a href="#【237】删除链表中的节点" class="headerlink" title="【237】删除链表中的节点"></a>【237】删除链表中的节点</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><blockquote><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。</p></blockquote><blockquote><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612594950984-e304d392-65d6-41ca-8761-e2a68b61369c.png#align=left&display=inline&height=74&margin=%5Bobject%20Object%5D&name=image.png&originHeight=148&originWidth=686&size=17423&status=done&style=none&width=343" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612594950984-e304d392-65d6-41ca-8761-e2a68b61369c.png#align=left&display=inline&height=74&margin=%5Bobject%20Object%5D&name=image.png&originHeight=148&originWidth=686&size=17423&status=done&style=none&width=343" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png">&gt; <img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612594962942-0f13002a-db9c-4ea8-b102-6f90d1d4bf42.png#align=left&display=inline&height=286&margin=%5Bobject%20Object%5D&name=image.png&originHeight=572&originWidth=1294&size=74872&status=done&style=none&width=647" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612594962942-0f13002a-db9c-4ea8-b102-6f90d1d4bf42.png#align=left&display=inline&height=286&margin=%5Bobject%20Object%5D&name=image.png&originHeight=572&originWidth=1294&size=74872&status=done&style=none&width=647" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"> &gt; <img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612594962942-0f13002a-db9c-4ea8-b102-6f90d1d4bf42.png#align=left&display=inline&height=286&margin=%5Bobject%20Object%5D&name=image.png&originHeight=572&originWidth=1294&size=74872&status=done&style=none&width=647" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612594962942-0f13002a-db9c-4ea8-b102-6f90d1d4bf42.png#align=left&display=inline&height=286&margin=%5Bobject%20Object%5D&name=image.png&originHeight=572&originWidth=1294&size=74872&status=done&style=none&width=647" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png">    &gt; <a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">链接</a></p></blockquote><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这道题的总体思路就是<strong>狸猫换太子。</strong></p><ol><li> 单向链表我们无法获取到上一项的值，去改变上一项的 next 指向</li><li> 所以我们换种思路，将传入的这个需要删除的节点直接替换成下一个节点，具体替换步骤也是分为两步：</li><li> 替换 val 值</li><li> 替换 next 节点</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">node</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将需要删除的当前节点的值替换为下一个节点的值</span></span><br><span class="line">  node.val = node.next.val;</span><br><span class="line">  <span class="comment">// 将需要删的节点next指向下一个节点的next</span></span><br><span class="line">  node.next = node.next.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)<br>空间复杂度：O(1)</p><h2 id="【2】两数相加"><a href="#【2】两数相加" class="headerlink" title="【2】两数相加"></a>【2】两数相加</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><blockquote><p>给你两个   非空 的链表，表示两个非负的整数。它们每位数字都是按照   逆序   的方式存储的，并且每个节点只能存储   一位   数字。</p></blockquote><blockquote></blockquote><blockquote><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p></blockquote><blockquote></blockquote><blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612684035912-bad5471f-ecdd-4cd5-97bb-7e106279b2b2.png#align=left&display=inline&height=388&margin=%5Bobject%20Object%5D&name=image.png&originHeight=776&originWidth=1022&size=113528&status=done&style=none&width=511" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/2705850/1612684035912-bad5471f-ecdd-4cd5-97bb-7e106279b2b2.png#align=left&display=inline&height=388&margin=%5Bobject%20Object%5D&name=image.png&originHeight=776&originWidth=1022&size=113528&status=done&style=none&width=511" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br>输入：l1 = [2,4,3], l2 = [5,6,4]</p></blockquote><blockquote><p>输出：[7,0,8]</p></blockquote><blockquote><p>解释：342 + 465 = 807.</p></blockquote><blockquote><p>示例 2：</p></blockquote><blockquote><p>输入：l1 = [0], l2 = [0]</p></blockquote><blockquote><p>输出：[0]</p></blockquote><blockquote><p>示例 3：</p></blockquote><blockquote><p>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</p></blockquote><blockquote><p>输出：[8,9,9,9,0,0,0,1]</p></blockquote><blockquote><p>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a></p></blockquote><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个需要返回的新链表</span></span><br><span class="line">  <span class="keyword">const</span> l3 = <span class="keyword">new</span> ListNode();</span><br><span class="line">  <span class="comment">// 保存每个链表的节点指针</span></span><br><span class="line">  <span class="keyword">let</span> p1 = l1;</span><br><span class="line">  <span class="keyword">let</span> p2 = l2;</span><br><span class="line">  <span class="keyword">let</span> p3 = l3;</span><br><span class="line">  <span class="comment">// 创建变量来存储进位</span></span><br><span class="line">  <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 遍历 p1 和 p2 每个节点的val值进行相加</span></span><br><span class="line">  <span class="comment">// 这里需要注意： 因为p1和p2可能长度不同，所以当其中一个有值时都需要相加，没有值的那个用0代替</span></span><br><span class="line">  <span class="keyword">while</span> (p1 || p2) &#123;</span><br><span class="line">    <span class="keyword">const</span> v1 = p1 ? p1.val : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> v2 = p2 ? p2.val : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算和，要加上前一个数字相加的进位</span></span><br><span class="line">    <span class="keyword">const</span> sum = v1 + v2 + carry;</span><br><span class="line">    <span class="comment">// 计算进位，这里需要注意要将进位向下取整</span></span><br><span class="line">    carry = <span class="built_in">Math</span>.floor(sum / <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 将个位数字放入l3链表中</span></span><br><span class="line">    p3.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新指针</span></span><br><span class="line">    <span class="keyword">if</span> (p1) p1 = p1.next;</span><br><span class="line">    <span class="keyword">if</span> (p2) p2 = p2.next;</span><br><span class="line">    p3 = p3.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历结束后，判断进位，如果扔有进位放入l3链表中</span></span><br><span class="line">  <span class="keyword">if</span> (carry) p3.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">  <span class="comment">// 因为我们在创建新链表时，首位是0，所以我们要从头节点的下一位开始</span></span><br><span class="line">  <span class="keyword">return</span> l3.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>useCallback</title>
      <link href="2020/12/08/yuque/useCallback/"/>
      <url>2020/12/08/yuque/useCallback/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Toy-Brower</title>
      <link href="2020/12/02/yuque/Toy-Brower/"/>
      <url>2020/12/02/yuque/Toy-Brower/</url>
      
        <content type="html"><![CDATA[<p>为了更加了解浏览器的工作原理，我们来自己用代码搞一个浏览器玩一下。</p><h2 id="基本功能描述"><a href="#基本功能描述" class="headerlink" title="基本功能描述"></a>基本功能描述</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607396985290-ee9fbd15-7e2e-4ab0-9f71-7adf34a29f88.png#align=left&display=inline&height=178&margin=%5Bobject%20Object%5D&name=image.png&originHeight=178&originWidth=1506&size=163962&status=done&style=none&width=1506" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607396985290-ee9fbd15-7e2e-4ab0-9f71-7adf34a29f88.png#align=left&display=inline&height=178&margin=%5Bobject%20Object%5D&name=image.png&originHeight=178&originWidth=1506&size=163962&status=done&style=none&width=1506" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="HTTP-实现"><a href="#HTTP-实现" class="headerlink" title="HTTP 实现"></a>HTTP 实现</h3><p>为了实现浏览器发送网络请求的这一部分，需要梳理一下这部分所需要的功能。</p><ol><li><p>构建请求信息（请求方法、请求行、请求头、请求体）</p></li><li><p>建立网络连接（net.createServer()）</p></li><li><p>接收响应结果</p></li><li><p>处理响应结果</p><ol><li>处理响应头</li><li>处理响应体 - 利用单独的子类进行 body text 的处理</li></ol></li><li><p>构造一个发送请求的类 <code>Request</code></p><blockquote><p>思考：这个类都需要什么东西？</p><ul><li>首先需要一些发送请求时需要配置的基本配置项（options）<ul><li>url    请求路径</li><li>port     请求端口</li><li>method     请求方法</li><li>headers     请求头</li><li>body     请求体</li></ul></li><li>其次需要一个发送该请求的方法（send）<ul><li>该方法返回一个 promise 对象，该对象是请求回来的结果</li><li>该方法的功能：<ul><li>构造请求并发送，发送前需要拼接上请求行、请求头、换行、请求体等信息。</li><li>接受请求结果</li></ul></li></ul></li></ul></blockquote></li><li><p>构造一个解析响应的类 <code>ResponseParse</code></p><blockquote><ul><li>response 返回的结果需要分段来进行处理，所以我们需要一个 ResponseParse 来进行装配</li><li>ResponseParse 来分段处理返回的结果，我们用有限状态机来记录完成这一个过程</li><li>针对 response body 中的内容采用另一个方法进行分段解析</li></ul></blockquote></li><li><p>构造一个类 <code>TrunkedBodyParser</code></p><blockquote><ul><li>response body 针对不通的 Content-type 类型会有不同的处理方法</li><li>我们这里针对 chunk 类型进行解析</li></ul></blockquote></li></ol><hr><h3 id="HTML-解析的实现"><a href="#HTML-解析的实现" class="headerlink" title="HTML 解析的实现"></a>HTML 解析的实现</h3><ol><li>接收响应体进行解析</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607643059789-38ccd590-7e2b-42a1-8852-b7b75fa9d219.png#align=left&display=inline&height=64&margin=%5Bobject%20Object%5D&name=image.png&originHeight=128&originWidth=1108&size=79721&status=done&style=none&width=554" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1607643059789-38ccd590-7e2b-42a1-8852-b7b75fa9d219.png#align=left&display=inline&height=64&margin=%5Bobject%20Object%5D&name=image.png&originHeight=128&originWidth=1108&size=79721&status=done&style=none&width=554" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><ol start="2"><li><p>构造状态机进行标签解析</p><ol><li>开始标签<ol><li><code>&lt;</code>  开始标签的标志</li><li><code>/n/t </code>  空格标志后面是标签属性</li></ol></li><li>结束标签<ol><li><code>/</code>  结束标签的标志</li><li><code>&gt;</code>  标签解析结束，开始下一个标签解析</li></ol></li><li>自封闭标签<ol><li><code>&lt;/</code>  自闭和标签的标志</li></ol></li></ol></li><li><p>利用 currentToken 变量接受解析结果</p><ol><li><code>text</code>文本类型</li><li><code>statTag</code>开始标签类型</li><li><code>endTag</code>结束标签类型</li><li><code>isSelfCloseTag</code>自闭和标签标志<blockquote><p>每次当前标签结束时需要<code>emit(currentToken)</code>来触发当前标签结束的事件</p></blockquote></li></ol></li><li><p>解析标签属性</p><ol><li>氛围 attributeName 和 value 两部分进行解析</li><li>解析完成之后 emit 对应数据</li></ol></li><li><p>构建 DOM 树</p><ol><li>使用栈进行构造</li><li>遇到开始标签就处理好相关属性和元素名入栈</li><li>遇到自闭和标签就相当入栈后立即出栈</li><li>遇到闭合标签就找到对应标签出栈</li></ol></li></ol><h3 id="CSS-计算"><a href="#CSS-计算" class="headerlink" title="CSS 计算"></a>CSS 计算</h3><ol><li>遇到 style 标签时，将 css 规则保存起来，使用 css parser 解析规则</li><li>当创建一个元素后应立即计算 css<ol><li>理论上当我们分析一个元素时，是假设这个元素的 css 规则已经全部收集完毕的</li></ol></li><li>在 computedCss 函数中，我们需要知道所有元素的父元素才可以去判断元素是否与规则匹配<ol><li>由于我们首先获取的是当前元素，所以我们获得和计算父元素匹配的顺序是由内到外的</li></ol></li><li>选择器也是由内向外匹配排列的</li><li>根据选择器的类型和元素属性，计算是否当前的元素匹配</li><li>元素匹配完成就应用选择器到元素上，形成 computedSty</li><li>css 规则具有优先级，我们利用 specificity 特征去进行判断比较<ol><li>specificity 是一个四元组，越左边权重越重<ol><li>[0,0,0,]</li><li>inline、id、class、tag</li></ol></li><li>css 规则的 specificity 是根据所包含的简单选择器相加形成的<br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/2705850/1607825664969-8a234679-ac32-4c70-a494-6f6a7a466227.jpeg" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/jpeg/2705850/1607825664969-8a234679-ac32-4c70-a494-6f6a7a466227.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码效率优化方法论</title>
      <link href="2020/12/02/yuque/%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
      <url>2020/12/02/yuque/%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="如何衡量一段代码的优劣呢？"><a href="#如何衡量一段代码的优劣呢？" class="headerlink" title="如何衡量一段代码的优劣呢？"></a>如何衡量一段代码的优劣呢？</h2><p>一般我们会从两个维度去考虑一段代码的质量：</p><ol><li>时间复杂度</li><li>空间复杂度</li></ol><p>顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。<br>那么我们应该怎么取舍这两个标准呢？</p><h2 id="提高代码效率的方法"><a href="#提高代码效率的方法" class="headerlink" title="提高代码效率的方法"></a>提高代码效率的方法</h2><p>我们从上面已经知道了衡量代码效率的方法，那么我们应该怎么着手去优化提高我们代码的效率呢？</p><p>总的策略就是降低代码的时间复杂度和空间复杂度。</p><p>但是对于一段代码来说往往时间和空间两个是互斥的，如果我们想要降低时间复杂度，那么无疑就会增加空间复杂度。<br>举一个生活中的 🌰，就像我们平时生活中开车过红绿灯，如果只有这一条路（空间）那么我们就只能在这等着红灯，当车越来越多的时候，就会消耗大家很多时间，但是当我们修建了立交桥之后，就会有更多的选择空间，就会大大减少等待红灯的时间。<br><img src="https://cdn.nlark.com/yuque/0/2020/gif/2705850/1606953443121-946ba365-7a49-4689-8090-5e820840f5eb.gif#align=left&display=inline&height=720&margin=%5Bobject%20Object%5D&name=CgqCHl7CRMaAO_oEAJfz6fjfMNQ403.gif&originHeight=720&originWidth=1280&size=9958377&status=done&style=none&width=1280" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/2705850/1606953443121-946ba365-7a49-4689-8090-5e820840f5eb.gif#align=left&display=inline&height=720&margin=%5Bobject%20Object%5D&name=CgqCHl7CRMaAO_oEAJfz6fjfMNQ403.gif&originHeight=720&originWidth=1280&size=9958377&status=done&style=none&width=1280" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="CgqCHl7CRMaAO_oEAJfz6fjfMNQ403.gif"><br>（图片来自拉钩教育-公瑾老师的重学算法与数据结构一课中）<br>而对我们来说，时间永远都要比空间更加重要，因为时间拿钱买不来，而空间我们起码可以拿钱来进行扩容。<br><strong>空间是廉价的，时间是昂贵的</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/2705850/1606953817114-7e1a263e-6acb-4bf2-9110-da34521c23f8.png#align=left&display=inline&height=76&margin=%5Bobject%20Object%5D&name=image.png&originHeight=152&originWidth=142&size=26430&status=done&style=none&width=71" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/2705850/1606953817114-7e1a263e-6acb-4bf2-9110-da34521c23f8.png#align=left&display=inline&height=76&margin=%5Bobject%20Object%5D&name=image.png&originHeight=152&originWidth=142&size=26430&status=done&style=none&width=71" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></strong></p><ol><li>暴力解法：在没有任何时间和空间的限制下，将目标达成</li><li>剔除无效操作：将代码中没有必要的计算、无效的存储删除来优化时间和空间复杂度</li><li>时空转换：设计合理的数据结构，将时间向空间转换</li></ol><h2 id="增删查：数据的基本操作"><a href="#增删查：数据的基本操作" class="headerlink" title="增删查：数据的基本操作"></a>增删查：数据的基本操作</h2><p>一般一段算法的实现最常设计的三个操作就是：增、删、查。<br>而我们对一个算法的优化和实现只要围绕这三个为重心去思考展开即可：</p><ol><li>分析这段代码对数据进行了那些操作</li><li>这些操作中有哪些操作是最消耗性能的，对时间复杂度的损耗是最高的？</li><li>考虑有哪种数据结构可以帮助提高数据操作的使用效率。</li></ol><p>以上三点就是构成我们实现代码效率优化的方法论。</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ol><li>按照元素索引查找<ul><li>对于数组这些天生拥有索引的数据结构来说十分简单</li><li>对于链表这种，通过指针进行连接的就需要知道前面一个元素</li></ul></li><li>按照元素特征值查找<ul><li>对于字典类型的数据来说，key 就相当是特征，value 就是值，查找起来非常方便</li><li>对于数组和链表来说就需要循环对比每个元素来进行比较值的特征是否符合</li></ul></li></ol><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ol><li>在复杂数据结构的末尾添加数据<ul><li>不会影响数据的原始位置</li></ul></li><li>在复杂数据结构的中间添加数据<ul><li>会影响到数据原始的位置</li></ul></li></ol><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ol><li>在复杂数据结构的末尾删除<ul><li>不会影响到原先数据的位置</li></ul></li><li>在复杂数据结构的中间位置进行删除<ul><li>会影响到之前数据的原始位置</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

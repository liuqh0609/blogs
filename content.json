{"meta":{"title":"火热","subtitle":"","description":"你我山巅自相逢，予你与我遇清风","author":"火热","url":"https://blog.lqh.kim","root":"/"},"pages":[{"title":"","date":"2021-05-13T22:50:54.534Z","updated":"2021-05-13T22:50:54.534Z","comments":true,"path":"404.html","permalink":"https://blog.lqh.kim/404.html","excerpt":"","text":""},{"title":"","date":"2021-05-13T22:50:54.534Z","updated":"2021-05-13T22:50:54.534Z","comments":true,"path":"about/index.html","permalink":"https://blog.lqh.kim/about/index.html","excerpt":"","text":"对生活保持热爱对知识保持敬畏"},{"title":"所有分类","date":"2021-05-13T22:50:54.534Z","updated":"2021-05-13T22:50:54.534Z","comments":true,"path":"categories/index.html","permalink":"https://blog.lqh.kim/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-05-13T22:50:54.534Z","updated":"2021-05-13T22:50:54.534Z","comments":true,"path":"tags/index.html","permalink":"https://blog.lqh.kim/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"代码效率优化方法论","slug":"代码效率优化方法论","date":"2021-05-13T22:50:54.534Z","updated":"2021-05-13T22:50:54.534Z","comments":true,"path":"2021/05/14/代码效率优化方法论/","link":"","permalink":"https://blog.lqh.kim/2021/05/14/%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%AE%BA/","excerpt":"","text":"代码效率优化方法论如何衡量一段代码的优劣呢？一般我们会从两个维度去考虑一段代码的质量： 时间复杂度 空间复杂度 顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。那么我们应该怎么取舍这两个标准呢？ 提高代码效率的方法我们从上面已经知道了衡量代码效率的方法，那么我们应该怎么着手去优化提高我们代码的效率呢？ 总的策略就是降低代码的时间复杂度和空间复杂度。 但是对于一段代码来说往往时间和空间两个是互斥的，如果我们想要降低时间复杂度，那么无疑就会增加空间复杂度。举一个生活中的 🌰，就像我们平时生活中开车过红绿灯，如果只有这一条路（空间）那么我们就只能在这等着红灯，当车越来越多的时候，就会消耗大家很多时间，但是当我们修建了立交桥之后，就会有更多的选择空间，就会大大减少等待红灯的时间。（图片来自拉钩教育-公瑾老师的重学算法与数据结构一课中）而对我们来说，时间永远都要比空间更加重要，因为时间拿钱买不来，而空间我们起码可以拿钱来进行扩容。空间是廉价的，时间是昂贵的 暴力解法：在没有任何时间和空间的限制下，将目标达成 剔除无效操作：将代码中没有必要的计算、无效的存储删除来优化时间和空间复杂度 时空转换：设计合理的数据结构，将时间向空间转换 增删查：数据的基本操作一般一段算法的实现最常设计的三个操作就是：增、删、查。而我们对一个算法的优化和实现只要围绕这三个为重心去思考展开即可： 分析这段代码对数据进行了那些操作 这些操作中有哪些操作是最消耗性能的，对时间复杂度的损耗是最高的？ 考虑有哪种数据结构可以帮助提高数据操作的使用效率。 以上三点就是构成我们实现代码效率优化的方法论。 查 按照元素索引查找 对于数组这些天生拥有索引的数据结构来说十分简单 对于链表这种，通过指针进行连接的就需要知道前面一个元素 按照元素特征值查找 对于字典类型的数据来说，key 就相当是特征，value 就是值，查找起来非常方便 对于数组和链表来说就需要循环对比每个元素来进行比较值的特征是否符合 增 在复杂数据结构的末尾添加数据 不会影响数据的原始位置 在复杂数据结构的中间添加数据 会影响到数据原始的位置 删 在复杂数据结构的末尾删除 不会影响到原先数据的位置 在复杂数据结构的中间位置进行删除 会影响到之前数据的原始位置","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"时间复杂度&空间复杂度","slug":"时间复杂度&空间复杂度","date":"2021-05-13T22:50:54.534Z","updated":"2021-05-13T22:50:54.534Z","comments":true,"path":"2021/05/14/时间复杂度&空间复杂度/","link":"","permalink":"https://blog.lqh.kim/2021/05/14/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"","text":"时间复杂度&amp;空间复杂度复杂度的作用一般我们会从两个维度去考虑一段代码的质量： 时间复杂度 空间复杂度 顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。 所以时间复杂度和空间复杂度一般是用来衡量一段代码的优劣的。 那么我们应该怎么来定义复杂度呢？ 复杂度的定义与特点定义 复杂度是一个关于输入量 n 的函数。eg：假设你的代码复杂度是 f(n),那么用大写字母 O 将其括起来就可以表示复杂度了 — O(f(n)) 特点与常系数无关 例如 O(n) + O(n) = O(2n), 其实 O(n)复杂度和 O(2n)复杂度是一样的，我们通常会忽略常系数对复杂度的影响 多项式级相加的复杂度，会取结果最大的那一个作为最后的结果 O(n^2) + O(n)，明显 n^2 在输入量 n 逐渐变大的情况下，变化会更大，所以我们就说复杂度是 O(n^2)即可 O(1)是一个特殊的复杂度：输入量 n 与消耗的资源无关 O（1）表示的是当前复杂度和输入 n 无关。例如你的代码处理 100 条数据是消耗 3 个时间单元和 1 个空间单元，处理 500 条数据依然还是消耗 3 个时间单元和 1 个空间单元，那么就是输入量与消耗资源无 案例分析O(1)12let num = 0;num += 1; 时间复杂度：O(1)空间复杂度：O(1) O(n)123for (let i = 0; i++; i &lt; n) &#123; console.log(i);&#125; 时间复杂度：O(n)空间复杂度：O(1) 单个变量所占的空间永远都是一个常量所以是 O(1) 1234const arr = [];for (let i = 0; i++; i &lt; n) &#123; arr.push(i);&#125; 时间复杂度：O(n)空间复杂度：O(n) 这段代码相当于我们给数组 arr 中添加了 n 个元素，所以占用了 n 个内存单元，因此空间复杂度为 O(n) O(logn)1234let i = 1;while (i &lt;= n) &#123; i *= 2;&#125; 时间复杂度：O(n)空间复杂度：O(1) 这段代码相当于是在计算 2&lt;=n，也就是 x 次之后循环结束那么 x=logn","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"栈 - 基础知识","slug":"栈","date":"2021-05-13T22:50:54.534Z","updated":"2021-05-13T22:50:54.534Z","comments":true,"path":"2021/05/14/栈/","link":"","permalink":"https://blog.lqh.kim/2021/05/14/%E6%A0%88/","excerpt":"","text":"栈 定义一种后进先出的数据结构。 类似于一个麻袋，先装进去的就在袋子的最底部，所以只能先拿出来最上面的 名词解释push： 入栈pop： 出栈top：栈顶JavaScript 中的栈在 js 中是没用栈这种数据结构的，不过我们可以利用数组来模拟。而且在 js 中也是有对应的 push 和 pop 方法的: push: 向数组末尾添加一个元素，返回值是数组的长度pop：移除数组的第一个元素，返回值是移除的元素 什么场景下用栈？ 最直白的讲就是需要后进先出的场景 十进制转二进制我们计算十进制转二进制时，就是不断除以 2，然后取余数然后将最后一位的余数与第一位的余数拼成二进制 这样的后进先出的手法有没有想到栈！ 判断字符串的括号是否有效我们验证括号是否有效其实就是在验证是不是能够凑齐一对完整的闭合括号。 而且我们可以发现一个规律，越靠左的左括号，它对应的右括号就越靠右。反之也就是最后面的左括号，对应的必定是出现的第一个右括号。 所以我们就可以在遇到左括号时就入栈，遇到右括号时就与栈顶的括号就行配对比较，若果符合配对规则则出栈，否则就不符合规则直接判定无效。匹配到最后结如果栈内是空就证明可以完整闭合 函数调用栈等这个可以看浏览器，js 的解释器就是通过调用栈的形式实现的 执行 fun1 时先将 fun1 入栈，然后调用 fun2，入栈；然后调用 fun3 入栈。 fun3 执行完毕出栈fun2 执行完毕出栈fun1 执行完毕出栈程序执行完毕","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"栈 - 基础知识","slug":"测试","date":"2021-05-13T22:50:54.534Z","updated":"2021-05-13T22:50:54.534Z","comments":true,"path":"2021/05/14/测试/","link":"","permalink":"https://blog.lqh.kim/2021/05/14/%E6%B5%8B%E8%AF%95/","excerpt":"测试首页图片是否能正常显示以及文章描述","text":"测试首页图片是否能正常显示以及文章描述","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"虚拟列表","slug":"yuque/虚拟列表","date":"2021-05-13T06:31:55.000Z","updated":"2021-05-13T22:51:19.542Z","comments":true,"path":"2021/05/13/yuque/虚拟列表/","link":"","permalink":"https://blog.lqh.kim/2021/05/13/yuque/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/","excerpt":"","text":"首先需要一个能够模拟出滚动区的页面结构按照虚拟列表的方式，计算出来渲染区每次可以渲染出来的总数，但是渲染去并不会被撑开，比如渲染区只能渲染 10 条，俺正常来说渲染区是没滚动条的，那就无法进行滚动，所以我们接下来需要将完整数据的渲染区滚动条给模拟出来​ useRef 的作用我们在函数组件中这样去定义一个变量时，会发生一个问题： 就是每次渲染之后，这个变量都会重新被定义，也就是每次渲染之后都会重新变成初始值 0那么我们应该怎么样去保持这个值在整个生命周期里都是不变的呢，有两个方法： useState useRef 第一种方法是比较常见的，但是有一个弊端就是每次更新值的时候都会重新触发渲染，所以对于那些我们只是想记录一个值的变量来说不是好的解决方案，useRef 就是一个可以实现跨生命周期保持不变的一个对象。","categories":[],"tags":[]},{"title":"大纲","slug":"yuque/大纲","date":"2021-05-10T23:07:09.000Z","updated":"2021-05-13T22:51:19.546Z","comments":true,"path":"2021/05/11/yuque/大纲/","link":"","permalink":"https://blog.lqh.kim/2021/05/11/yuque/%E5%A4%A7%E7%BA%B2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"二、设计原则","slug":"yuque/二、设计原则","date":"2021-04-08T03:14:37.000Z","updated":"2021-05-13T22:51:19.586Z","comments":true,"path":"2021/04/08/yuque/二、设计原则/","link":"","permalink":"https://blog.lqh.kim/2021/04/08/yuque/%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","excerpt":"","text":"何为设计？ 即按照哪一种思路或者标准来实现功能 功能相同，可以有不同的设计方案来实现 伴随着需求增加，设计的作用才能体现出来 《UNIX/LINUX 设计哲学》一书中提出了几个设计的准则： 准则 1： 小即是美 准则 2： 让每个程序只做好一件事 准则 3： 快速建立原型 准则 4： 舍弃高效率而取可移植性 准则 5： 采用纯文本来存储数据（可读性） 准则 6： 充分利用软件的杠杆效应（复用性） 准则 7： 使用 shell 脚本来提高杠杆效应和可移植性 准则 8： 避免强制性的用户界面 准则 9： 让每个程序都成为过滤器 几个小准则： 允许用户定制环境 尽量使操作系统内核小而轻量化 使用小写字母和简写 沉默是金 各部分之和大于整体 寻求 90%的解决方案（100 个人里只需要满足 90 个用户的需求 - 28 准则） S O L I D 五大设计原则** S 单一职责 O 开放封闭（对扩展开放，对修改封闭） L 李氏置换 I 接口独立 D 依赖导致 单一职责原则 一个函数只负责一件事 专职专用 开放封闭 对扩展开放，对修改封闭 增加需求时，应该是增加代码，而不是去修改已有的代码 李氏置换 子类能覆盖父类 父类能出现的地方子类就能出现 JS 中使用较少（弱类型 &amp; 继承使用较少） 接口独立 保持接口的单一独立，避免出现“胖接口” JS 中是没有接口接口的，使用较少 类似于单一职责，但是更关注接口 依赖倒置 面向接口编程，只关注接口而不关注具体类的实现 JS 中使用较少 23 种设计模式","categories":[],"tags":[]},{"title":"一、面向对象","slug":"yuque/一、面向对象","date":"2021-04-08T03:13:17.000Z","updated":"2021-05-13T22:51:19.822Z","comments":true,"path":"2021/04/08/yuque/一、面向对象/","link":"","permalink":"https://blog.lqh.kim/2021/04/08/yuque/%E4%B8%80%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"什么是面向对象？概念： 类： 抽象出来的一个具有一些通用特征的模板 实例： 通过类构造出来的的具体对象 三要素： 继承：子类继承父类 封装：数据的权限和保密 多态：统一接口的不同实现 继承子类继承父类。 在 js 中实现继承的方式是通过原型链的方式实现的，大概有六种，详情可以看这里https://www.notion.so/callmew/JavaScript-c6f0e1fea7d845a298dbb8f773fd1d66 封装 public 完成开发 protected 对子类开放 private 对自己开放 TS Playground - An online editor for exploring TypeScript and JavaScript 1234567891011121314151617181920212223242526272829class People &#123; name; age; protected weight; // 只对子类公开 constructor(name: string, age: number) &#123; this.name = name; this.age = age; this.weight = 120; &#125;&#125;class Student extends People &#123; number; private girlFriend; // 只对自己开放 constructor(name: string, age: number, number: number) &#123; super(name, age); this.number = number; this.girlFriend = &quot;Lily&quot;; &#125; getWeight() &#123; console.log(this.weight); &#125;&#125;const xiaoMing = new Student(&quot;小名&quot;, 18, 20);xiaoMing.getWeight();xiaoMing.girlFriend; // 私有变量，只能在类内部访问，不能在实例中访问 封装总结： 减少耦合，不该外露的不外露 利于数据、接口的权限管理 ES6 目前不支持，一般认为_开头的属性是 private 多态 同一个接口不同的表现 保持子类的开放性和灵活性 面向接口编程 需要和重载进行区分： 重载：允许存在多个同名函数，然后通过不同的参数来进行调用对应的方法 多态：是对父类的方法进行重新定义，定义一个接口，然后在子类中完成不同的功能 为什么要使用面向对象？编程应该： 简单 &amp; 抽象 UML 类图","categories":[],"tags":[]},{"title":"队列","slug":"yuque/队列","date":"2021-02-06T06:32:18.000Z","updated":"2021-05-13T22:51:19.870Z","comments":true,"path":"2021/02/06/yuque/队列/","link":"","permalink":"https://blog.lqh.kim/2021/02/06/yuque/%E9%98%9F%E5%88%97/","excerpt":"","text":"具体请移步git 仓库查看 【933】最近的请求次数题目描述这道题可能读起来有点难懂，我们这里先来梳理一下题意：我们配合示例来看，首先输入是两个数组 第一个数组是字符串组成的，这个字符串其实对应的是方法的调用 第二个数组是由数字组成的，这个就是在调用的第一个数组时传入的参数 两个数组两两对应 题解1234567891011121314151617181920212223242526var RecentCounter = function () &#123; // 创建缓存队列 this.q = [];&#125;;/** * @param &#123;number&#125; t * @return &#123;number&#125; */RecentCounter.prototype.ping = function (t) &#123; // 将传入的每一个参数入队 this.q.push(t); // 判断队列的首元素是否在当前参数的值到3000之间[t-3000,t] while (this.q[0] &lt; t - 3000) &#123; // 不在就剔除队列中 this.q.shift(); &#125; // 返回队列的长度 return this.q.length;&#125;;/** * Your RecentCounter object will be instantiated and called as such: * var obj = new RecentCounter() * var param_1 = obj.ping(t) */ 时间复杂度：O(n)空间复杂度：O(1)","categories":[],"tags":[]},{"title":"栈","slug":"yuque/栈","date":"2021-02-02T06:10:34.000Z","updated":"2021-05-13T22:51:19.922Z","comments":true,"path":"2021/02/02/yuque/栈/","link":"","permalink":"https://blog.lqh.kim/2021/02/02/yuque/%E6%A0%88/","excerpt":"","text":"具体请移步git 仓库查看 【20】有效的括号描述 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 提示： ** ** 1 &lt;= s.length &lt;= 10 s 仅由括号 &#39;()[]&#123;&#125;&#39; 组成 链接 题解 首先要明确一点，最后出现的左括号一定是匹配第一次出现的右括号（这就可以从栈的后进先出去匹配遇到右括号时是否能和栈顶的左括号相匹配） 1234567891011121314151617181920212223242526var isValid = function (s) &#123; // 如果字符长度是奇数直接返回false if (s.length % 2 === 1) return false; // 构建map字典 const map = new Map([ [&quot;)&quot;, &quot;(&quot;], [&quot;&#125;&quot;, &quot;&#123;&quot;], [&quot;]&quot;, &quot;[&quot;], ]); // 创建缓存栈 const stack = []; // 循环字符串 for (let val of s) &#123; // 符合左括号规则入栈 if (val === &quot;(&quot; || val === &quot;[&quot; || val === &quot;&#123;&quot;) &#123; stack.push(val); &#125; else &#123; // 判断右括号是否和栈顶的左括号匹配 const top = stack.pop(); // 不匹配直接返回false，匹配循环继续 if (map.get(val) !== top) return false; &#125; &#125; // 字符匹配完毕，判断栈内是否清空 return stack.length === 0;&#125;; 时间复杂度： O(n） ：一个循环解决的 空间复杂度：O(n) ：stack 最大可能就是将 s 字符串的所有字符压入，所以为 O(n) 【144】二叉树的前序遍历 - 迭代描述 给你二叉树的根节点 root ，返回它节点值的 前序_ _遍历。 &gt; 链接 题解 首先明确前序遍历的规则：DLR ，即先找自身（D）节点，然后找左（L）节点，最后找右（R）节点 延伸：中序遍历： LDR后续遍历： LRD 2. 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var preorderTraversal = function (root) &#123; if (!root) return []; const res = []; const stack = []; // 将根节点首先压入栈中 stack.push(root); while (stack.length) &#123; // 取出栈顶元素进行遍历操作,栈顶元素就是根元素即D const d = stack.pop(); res.push(d.val); // 分别取出左右节点,分别压入栈中 // 这里需要注意因为栈的特性是后进先出，所以我们前序遍历要先取出左节点，因为这里左节点要最后入栈 if (d.right) stack.push(d.right); if (d.left) stack.push(d.left); &#125; return res;&#125;; 时间复杂度：O(n)空间复杂度：O(n)","categories":[],"tags":[]},{"title":"数据结构","slug":"yuque/数据结构","date":"2021-02-02T03:35:18.000Z","updated":"2021-05-13T22:51:20.086Z","comments":true,"path":"2021/02/02/yuque/数据结构/","link":"","permalink":"https://blog.lqh.kim/2021/02/02/yuque/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"栈 定义一种后进先出的数据结构。 类似于一个麻袋，先装进去的就在袋子的最底部，所以只能先拿出来最上面的 名词解释push： 入栈pop： 出栈top：栈顶JavaScript 中的栈在 js 中是没用栈这种数据结构的，不过我们可以利用数组来模拟。而且在 js 中也是有对应的 push 和 pop 方法的: push: 向数组末尾添加一个元素，返回值是数组的长度pop：移除数组的第一个元素，返回值是移除的元素 什么场景下用栈？ 最直白的讲就是需要后进先出的场景 十进制转二进制我们计算十进制转二进制时，就是不断除以 2，然后取余数然后将最后一位的余数与第一位的余数拼成二进制 这样的后进先出的手法有没有想到栈！ 判断字符串的括号是否有效我们验证括号是否有效其实就是在验证是不是能够凑齐一对完整的闭合括号。 而且我们可以发现一个规律，越靠左的左括号，它对应的右括号就越靠右。反之也就是最后面的左括号，对应的必定是出现的第一个右括号。 所以我们就可以在遇到左括号时就入栈，遇到右括号时就与栈顶的括号就行配对比较，若果符合配对规则则出栈，否则就不符合规则直接判定无效。匹配到最后结如果栈内是空就证明可以完整闭合 函数调用栈等这个可以看浏览器，js 的解释器就是通过调用栈的形式实现的 执行 fun1 时先将 fun1 入栈，然后调用 fun2，入栈；然后调用 fun3 入栈。 fun3 执行完毕出栈fun2 执行完毕出栈fun1 执行完毕出栈程序执行完毕 队列 定义一种先进先出的数据结构，类似一个管道，这边进那边出 名词解释enqueue: 入队dequeue：出队JavaScript 中模拟队列JavaScript 中没有队列，但是可以使用数组来模拟 push shift: 移除数组中最后一个个元素，返回值是被移除的元素 应用场景js 中的异步任务队列 计算最近请求次数链表线性表是 n 个元素的有限序列，最常用的是链式表达式，通常也叫作线性链表或者链表。**在链表中存储的数据元素也叫作*节点，\\*一个节点存储的就是一条数据记录。每个节点的结构包括两个部分： 具体的数据值 指向下一个节点的指针 在链表的最前面通常有一个头指针用来指向第一个节点。对于链表的最后一个节点，由于在他之后没有下一个节点，因此它的指针是一个空指针。** 单向链表 如上图所示：只能通过上一个节点的指针找到下一个节点，而不能通过下一个节点去找到上一个节点 循环链表 让最后一个元素的指针指向第一个元素，就形成了循环链表 双向链表 给每个元素增加一个指向上一个元素的指针就形成了双向链表双向链表可以通过自身查找到上一个元素，也可以查找到下一个元素 双向循环链表 同样的还可以将双向链表和循环链表相结合，形成双向循环链表 单向链表的增删查增当我们想要在一个链表A节点和B节点的中间增加节点C时，需要进行以下两步： 使 C 节点的 net 等于 A 节点的 next 改变 A 节点的 next 等于 C 节点 第一步和第二步的顺序不能调换，如果先执行第一步的话，那么就没办法获取到指向 B 节点的指针了，除非是新建一个变量提前缓存该指针 12C.next = A.next;A.next = C; 删当我们想要在一个链表中删除B节点时，需要进行以下一步： 使 A 的 next 等于 B 的 next 这里需要注意，A.next = B， 所以我们在处理这一步的时候，完全可以写成 A.next = A.next.next ; 1A.next = A.next.next; 查链表这种数据结构对于查找操作来说是弱项。因为链表的查找只能从第一个节点开始，逐个查找。 通过上面的增删查操作我们可以明显感知到，链表这种数据结构在增、删的操作上是比较方便的，可以在O(1)的时间复杂度内完成，但是查的话就是O(n)的时间复杂度了。但是链表在增删上的优势并不明显，因为我们在增删的时候往往会伴随着查找的动作，比如我们在第五个节点后面添加一个新的节点，就会有这样的过程： 查找到链表中的第 5 个节点 在他后面新增节点 那这么说链表就没什么用了吗？ 当然不是，链表的真正价值在于它存储的数据方式是按照顺序进行关联存储的，如果对于元素个数不确定，并且经常进行增删的数据来说，链表是比较合适的 链表在内存中可以存储在不连续的内存空间内因为链表的顺序关联是通过指针进行关联的所以对于不确定元素个数的数据来说，存储在内存空间中的各个位置，然后通过 next 指针关联是较好的 对于元素个数确定的数据，那么数组就是比较好的选择了 数组在内存中开辟的是一块固定的连续内存空间 集合定义一种无序且唯一的数据结构。 JavaScript 中的集合 set 123456const arr = [1, 1, 2, 3, 4, 5, 6, 7, 5, 7];// 去重const arr2 = [...new Set(arr)];// 判断集合中是否有某元素const set = new Set([1, 2, 3]);set.has(1); 应用场景 去重 求交集 判断某元素是否在集合中 字典定义与集合类似，字典也是一种存储唯一值的数据结构，但它是以键值对的形式来存储的. JavaScript 中的字典 ES6 中的字典，名为 Map 1234567891011121314const map = new Map();// 增map.set(&quot;a&quot;, &quot;123&quot;);map.set(&quot;b&quot;, &quot;456&quot;);// 删map.delete(&quot;a&quot;);map.clear(); // 清空字典// 改map.set(&quot;a&quot;, &quot;233&quot;);// 查map.get(&quot;a&quot;);// 这些操作的时间复杂度都为O(1) 图定义 图是网络结构的抽象模型，是一组由边连接的节点 图可以表示任何二元关系，比如道路、航班 二元关系： 一条边只能连接两个节点 JavaScript 中的图 js 中没有图，但是可以用 Object 和 Array 构建图 图的表示法： 邻接矩阵、邻接表、关联矩阵 操作 深度优先遍历 访问根节点 对根节点的没访问过的相邻节点挨个进行深度优先遍历 广度优先遍历 新建一个队列，将根节点入队 将队头取出并访问 把队头的没访问过的相邻节点入队 重复 2、3、4 步，直到队列为空 堆 堆是一种特殊的完全二叉树 所有的节点都大于等于（最大堆）或者小于等于（最小堆）他的子节点 Javascript 中的堆 js 中通常用数组表示堆 左侧子节点的位置是： 2*index+1 右侧子节点的位置是： 2*index+2 父节点的位置是： （index-1）/ 2 向下取整 堆的应用 高效快速的找到最大或者最小的元素 因为堆是有顺序的，不是最大堆就是最小堆 找到最大或者最小的第 K 个元素 JavaScript 实现最小的堆类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class MinHeap &#123; constructor() &#123; this.heap = []; &#125; // 交换元素 swap(i1, i2) &#123; [this.heap[i2], this.heap[i1]] = [this.heap[i1], this.heap[i2]]; &#125; // 元素上移 shiftUp(index) &#123; // 比较到堆顶元素直接返回 if (index === 0) return; const parentIndex = this.parentIndex(index); // 比较当前节点与父节点的大小 if (this.heap[index] &lt; this.heap[parentIndex]) &#123; this.swap(index, parentIndex); // 递归比较下一个节点与父节点 this.shiftUp(parentIndex); &#125; &#125; // 元素下移 shiftDown(index) &#123; const left = this.leftIndex(index); const right = this.rightIndex(index); // 判断左子节点是否比自己小 if (this.heap[left] &lt; this.heap[index]) &#123; this.swap(left, index); this.shiftDown(left); &#125; // 判断右子节点是否比自己小 if (this.heap[right] &lt; this.heap[index]) &#123; this.swap(right, index); this.shiftDown(right); &#125; &#125; // 插入 insert(n) &#123; this.heap.push(n); // 插入之后需要考虑将该元素上移 this.shiftUp(this.heap.length - 1); &#125; // 删除堆顶 pop() &#123; // 用堆底元素替换堆顶元素 this.heap[0] = this.heap.pop(); // 将更新后的堆顶元素向下移动 this.shiftDown(0); &#125; // 获取堆顶元素 peek() &#123; return this.heap[0]; &#125; // 获取堆的大小 size() &#123; return this.heap.length; &#125; // 获取父节点的下标 parentIndex(index) &#123; return Math.floor((index - 1) / 2); &#125; // 获取左侧子节点下标 leftIndex(index) &#123; return index * 2 + 1; &#125; // 获取右侧子节点下标 rightIndex(index) &#123; return index * 2 + 2; &#125;&#125;// 测试是否可以正常运行const h = new MinHeap();h.insert(3);h.insert(2);h.insert(1);h.insert(0);h.pop();console.log(h.heap);","categories":[],"tags":[]},{"title":"时间复杂度&空间复杂度","slug":"yuque/时间复杂度&空间复杂度","date":"2021-02-01T23:09:37.000Z","updated":"2021-05-13T22:51:20.126Z","comments":true,"path":"2021/02/02/yuque/时间复杂度&空间复杂度/","link":"","permalink":"https://blog.lqh.kim/2021/02/02/yuque/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"","text":"复杂度的作用一般我们会从两个维度去考虑一段代码的质量： 时间复杂度 空间复杂度 顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。 所以时间复杂度和空间复杂度一般是用来衡量一段代码的优劣的。 那么我们应该怎么来定义复杂度呢？ 复杂度的定义与特点定义 复杂度是一个关于输入量 n 的函数。eg：假设你的代码复杂度是 f(n),那么用大写字母 O 将其括起来就可以表示复杂度了 — O(f(n)) 特点与常系数无关 例如 O(n) + O(n) = O(2n), 其实 O(n)复杂度和 O(2n)复杂度是一样的，我们通常会忽略常系数对复杂度的影响 多项式级相加的复杂度，会取结果最大的那一个作为最后的结果 O(n^2) + O(n)，明显 n^2 在输入量 n 逐渐变大的情况下，变化会更大，所以我们就说复杂度是 O(n^2)即可 O(1)是一个特殊的复杂度：输入量 n 与消耗的资源无关 O（1）表示的是当前复杂度和输入 n 无关。例如你的代码处理 100 条数据是消耗 3 个时间单元和 1 个空间单元，处理 500 条数据依然还是消耗 3 个时间单元和 1 个空间单元，那么就是输入量与消耗资源无 案例分析O(1)12let num = 0;num += 1; 时间复杂度：O(1)空间复杂度：O(1) O(n)123for (let i = 0; i++; i &lt; n) &#123; console.log(i);&#125; 时间复杂度：O(n)空间复杂度：O(1) 单个变量所占的空间永远都是一个常量所以是 O(1) 1234const arr = [];for (let i = 0; i++; i &lt; n) &#123; arr.push(i);&#125; 时间复杂度：O(n)空间复杂度：O(n) 这段代码相当于我们给数组 arr 中添加了 n 个元素，所以占用了 n 个内存单元，因此空间复杂度为 O(n) O(logn)1234let i = 1;while (i &lt;= n) &#123; i *= 2;&#125; 时间复杂度：O(n)空间复杂度：O(1) 这段代码相当于是在计算 2&lt;=n，也就是 x 次之后循环结束那么 x=logn","categories":[],"tags":[]},{"title":"[红宝书质检厂]看看读完红宝书的你，到底学废了吗？","slug":"yuque/[红宝书质检厂]看看读完红宝书的你，到底学废了吗？","date":"2021-01-25T23:20:11.000Z","updated":"2021-05-13T22:51:20.142Z","comments":true,"path":"2021/01/26/yuque/[红宝书质检厂]看看读完红宝书的你，到底学废了吗？/","link":"","permalink":"https://blog.lqh.kim/2021/01/26/yuque/[%E7%BA%A2%E5%AE%9D%E4%B9%A6%E8%B4%A8%E6%A3%80%E5%8E%82]%E7%9C%8B%E7%9C%8B%E8%AF%BB%E5%AE%8C%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%9A%84%E4%BD%A0%EF%BC%8C%E5%88%B0%E5%BA%95%E5%AD%A6%E5%BA%9F%E4%BA%86%E5%90%97%EF%BC%9F/","excerpt":"","text":"对于技术类的书籍，我认为我们在阅读的时候应该是带着问题又目的性的阅读，当我们读完一个章节或者一部分之后就回头问问自己是否了解或者掌握了这其中的知识点，以问题的形式来回顾和检查自己的理解程度。 本篇文章我就以这种角度来带大家检查一下自己阅读红宝书的质量到底如何 第一章你眼里的 JavaScript 是什么？在前端的远古时代（95 年之前）为了验证一个输入字段是否有效，就需要与服务器进行一次往返的通信，极其浪费时间。而 JavaScript 当时的出现就是为了解决这种前端的数据验证问题，但是随着自身的发展，现在 Js 能做的事情已经越来越多了，也就成为了现在我们所认识的主流编程语言。完整的 JavaScript 由 3 部分组成： ECMAScript DOM BOM 那你能分别介绍一下这三部分吗？ECMAScript：由国际标准化组织制定的一种标准，定义了这门语言的一些词法、语法和类型等一系列的标准DOM：全称是 Document Object Model，也就是文档对象模型，是用来让我们对 HTML 文档中的元素结构进行增删改查的BOM：Brower Object Model，浏览器对象模型，实现了一系列的浏览器 API，以方便我们去操作浏览器相关的操作，常用的有 window 对象，navigator 对象，XMLRequest，操作 Cookie 的等等 思维导图 第二章能说一下 script 标签的 defer 和 async 属性吗？上面你提到的 load 和 DOMContentLoad 事件能解释一下吗？思维导图","categories":[],"tags":[]},{"title":"标签语义化","slug":"yuque/标签语义化","date":"2020-12-29T23:25:07.000Z","updated":"2021-05-13T22:51:20.146Z","comments":true,"path":"2020/12/30/yuque/标签语义化/","link":"","permalink":"https://blog.lqh.kim/2020/12/30/yuque/%E6%A0%87%E7%AD%BE%E8%AF%AD%E4%B9%89%E5%8C%96/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"动画与绘制","slug":"yuque/动画与绘制","date":"2020-12-27T13:02:11.000Z","updated":"2021-05-13T22:51:20.194Z","comments":true,"path":"2020/12/27/yuque/动画与绘制/","link":"","permalink":"https://blog.lqh.kim/2020/12/27/yuque/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%88%B6/","excerpt":"","text":"Animation @keyframes 定义 可以使用百分比表示进度 也可以使用 from、to 1234567@keyframes mykf&#123; form&#123; background: red &#125; to&#123; background: blue &#125; animation：使用 animation-name 动画名称 animation-duration 动画的时长 animation-timing-function 动画的时间曲线 贝塞尔曲线：https://cubic-bezier.com/#.17,.67,.83,.67 一次贝塞尔曲线（直线） 二次贝塞尔曲线 三次贝塞尔曲线（常用） animation-delay 动画开始前的延迟 animation-iteration-count 动画的播放次数 animation-rirection 动画的方向 transition transition-property 需要变换的属性 transition-duration 变换的时长 transition-timing-function 时间曲线 transition-delay 延迟 颜色在自然界中我们看到的光都是混色光，极少有纯色光（激光笔可以达到纯色光）正常人类看到的光的波长在 400~760nm。 人眼内有三种视锥细胞，这三种细胞分别用来识别三种颜色：红绿蓝（RGB） HSL 和 HSV Hue： 色相（将颜色分成一个色盘，然后我们通过制定一个色盘中的角度，来决定他的颜色） Ssturation：纯度 Lightness： 亮度（到达 100 是白色，到达 0 是黑色，中间的才是纯色） Value：明度 （value 到达 100%时，就相当于是一个纯色） （HSL： W3C 采用的标准） 绘制几何图形 border box-shadow border-radius 文字 font text-decoration 位图 background-image","categories":[],"tags":[]},{"title":"CSS排版","slug":"yuque/CSS排版","date":"2020-12-20T23:28:21.000Z","updated":"2021-05-13T22:51:20.310Z","comments":true,"path":"2020/12/21/yuque/CSS排版/","link":"","permalink":"https://blog.lqh.kim/2020/12/21/yuque/CSS%E6%8E%92%E7%89%88/","excerpt":"","text":"盒（Box) HTML 代码中可以书写开始标签，结束标签，和自封闭标签一对起止标签，表示一个元素DOM 树中存储的是元素和其他类型的节点（Node)CSS 选择器选中的是元素CSS 选择器选中的元素，在排版时可能产生多个盒排版和渲染的基本单位是盒 盒模型盒模型分为两种： 可以通过 box-sizing 来设置不同的盒模型box-sizing 默认值是 content-box 怪异盒模型（border-box)： box-width = content + padding + border 标准盒模型 (content-box)： box-width = content 怪异盒模型在增加 padding 和 border 的宽度时，会保持原有的 box-width 而去对应减少 content 的 width 的所占空间 正常流正常流的排版： 收集盒和文字进行计算 计算盒和文字在行中的排布 计算行的排布 IFC：行内级格式化上下文（从左到右排列）BFC：块级格式化上下（从上到下排列） 正常流的行级排布（IFC）Baseline下图中黄色的线就是基线，文字是基于基线来对齐的。 Text底层软件定义的文字 origin：基线的原点 advance：排版中文字占据的空间 bearingX：文字之间的间距 yMin：文字基线距离文字底部的距离 行模型 base-line：基线，文字默认对齐的线 text-top、text-bottom：文字的上下边缘线 只要字体的大小不变，text-top 和 text-bottom 就是不变的如果用了多种字体混排的话，那么这个文字的上下边缘就是有 font-size 最大的字体决定的。我们基本可以认为这两条线是固定不变的 line-top、line-bottom：行的上下边缘线 这两条线的产生是因为行高大于文字的高度 文字和盒混排时产生的问题当一个行内盒是按照 text-bottom 来对齐的话，它就会撑开该行的高度，造成偏移的情况。 当没有蓝色的行内盒的时候，只有文字那么该盒是只有 text-top 和 text-bottom 的高度时，文字看起来排版就比较正常，但是当蓝色盒子出现的时候撑开了 line-top，导致该行整体高度都被撑开了，那么文字相较之前的就会看起来偏下了许多。 Eg： 123456789101112&lt;div style=&quot;font-size: 50px; line-height: 100px; background-color: bisque&quot;&gt; &lt;span&gt;Hello good 国&lt;/span&gt; &lt;div style=&quot; display: inline-block; line-height: 70px; width: 100px; height: 150px; background-color: cadetblue; &quot; &gt;&lt;/div&gt;&lt;/div&gt; 效果如下：文字正常情况按照基线对齐：当我们添加一个行内盒的时候：蓝色的线是 line-top，就被撑开了（该行的整体高度被撑开）。绿色的线是 text-top，行内盒不会影响 text 的边缘线高度。当我们在行内盒添加上一个文字时：这种情况就相当于，当一个行内盒中有了文字之后，那么对齐的时候就会按照文字的基线去对齐当我们呢在行内盒再添加一个换行和文字时：会按照最下面文字的基线去进行对齐上面的演示代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;div style=&quot;font-size: 50px; line-height: 100px; background-color: bisque&quot;&gt; &lt;!-- line-top --&gt; &lt;div style=&quot; vertical-align: top; width: 1px; height: 1px; display: inline-block; &quot; &gt; &lt;div style=&quot;width: 100vw; height: 1px; background-color: blue&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- text-top --&gt; &lt;div style=&quot; vertical-align: text-top; width: 1px; height: 1px; display: inline-block; &quot; &gt; &lt;div style=&quot;width: 100vw; height: 1px; background-color: green&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 基线 --&gt; &lt;div style=&quot; vertical-align: baseline; width: 1px; height: 1px; display: inline-block; &quot; &gt; &lt;div style=&quot;width: 100vw; height: 1px; background-color: red&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- text-bottom --&gt; &lt;div style=&quot; vertical-align: text-bottom; width: 1px; height: 1px; display: inline-block; &quot; &gt; &lt;div style=&quot;width: 100vw; height: 1px; background-color: green&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- line-bottom --&gt; &lt;div style=&quot; vertical-align: bottom; width: 1px; height: 1px; display: inline-block; &quot; &gt; &lt;div style=&quot;width: 100vw; height: 1px; background-color: blue&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;span&gt;Hello good 国&lt;/span&gt; &lt;div style=&quot; display: inline-block; line-height: 70px; width: 100px; height: 150px; background-color: cadetblue; &quot; &gt; M N &lt;/div&gt;&lt;/div&gt; 正常流的块级排布（BFC)float 和 clearfloat： 严格来说是已经脱离文档流的，他在排列时可以完成图文环绕排的形式。 多个 float 元素会依次排列，不会占据对方的空间 float 会造成重排的问题 clear：与其说是清除浮动，不如说是在某个方向上找个干净的地方去完成浮动的排列 与上面同样的代码，只要给第二个 float 的红色 div 设置 clear: right 就可以实现下面这种效果 所以说 clear 更像是在右面找了一个干净的地方进行浮动排列 margin 折叠这种现象只会发生在正常流中，在正常流中只有 BFC 才会有！ 上下两个块级元素都有 margin 的情况下，在排列的时候会选取一个 margin 的最大值作为其最终排版的结果 =====&gt; BFC 合并 Block Container： 里面有 BFC 能容纳正常流的盒，里面就有 BFC BLock-level Box： 外面有 BFC 的 Block Box = Block container + Block-level Box：里外都有 BFC 的","categories":[],"tags":[]},{"title":"Pseudo-element: 伪元素","slug":"yuque/Pseudo-element! 伪元素","date":"2020-12-20T11:07:45.000Z","updated":"2021-05-13T22:51:20.326Z","comments":true,"path":"2020/12/20/yuque/Pseudo-element! 伪元素/","link":"","permalink":"https://blog.lqh.kim/2020/12/20/yuque/Pseudo-element!%20%E4%BC%AA%E5%85%83%E7%B4%A0/","excerpt":"","text":"::before ::after ::first-line 选中第一行 ::first-letter 选中第一个字母 1234&lt;div&gt; &lt;::before/&gt; content content content content content content content content &lt;::after/&gt;&lt;/div&gt; 1234&lt;div&gt; &lt;::first-letter&gt;c&lt;/::first-letter&gt;ontent content content content content content content content&lt;/div&gt; first-line 和 first-letter 支持的 css 属性设置：","categories":[],"tags":[]},{"title":"Calculating specificity：计算优先级","slug":"yuque/Calculating specificity：计算优先级","date":"2020-12-20T00:34:25.000Z","updated":"2021-05-13T22:51:20.358Z","comments":true,"path":"2020/12/20/yuque/Calculating specificity：计算优先级/","link":"","permalink":"https://blog.lqh.kim/2020/12/20/yuque/Calculating%20specificity%EF%BC%9A%E8%AE%A1%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7/","excerpt":"","text":"计算方法为给定元素计算它的优先级，遵循以下原则： 计算 ID 选择器的值 A 计算类选择、属性选择器、伪类选择器的值 B 计算标签选择器和伪元素选择器的值 C 忽略通用选择器* :is()、:not()、:has(),这三个伪类选择器的计算值将被其中优先级最高的值所代替 eg::is(#id) [1,0,0] 伪类的优先级值 B 被 id 的高优先值所代替 类似的, :nth-child()、：nth-last-child()的计算值是一个伪类的值加上参数的计算值之和。 eg::nth-child(.item) [0,2,0] 伪类的值加上参数.item 的值 :where() 伪类的计算值为 0 eg:.item:where(em,#foo) [0,1,0] where 伪类的值为 0 【A，B，C】 /_ a=0 b=0 c=0 /LI / a=0 b=0 c=1 /UL LI / a=0 b=0 c=2 /UL OL+LI / a=0 b=0 c=3 _/H1 + [REL=up] / a=0 b=1 c=1 /UL OL LI.red / a=0 b=1 c=3 /LI.red.level / a=0 b=2 c=1 /#x34y / a=1 b=0 c=0 /#s12:not(FOO) / a=1 b=0 c=1 /.foo :is(.bar, #baz) / a=1 b=1 c=0 */ 官方文档是按照 3 位来计算优先级的，就是上图中的：[A, B, C]还有一种计算方式是按照四位来计算的，最高位表示是否为行内样式：[ L, A, B, C] 练习1234div#a.b .c[id=x] [0, 1, 3, 1]#a:not(#b) [0, 2, 0, 0]*.a [0, 0, 1, 0]div.a [0, 0, 1, 1]","categories":[],"tags":[]},{"title":"Pseudo-Class：伪类","slug":"yuque/Pseudo-Class：伪类","date":"2020-12-20T00:33:41.000Z","updated":"2021-05-13T22:51:20.406Z","comments":true,"path":"2020/12/20/yuque/Pseudo-Class：伪类/","link":"","permalink":"https://blog.lqh.kim/2020/12/20/yuque/Pseudo-Class%EF%BC%9A%E4%BC%AA%E7%B1%BB/","excerpt":"","text":"链接/行为之前这些伪类的实现都是为了超链接设计的，但是现在有很多伪类都可以用到其他元素上了。 :any-link 任何超链接 :link 没有访问过的超链接 :visited 已经访问过的超链接 any-link 可以看做是 link 和 visited 的结合Tips：一旦使用了 link 或者 visited 伪类之后，就没有办法去修改除了颜色以外的 css 属性了。这样做是为了浏览器安全考虑的。因为一旦你更改了像 visited 超链接的大小的时候，就可以让别人明显感受到你访问过哪些网站，这对于用户来说是不太容易接受的，就像泄漏了隐私一样，也不符合浏览器安全的相关策略。 :hover :active :focus :target 树结构 :empty :nth-child() 从前让后数 :nth-last-child() 从后往前数 :first-child :last-child :only-child 逻辑型 :not 伪类 :where :has 在 css 书写过程中，我们不应该写过于复杂的选择器，这样一是对性能不好，二是可能自己 HTML 结构设计的有问题。","categories":[],"tags":[]},{"title":"Selector: 选择器","slug":"yuque/Selector! 选择器","date":"2020-12-20T00:28:48.000Z","updated":"2021-05-13T22:51:20.418Z","comments":true,"path":"2020/12/20/yuque/Selector! 选择器/","link":"","permalink":"https://blog.lqh.kim/2020/12/20/yuque/Selector!%20%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"选择器简单选择器 - div、svg、a .class #id [attr=value] :hover ::before 复合选择器 &lt;简单选择器&gt;&lt;简单选择器&gt;&lt;简单选择器&gt; 或者 div 必须写在最前面 复杂选择器 &lt;复合选择器&gt;&lt;复合选择器&gt; &lt;复合选择器&gt;”&gt;”&lt;复合选择器&gt; &lt;复合选择器&gt;”~”&lt;复合选择器&gt; &lt;复合选择器&gt;”+”&lt;复合选择器&gt; &lt;复合选择器&gt;”||”&lt;复合选择器&gt;","categories":[],"tags":[]},{"title":"翻译记录","slug":"yuque/翻译记录","date":"2020-12-14T23:42:53.000Z","updated":"2021-05-13T22:51:20.442Z","comments":true,"path":"2020/12/15/yuque/翻译记录/","link":"","permalink":"https://blog.lqh.kim/2020/12/15/yuque/%E7%BF%BB%E8%AF%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Selectors Level 4Selector syntax(选择器语法）一个选择器是由一个或者多个简单选择器序列组合而成的，他们通过连接符（Combinators）分割开。并且在一个选择器中的最后一个简单选择器的末尾可以添加一个伪元素。 简单选择器序列（sequences of simple selectors)：由一连串没有使用连接符（Combinators）分割开来的简单选择器组合而成。通常是由标签选择器（h1、div）和通用选择器（*）作为开头。在简单选择器序列中不允许其他的标签选择器或者是通用选择器。 简单选择器（simple selectors）： 标签选择器(h1) 通用选择器(*) 属性选择器（[]) 类选择器(.) id 选择器(#) 伪类选择器（::) 连接符（Combinators）： whitespace 空格 - ~ Calculating a selector’s specificity(计算选择器的优先级）为给定元素计算它的优先级，遵循以下原则： 计算 ID 选择器的值 A 计算类选择、属性选择器、伪类选择器的值 B 计算标签选择器和伪元素选择器的值 C 忽略通用选择器* :is()、:not()、:has(),这三个伪类选择器的计算值将被其中优先级最高的值所代替 eg::is(#id) [1,0,0] 伪类的优先级值 B 被 id 的高优先值所代替 类似的, :nth-child()、：nth-last-child()的计算值是一个伪类的值加上参数的计算值之和。 eg::nth-child(.item) [0,2,0] 伪类的值加上参数.item 的值 :where() 伪类的计算值为 0 eg:.item:where(em,#foo) [0,1,0] where 伪类的值为 0 【A，B，C】 /_ a=0 b=0 c=0 /LI / a=0 b=0 c=1 /UL LI / a=0 b=0 c=2 _/ UL OL+LI /_ a=0 b=0 c=3 _/ H1 + [REL=up] / a=0 b=1 c=1 */ UL OL LI.red /_ a=0 b=1 c=3 _/ LI.red.level /_ a=0 b=2 c=1 _/ #x34y /_ a=1 b=0 c=0 _/ #s12:not(FOO) /_ a=1 b=0 c=1 _/ .foo :is(.bar, #baz) /_ a=1 b=1 c=0 _/ Grammar","categories":[],"tags":[]},{"title":"CSS结构","slug":"yuque/CSS结构","date":"2020-12-13T23:30:32.000Z","updated":"2021-05-13T22:51:20.486Z","comments":true,"path":"2020/12/14/yuque/CSS结构/","link":"","permalink":"https://blog.lqh.kim/2020/12/14/yuque/CSS%E7%BB%93%E6%9E%84/","excerpt":"","text":"因为找不到一个明确的语法线索，所以我们这里根据 2.1 版本的语法来进行学习。现版本 css 多了很多 css3 的语法，但是不影响我们理解他的语法结构。 CSS2.1 语法 css2.1Grammar 中文对照版 总体结构一个样式文件从上到下的顺序结构： @charset @charset &#39;UTF-8&#39;; 声明 css 文件的字符编码标准。 必须在样式表的第一行声明 如果有多个@charset 声明，那么只有第一个会生效 无法在 HTML 的 style 标签里使用该 at-rule 规则 Tip:在样式表中声明字符编码有很多种方式，浏览器会按照以下顺序去尝试确定文件的编码方式（只要找到一种就会停止并得出结果）： 文件开头的 Unicode byte-order 字符值 由 Content-type 确定：HTTP 协议中的 charset 属性给出的值或用于提供样式表的协议中的等效值 CSS @rule 规则：@charset 假设文档上是 UTF-8 的格式 @import rules （这部分是我们日常最常用到的部分） @media @page rule CSS 规则的结构1234div /* selector */ &#123; /* key */ background-color: /* value */ red;&#125; 由上面的 css 代码可以明确 css 规则的结构分为以下两个部分： Selector（选择器） Declare（声明） key value 爬取 w3c 的 css 规则123456789JSON.stringify( Array.prototype.slice .call(document.querySelector(&quot;#container&quot;).children) .filter((e) =&gt; e.getAttribute(&quot;data-tag&quot;).match(/css/)) .map((e) =&gt; (&#123; name: e.children[1].children[0].innerText, url: e.children[1].children[0].href, &#125;))); 思维导图","categories":[],"tags":[]},{"title":"链表篇","slug":"yuque/链表篇","date":"2020-12-10T06:10:05.000Z","updated":"2021-05-13T22:51:20.542Z","comments":true,"path":"2020/12/10/yuque/链表篇/","link":"","permalink":"https://blog.lqh.kim/2020/12/10/yuque/%E9%93%BE%E8%A1%A8%E7%AF%87/","excerpt":"","text":"【206】反转链表描述 反转一个单链表。 示例: &gt; 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 题解这是个经典的链表问题，其实这个问题的关键就在于要提前保存下一个节点的值。因为你在让当前节点指向上一个节点的过程中，就会把当前节点的 next 指向改变，如果不提前保存当前节点的 next 值的话，就会找不到原有的当前节点的 next 值。 迭代大法 时间复杂度：O(n) 空间复杂度：O(1) 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */const reverList = (head) =&gt; &#123; let cur = head; let prev = null; let tmp; while (cur) &#123; // 记录当前节点的下一个节点 tmp = cur.next; // 改变当前节点的next指针指向 cur.next = prev; // 更新上一个节点的值 prev = cur; // 更新当前节点 cur = tmp; &#125; return prev;&#125;; 递归方法 时间复杂度：O(n) 空间复杂度：O(1) 1234567891011const reverList = (head) =&gt; &#123; const rever = (prev, cur) =&gt; &#123; // 严谨性判断，当cur为空时链表翻转结束 if (!cur) return prev; // 提前保存上一个节点的值 const tmp = cur.next; cur.next = prev; return rever(cur, tmp); &#125;; return rever(null, head);&#125;; 【237】删除链表中的节点描述 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。 现有一个链表 – head = [4,5,1,9]，它可以表示为:&gt; &gt; &gt; 链接 题解这道题的总体思路就是狸猫换太子。 单向链表我们无法获取到上一项的值，去改变上一项的 next 指向 所以我们换种思路，将传入的这个需要删除的节点直接替换成下一个节点，具体替换步骤也是分为两步： 替换 val 值 替换 next 节点 1234567891011121314151617/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; node * @return &#123;void&#125; Do not return anything, modify node in-place instead. */var deleteNode = function (node) &#123; // 将需要删除的当前节点的值替换为下一个节点的值 node.val = node.next.val; // 将需要删的节点next指向下一个节点的next node.next = node.next.next;&#125;; 时间复杂度：O(1)空间复杂度：O(1) 【2】两数相加描述 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2： 输入：l1 = [0], l2 = [0] 输出：[0] 示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 链接：https://leetcode-cn.com/problems/add-two-numbers 题解1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function (l1, l2) &#123; // 创建一个需要返回的新链表 const l3 = new ListNode(); // 保存每个链表的节点指针 let p1 = l1; let p2 = l2; let p3 = l3; // 创建变量来存储进位 let carry = 0; // 遍历 p1 和 p2 每个节点的val值进行相加 // 这里需要注意： 因为p1和p2可能长度不同，所以当其中一个有值时都需要相加，没有值的那个用0代替 while (p1 || p2) &#123; const v1 = p1 ? p1.val : 0; const v2 = p2 ? p2.val : 0; // 计算和，要加上前一个数字相加的进位 const sum = v1 + v2 + carry; // 计算进位，这里需要注意要将进位向下取整 carry = Math.floor(sum / 10); // 将个位数字放入l3链表中 p3.next = new ListNode(sum % 10); // 更新指针 if (p1) p1 = p1.next; if (p2) p2 = p2.next; p3 = p3.next; &#125; // 遍历结束后，判断进位，如果扔有进位放入l3链表中 if (carry) p3.next = new ListNode(carry); // 因为我们在创建新链表时，首位是0，所以我们要从头节点的下一位开始 return l3.next;&#125;;","categories":[],"tags":[]},{"title":"react-hooks的设计动机和工作模式","slug":"yuque/react-hooks的设计动机和工作模式","date":"2020-12-10T00:18:06.000Z","updated":"2021-05-13T22:51:20.586Z","comments":true,"path":"2020/12/10/yuque/react-hooks的设计动机和工作模式/","link":"","permalink":"https://blog.lqh.kim/2020/12/10/yuque/react-hooks%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8A%A8%E6%9C%BA%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"Why为什么要有 hooks 这种方式？ 类组件通过 ES6 的 class 形式，继承 component 形成的组件，在该组件内有一系列的生命周期函数供开发者使用 1234567891011121314151617181920212223242526272829class DemoClass extends React.Component &#123; constructor(props) &#123; super(props); // 初始化类组件的 state state = &#123; text: &quot;&quot;, &#125;; &#125; // 编写生命周期方法 didMount componentDidMount() &#123; // 省略业务逻辑 &#125; // 编写自定义的实例方法 changeText = (newText) =&gt; &#123; // 更新 state this.setState(&#123; text: newText, &#125;); &#125;; // 编写生命周期方法 render render() &#123; return ( &lt;div className=&quot;demoClass&quot;&gt; &lt;p&gt;&#123;this.state.text&#125;&lt;/p&gt; &lt;button onClick=&#123;this.changeText&#125;&gt;点我修改&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 类组件是一个封装好的“重型战舰”，它里面有一系列的生命周期，可以很方便的让我们使用，而我们只需要继承一下 React.component 即可。但是类组件的全，并不一定是好事，大而全的背后必定是昂贵的学习代价。比如说如果我们不了解生命周期的话，那写出来的代码逻辑顺序大概率会变得一团糟。 函数组件函数组件在早期又叫做无状态组件，因为当时没有 hooks 的加持，它没有办法维持自身状态，只能通过父组件传递的 props 来维护一个值。 12345function DemoFun(props) &#123; const &#123; value &#125; = props; return &lt;div&gt;这是一个函数组件&lt;/div&gt;;&#125; 函数组件相较于类组件，肉眼可见的轻便、简单、易于维护。 二者的对比（无关优劣，之谈区别） 类组件需要继承 component 或者 pureComponent，函数组件不需要 类组件中有众多生命周期可以使用，函数组件中没有 类组件中可以通过访问 this 来做一些事情，函数组件中不行 类组件中可以维护自己的状态（state），函数组件中不行（以前不行，现在有了 hooks 就可以了） 函数组件会捕获 render 内部的状态，这是两者之间最大的区别 这里就最后一条进行展开描述，因为这条区别可以说是两者之间的本质区别，react 团队也是意识到了这个问题，才开始拥抱函数组件的。 为什么说函数组件会捕获 render 内部的状态可以说函数组件其实才是更契合 React 设计理念的。从上面这个图中可以看到，其实 react 的组件本身就是一个吃进数据，并且吐出 UI 的一种设计。 函数组件可以将数据处理并且最后映射到 UI 中去。React 数据应该总是和渲染紧密绑定在一起的，而类组件就做不到这一点。 https://codesandbox.io/s/focused-sun-si5pu?file=/src/index.js 虽然 props 本身是不可变的，但 this 却是可变的，this 上的数据是可以被修改的？ 怎么理解 props 本身是不可变的这句话？和 immutable 数据有关系吗？ 为什么类组件中的方法，不 bind this 就无法获取到 this 实例？设计缺陷，而我们都是在代码层面去弥补它设计上的缺陷 为什么需要 React-hooks 呢？（总结） 解决难以理解的 class 模式（this 问题） 函数组件更加符合 react 的设计：UI=f(data) 使组件的状态和逻辑可以进行拆分和维护","categories":[],"tags":[]},{"title":"useCallback","slug":"yuque/useCallback","date":"2020-12-08T03:31:06.000Z","updated":"2021-05-13T22:51:20.590Z","comments":true,"path":"2020/12/08/yuque/useCallback/","link":"","permalink":"https://blog.lqh.kim/2020/12/08/yuque/useCallback/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Toy-Brower","slug":"yuque/Toy-Brower","date":"2020-12-02T13:38:57.000Z","updated":"2021-05-13T22:51:20.630Z","comments":true,"path":"2020/12/02/yuque/Toy-Brower/","link":"","permalink":"https://blog.lqh.kim/2020/12/02/yuque/Toy-Brower/","excerpt":"","text":"为了更加了解浏览器的工作原理，我们来自己用代码搞一个浏览器玩一下。 基本功能描述 功能实现HTTP 实现为了实现浏览器发送网络请求的这一部分，需要梳理一下这部分所需要的功能。 构建请求信息（请求方法、请求行、请求头、请求体） 建立网络连接（net.createServer()） 接收响应结果 处理响应结果 处理响应头 处理响应体 - 利用单独的子类进行 body text 的处理 构造一个发送请求的类 Request 思考：这个类都需要什么东西？ 首先需要一些发送请求时需要配置的基本配置项（options） url 请求路径 port 请求端口 method 请求方法 headers 请求头 body 请求体 其次需要一个发送该请求的方法（send） 该方法返回一个 promise 对象，该对象是请求回来的结果 该方法的功能： 构造请求并发送，发送前需要拼接上请求行、请求头、换行、请求体等信息。 接受请求结果 构造一个解析响应的类 ResponseParse response 返回的结果需要分段来进行处理，所以我们需要一个 ResponseParse 来进行装配 ResponseParse 来分段处理返回的结果，我们用有限状态机来记录完成这一个过程 针对 response body 中的内容采用另一个方法进行分段解析 构造一个类 TrunkedBodyParser response body 针对不通的 Content-type 类型会有不同的处理方法 我们这里针对 chunk 类型进行解析 HTML 解析的实现 接收响应体进行解析 构造状态机进行标签解析 开始标签 &lt; 开始标签的标志 /n/t 空格标志后面是标签属性 结束标签 / 结束标签的标志 &gt; 标签解析结束，开始下一个标签解析 自封闭标签 &lt;/ 自闭和标签的标志 利用 currentToken 变量接受解析结果 text文本类型 statTag开始标签类型 endTag结束标签类型 isSelfCloseTag自闭和标签标志 每次当前标签结束时需要emit(currentToken)来触发当前标签结束的事件 解析标签属性 氛围 attributeName 和 value 两部分进行解析 解析完成之后 emit 对应数据 构建 DOM 树 使用栈进行构造 遇到开始标签就处理好相关属性和元素名入栈 遇到自闭和标签就相当入栈后立即出栈 遇到闭合标签就找到对应标签出栈 CSS 计算 遇到 style 标签时，将 css 规则保存起来，使用 css parser 解析规则 当创建一个元素后应立即计算 css 理论上当我们分析一个元素时，是假设这个元素的 css 规则已经全部收集完毕的 在 computedCss 函数中，我们需要知道所有元素的父元素才可以去判断元素是否与规则匹配 由于我们首先获取的是当前元素，所以我们获得和计算父元素匹配的顺序是由内到外的 选择器也是由内向外匹配排列的 根据选择器的类型和元素属性，计算是否当前的元素匹配 元素匹配完成就应用选择器到元素上，形成 computedSty css 规则具有优先级，我们利用 specificity 特征去进行判断比较 specificity 是一个四元组，越左边权重越重 [0,0,0,] inline、id、class、tag css 规则的 specificity 是根据所包含的简单选择器相加形成的","categories":[],"tags":[]},{"title":"代码效率优化方法论","slug":"yuque/代码效率优化方法论","date":"2020-12-02T01:26:57.000Z","updated":"2021-05-13T22:51:20.666Z","comments":true,"path":"2020/12/02/yuque/代码效率优化方法论/","link":"","permalink":"https://blog.lqh.kim/2020/12/02/yuque/%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%AE%BA/","excerpt":"","text":"如何衡量一段代码的优劣呢？一般我们会从两个维度去考虑一段代码的质量： 时间复杂度 空间复杂度 顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。那么我们应该怎么取舍这两个标准呢？ 提高代码效率的方法我们从上面已经知道了衡量代码效率的方法，那么我们应该怎么着手去优化提高我们代码的效率呢？ 总的策略就是降低代码的时间复杂度和空间复杂度。 但是对于一段代码来说往往时间和空间两个是互斥的，如果我们想要降低时间复杂度，那么无疑就会增加空间复杂度。举一个生活中的 🌰，就像我们平时生活中开车过红绿灯，如果只有这一条路（空间）那么我们就只能在这等着红灯，当车越来越多的时候，就会消耗大家很多时间，但是当我们修建了立交桥之后，就会有更多的选择空间，就会大大减少等待红灯的时间。（图片来自拉钩教育-公瑾老师的重学算法与数据结构一课中）而对我们来说，时间永远都要比空间更加重要，因为时间拿钱买不来，而空间我们起码可以拿钱来进行扩容。空间是廉价的，时间是昂贵的 暴力解法：在没有任何时间和空间的限制下，将目标达成 剔除无效操作：将代码中没有必要的计算、无效的存储删除来优化时间和空间复杂度 时空转换：设计合理的数据结构，将时间向空间转换 增删查：数据的基本操作一般一段算法的实现最常设计的三个操作就是：增、删、查。而我们对一个算法的优化和实现只要围绕这三个为重心去思考展开即可： 分析这段代码对数据进行了那些操作 这些操作中有哪些操作是最消耗性能的，对时间复杂度的损耗是最高的？ 考虑有哪种数据结构可以帮助提高数据操作的使用效率。 以上三点就是构成我们实现代码效率优化的方法论。 查 按照元素索引查找 对于数组这些天生拥有索引的数据结构来说十分简单 对于链表这种，通过指针进行连接的就需要知道前面一个元素 按照元素特征值查找 对于字典类型的数据来说，key 就相当是特征，value 就是值，查找起来非常方便 对于数组和链表来说就需要循环对比每个元素来进行比较值的特征是否符合 增 在复杂数据结构的末尾添加数据 不会影响数据的原始位置 在复杂数据结构的中间添加数据 会影响到数据原始的位置 删 在复杂数据结构的末尾删除 不会影响到原先数据的位置 在复杂数据结构的中间位置进行删除 会影响到之前数据的原始位置","categories":[],"tags":[]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}
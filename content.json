{"meta":{"title":"火热","subtitle":"","description":"你我山巅自相逢，予你与我遇清风","author":"火热","url":"https://blog.lqh.kim","root":"/"},"pages":[{"title":"","date":"2021-06-08T07:55:21.733Z","updated":"2021-06-08T07:55:21.733Z","comments":true,"path":"404.html","permalink":"https://blog.lqh.kim/404.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-06-08T07:55:21.733Z","updated":"2021-06-08T07:55:21.733Z","comments":true,"path":"categories/index.html","permalink":"https://blog.lqh.kim/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-06-08T07:55:21.733Z","updated":"2021-06-08T07:55:21.733Z","comments":true,"path":"tags/index.html","permalink":"https://blog.lqh.kim/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-06-08T07:55:21.733Z","updated":"2021-06-08T07:55:21.733Z","comments":true,"path":"about/index.html","permalink":"https://blog.lqh.kim/about/index.html","excerpt":"","text":"对生活保持热爱对知识保持敬畏"}],"posts":[{"title":"代码效率优化方法论","slug":"代码效率优化方法论","date":"2021-06-08T07:55:21.733Z","updated":"2021-06-08T07:55:21.733Z","comments":true,"path":"2021/06/08/代码效率优化方法论/","link":"","permalink":"https://blog.lqh.kim/2021/06/08/%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%AE%BA/","excerpt":"","text":"代码效率优化方法论如何衡量一段代码的优劣呢？一般我们会从两个维度去考虑一段代码的质量： 时间复杂度 空间复杂度 顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。那么我们应该怎么取舍这两个标准呢？ 提高代码效率的方法我们从上面已经知道了衡量代码效率的方法，那么我们应该怎么着手去优化提高我们代码的效率呢？ 总的策略就是降低代码的时间复杂度和空间复杂度。 但是对于一段代码来说往往时间和空间两个是互斥的，如果我们想要降低时间复杂度，那么无疑就会增加空间复杂度。举一个生活中的 🌰，就像我们平时生活中开车过红绿灯，如果只有这一条路（空间）那么我们就只能在这等着红灯，当车越来越多的时候，就会消耗大家很多时间，但是当我们修建了立交桥之后，就会有更多的选择空间，就会大大减少等待红灯的时间。（图片来自拉钩教育-公瑾老师的重学算法与数据结构一课中）而对我们来说，时间永远都要比空间更加重要，因为时间拿钱买不来，而空间我们起码可以拿钱来进行扩容。空间是廉价的，时间是昂贵的 暴力解法：在没有任何时间和空间的限制下，将目标达成 剔除无效操作：将代码中没有必要的计算、无效的存储删除来优化时间和空间复杂度 时空转换：设计合理的数据结构，将时间向空间转换 增删查：数据的基本操作一般一段算法的实现最常设计的三个操作就是：增、删、查。而我们对一个算法的优化和实现只要围绕这三个为重心去思考展开即可： 分析这段代码对数据进行了那些操作 这些操作中有哪些操作是最消耗性能的，对时间复杂度的损耗是最高的？ 考虑有哪种数据结构可以帮助提高数据操作的使用效率。 以上三点就是构成我们实现代码效率优化的方法论。 查 按照元素索引查找 对于数组这些天生拥有索引的数据结构来说十分简单 对于链表这种，通过指针进行连接的就需要知道前面一个元素 按照元素特征值查找 对于字典类型的数据来说，key 就相当是特征，value 就是值，查找起来非常方便 对于数组和链表来说就需要循环对比每个元素来进行比较值的特征是否符合 增 在复杂数据结构的末尾添加数据 不会影响数据的原始位置 在复杂数据结构的中间添加数据 会影响到数据原始的位置 删 在复杂数据结构的末尾删除 不会影响到原先数据的位置 在复杂数据结构的中间位置进行删除 会影响到之前数据的原始位置","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"时间复杂度&空间复杂度","slug":"时间复杂度&空间复杂度","date":"2021-06-08T07:55:21.733Z","updated":"2021-06-08T07:55:21.733Z","comments":true,"path":"2021/06/08/时间复杂度&空间复杂度/","link":"","permalink":"https://blog.lqh.kim/2021/06/08/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"","text":"时间复杂度&amp;空间复杂度复杂度的作用一般我们会从两个维度去考虑一段代码的质量： 时间复杂度 空间复杂度 顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。 所以时间复杂度和空间复杂度一般是用来衡量一段代码的优劣的。 那么我们应该怎么来定义复杂度呢？ 复杂度的定义与特点定义 复杂度是一个关于输入量 n 的函数。eg：假设你的代码复杂度是 f(n),那么用大写字母 O 将其括起来就可以表示复杂度了 — O(f(n)) 特点与常系数无关 例如 O(n) + O(n) = O(2n), 其实 O(n)复杂度和 O(2n)复杂度是一样的，我们通常会忽略常系数对复杂度的影响 多项式级相加的复杂度，会取结果最大的那一个作为最后的结果 O(n^2) + O(n)，明显 n^2 在输入量 n 逐渐变大的情况下，变化会更大，所以我们就说复杂度是 O(n^2)即可 O(1)是一个特殊的复杂度：输入量 n 与消耗的资源无关 O（1）表示的是当前复杂度和输入 n 无关。例如你的代码处理 100 条数据是消耗 3 个时间单元和 1 个空间单元，处理 500 条数据依然还是消耗 3 个时间单元和 1 个空间单元，那么就是输入量与消耗资源无 案例分析O(1)12let num = 0;num += 1; 时间复杂度：O(1)空间复杂度：O(1) O(n)123for (let i = 0; i++; i &lt; n) &#123; console.log(i);&#125; 时间复杂度：O(n)空间复杂度：O(1) 单个变量所占的空间永远都是一个常量所以是 O(1) 1234const arr = [];for (let i = 0; i++; i &lt; n) &#123; arr.push(i);&#125; 时间复杂度：O(n)空间复杂度：O(n) 这段代码相当于我们给数组 arr 中添加了 n 个元素，所以占用了 n 个内存单元，因此空间复杂度为 O(n) O(logn)1234let i = 1;while (i &lt;= n) &#123; i *= 2;&#125; 时间复杂度：O(n)空间复杂度：O(1) 这段代码相当于是在计算 2&lt;=n，也就是 x 次之后循环结束那么 x=logn","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"栈 - 基础知识","slug":"栈","date":"2021-06-08T07:55:21.733Z","updated":"2021-06-08T07:55:21.733Z","comments":true,"path":"2021/06/08/栈/","link":"","permalink":"https://blog.lqh.kim/2021/06/08/%E6%A0%88/","excerpt":"","text":"栈 定义一种后进先出的数据结构。 类似于一个麻袋，先装进去的就在袋子的最底部，所以只能先拿出来最上面的 名词解释push： 入栈pop： 出栈top：栈顶JavaScript 中的栈在 js 中是没用栈这种数据结构的，不过我们可以利用数组来模拟。而且在 js 中也是有对应的 push 和 pop 方法的: push: 向数组末尾添加一个元素，返回值是数组的长度pop：移除数组的第一个元素，返回值是移除的元素 什么场景下用栈？ 最直白的讲就是需要后进先出的场景 十进制转二进制我们计算十进制转二进制时，就是不断除以 2，然后取余数然后将最后一位的余数与第一位的余数拼成二进制 这样的后进先出的手法有没有想到栈！ 判断字符串的括号是否有效我们验证括号是否有效其实就是在验证是不是能够凑齐一对完整的闭合括号。 而且我们可以发现一个规律，越靠左的左括号，它对应的右括号就越靠右。反之也就是最后面的左括号，对应的必定是出现的第一个右括号。 所以我们就可以在遇到左括号时就入栈，遇到右括号时就与栈顶的括号就行配对比较，若果符合配对规则则出栈，否则就不符合规则直接判定无效。匹配到最后结如果栈内是空就证明可以完整闭合 函数调用栈等这个可以看浏览器，js 的解释器就是通过调用栈的形式实现的 执行 fun1 时先将 fun1 入栈，然后调用 fun2，入栈；然后调用 fun3 入栈。 fun3 执行完毕出栈fun2 执行完毕出栈fun1 执行完毕出栈程序执行完毕","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"栈 - 基础知识","slug":"测试","date":"2021-06-08T07:55:21.733Z","updated":"2021-06-08T07:55:21.733Z","comments":true,"path":"2021/06/08/测试/","link":"","permalink":"https://blog.lqh.kim/2021/06/08/%E6%B5%8B%E8%AF%95/","excerpt":"测试首页图片是否能正常显示以及文章描述","text":"测试首页图片是否能正常显示以及文章描述","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"虚拟DOM","slug":"yuque/虚拟DOM","date":"2021-06-08T07:08:16.000Z","updated":"2021-06-08T07:55:49.975Z","comments":true,"path":"2021/06/08/yuque/虚拟DOM/","link":"","permalink":"https://blog.lqh.kim/2021/06/08/yuque/%E8%99%9A%E6%8B%9FDOM/","excerpt":"","text":"什么是虚拟 DOM？虚拟 DOM：本质上是 JS 和真实 DOM 之间的一个映射。用 js 对象的形式来描述 DOM 结构和属性需要关注的两个点： 虚拟 DOM 就是一个 JS 对象 虚拟 DOM 是对真实 DOM 的一个描述（抽象出来的一个结构） 虚拟 DOM 在 React 中怎么工作的？虚拟 dom 在 react 中的工作过程分为两个阶段： 挂载阶段：react 通过 JSX 解析出来对应的虚拟 DOM，然后 ReactDOM.render()方法将虚拟 DOM 渲染成为真实 DOM 更新阶段：会先作用于虚拟 DOM 上，通过 diff 算法来对比更新前后的两个虚拟 DOM 找出差异，然后将需要改变的地方再作用于真实 DOM 为什么用虚拟 DOM？ 虚拟 DOM 可以实现跨平台。因为虚拟 dom 其实就相当于一个独立的 Model 层，对于不同的平台可以将真实的结构来抽象形成一个对应的抽象对象来进行描述，这样就可以实现一套代码，多端运行的目的 虚拟 DOM 的出现可以提高我们的日常开发效率 其实虚拟 DOM 并不会提高应用的性能，react 官方也没有说过虚拟 dom 会提高性能这一点。","categories":[],"tags":[]},{"title":"React-redux","slug":"yuque/React-redux","date":"2021-06-08T06:34:11.000Z","updated":"2021-06-08T07:55:50.035Z","comments":true,"path":"2021/06/08/yuque/React-redux/","link":"","permalink":"https://blog.lqh.kim/2021/06/08/yuque/React-redux/","excerpt":"","text":"核心原则单向数据源整个应用的数据源 state，只存在于一个 store 中。单项数据源保证了流程的可控，和可追踪，能比较清晰的知道是在哪个环节出现了问题。 state 是只读的state 是只读的，修改 state 的唯一方式就是触发 action 1234store.dispatch(&#123; type: &quot;COMPLETE_TODO&quot;, index: 1,&#125;); 使用纯函数执行修改reducer 函数是用来描述 action 如何触发的修改。并且 reducer 中只能是纯函数 12345678910function counter(state = 0, action) &#123; switch (action.type) &#123; case &quot;INCREMENT&quot;: return state + 1; case &quot;DECREMENT&quot;: return state - 1; default: return state; &#125;&#125; ​","categories":[],"tags":[]},{"title":"Fiber架构","slug":"yuque/Fiber架构","date":"2021-06-08T03:34:09.000Z","updated":"2021-06-08T07:55:50.039Z","comments":true,"path":"2021/06/08/yuque/Fiber架构/","link":"","permalink":"https://blog.lqh.kim/2021/06/08/yuque/Fiber%E6%9E%B6%E6%9E%84/","excerpt":"","text":"怎么理解 fiber 架构","categories":[],"tags":[]},{"title":"Hooks的实现机制","slug":"yuque/Hooks的实现机制","date":"2021-06-08T01:50:27.000Z","updated":"2021-06-08T07:55:50.127Z","comments":true,"path":"2021/06/08/yuque/Hooks的实现机制/","link":"","permalink":"https://blog.lqh.kim/2021/06/08/yuque/Hooks%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Hooks 使用的时候官方给出了两条限制条件： 只能在 React 函数中使用 hooks 不能在循环、条件或嵌套函数中使用 hook ​ 第一条其实是比较容易理解的，因为之前也说过，hooks 的出现就是为了增强函数组件的功能的，所以只能在函数中使用，也是情有可原。那为什么不能在循环或者条件函数里使用 hook 呢？这里我们就以useState为例来探索一下 hooks 的实现机制。​ 更新在开始之前我们先来看一下 React 中的更新。 12345const App = ()=&gt;&#123; const [name, setName] = useState(&#x27;六一&#x27;); return &lt;p onClick=&#123;()=&gt; setName(&#x27;憨憨の爸爸&#x27;)&#125;&gt;&#123;name&#125;&lt;p/&gt;&#125; 就上面这个组件来说，其实更新包含两个阶段： 页面初次挂载，产生第一次更新：mount 点击 p 标签，调用 setName 方法也会触发页面的更新：update ​ 而我们在下面探索的 useState 也是这样，他的调用链路在不同的更新阶段会有所差别。​ useState 的调用链路初次挂载：mount我们这里主要关注mountState这个方法： 1234567891011121314151617181920212223242526272829303132// 进入 mounState 逻辑function mountState(initialState) &#123; // 将新的 hook 对象追加进链表尾部 var hook = mountWorkInProgressHook(); // initialState 可以是一个回调，若是回调，则取回调执行后的值 if (typeof initialState === &quot;function&quot;) &#123; // $FlowFixMe: Flow doesn&#x27;t like mixed types initialState = initialState(); &#125; // 创建当前 hook 对象的更新队列，这一步主要是为了能够依序保留 dispatch const queue = (hook.queue = &#123; last: null, dispatch: null, lastRenderedReducer: basicStateReducer, lastRenderedState: (initialState: any), &#125;); // 将 initialState 作为一个“记忆值”存下来 hook.memoizedState = hook.baseState = initialState; // dispatch 是由上下文中一个叫 dispatchAction 的方法创建的，这里不必纠结这个方法具体做了什么 var dispatch = (queue.dispatch = dispatchAction.bind( null, currentlyRenderingFiber$1, queue )); // 返回目标数组，dispatch 其实就是示例中常常见到的 setXXX 这个函数，想不到吧？哈哈 return [hook.memoizedState, dispatch];&#125; 可以看到这个阶段主要是为了初始化 Hooks，我们需要重点关注一下mountWorkInProgressHook这个方法，这个方法中为我们表述了基本的 hook 结构 1234567891011121314151617181920function mountWorkInProgressHook() &#123; // 注意，单个 hook 是以对象的形式存在的 var hook = &#123; memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null, &#125;; if (workInProgressHook === null) &#123; // 这行代码每个 React 版本不太一样，但做的都是同一件事：将 hook 作为链表的头节点处理 firstWorkInProgressHook = workInProgressHook = hook; &#125; else &#123; // 若链表不为空，则将 hook 追加到链表尾部 workInProgressHook = workInProgressHook.next = hook; &#125; // 返回当前的 hook return workInProgressHook;&#125; 可以看到这个方法就是初始化单个 hook 对象的，并且将每个 hook 对象以 next 指针进行关联，形成一个单向链表。而 hook 的基本结构就是这样的memoizedState 就是当前的 state 值。 这里需要和 fiber 结构中的 memoizedState 区别开来。fiber 结构中的 memoizedState 保存该 FunctionComponent 对应的 Hooks 链表而函数组件能实现状态的保存，也是将数据保存在对应函数组件的 fiber 中 &gt; 更新阶段：update可以看到在更新阶段，他们的调用方法是不一样的。​ 并且对于这个流程我们只需要知道updateState以及之后的流程做的一件事目的都比较明确就是：根据我们在 mout 阶段生成的 hooks 的链表，来按照顺序遍历读取对应的数据进行渲染。​ 这里需要注意一点就是，在非首次更新的阶段中，查找对应的 hook 是“依次遍历”的，也就是按照顺序一个个查找下来的，并不是按照 useState 的名字去查找的。 所以当我们在判断中去写 useState 的时候，就会造成在初次挂载时形成的链表结构中是有 3 个 hook，但是在更新的时候由于条件不满足就会造成只剩两个或者一个 hook，所以就会造成在遍历链表的过程中造成 hook 对应不上的情况，就会抛出错误，并且不能获取到真实数据的情况。 ​ 总结 为什么 hook 不能写在循环或者判断里 在一个组件初次挂载的时候，会调用 mountState 方法，就所有的 hook 形成一个链表结构，在组件发生更新时会调用 updateState 方法，去按照顺序遍历我们在挂载时形成的链表，如果在更新时因为判断或者循环造成 hook 的顺序或者数量发生变化，就会发生无法对应到实际 hook 的情况","categories":[],"tags":[]},{"title":"webpack编译结果分析","slug":"yuque/webpack编译结果分析","date":"2021-06-07T11:59:14.000Z","updated":"2021-06-08T07:55:50.231Z","comments":true,"path":"2021/06/07/yuque/webpack编译结果分析/","link":"","permalink":"https://blog.lqh.kim/2021/06/07/yuque/webpack%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90/","excerpt":"","text":"首先我们可以尝试自己手写一个简单的编译结果。然后和实际的编译结果进行对比，来加深对编译结果的分析。​ 手写 webpack 编译结果 这里的相关代码，已上传 git 仓库 1. 合并模块,形成一个模块对象在开始写编译结果之前，我们需要思考一个问题：打包之后的结果里，怎么把所有的模块给合并到一起，这些模块的导出用什么形式来接收？其实这一步我们可以使用函数来完成，即把每个模块的代码都当成一个函数去执行，将这些所有代码组装成一个 Module 对象： 对象的 key 就是模块的文件路径 value 就是一个函数，这个函数里的内容就是对应模块文件中需要执行的代码 12345678910111213const module = &#123; &quot;./src/a.js&quot;: function (module, exports, require) &#123; console.log(&quot;a module&quot;); module.exports = &#123; a: 1, &#125;; &#125;, &quot;./src/index.js&quot;: function (module, exports, require) &#123; console.log(&quot;index module&quot;); var a = require(&quot;./src/a.js&quot;); console.log(a); &#125;,&#125;; 这里有几个问题需要注意 在函数中，我们的形参为module, exports, require。这些都是导入导出所需要的变量，我们用参数的形式代替。之后需要我们来完成这些导入导出的统一。 ​ 但是这里我们需要注意一个问题，就是为了不影响其他模块的内容，我们打包后的文件里的所有声明都不应该去影响到其他的声明，所以我们这里可以借助立即执行函数来形成一个封闭的空间，保证变量或者函数声明的局部性 12345678910111213(function (module) &#123;&#125;)(&#123; &quot;./src/a.js&quot;: function (module, exports, require) &#123; console.log(&quot;a module&quot;); module.exports = &#123; a: 1, &#125;; &#125;, &quot;./src/index.js&quot;: function (module, exports, require) &#123; console.log(&quot;index module&quot;); var a = require(&quot;./a&quot;); console.log(a); &#125;,&#125;); 2. 执行入口文件，实现 require 功能我们已经形成了一个模块对象，接下来我们就需要考虑函数里需要实现什么功能。一开始我们需要执行入口文件，通过入口文件来不断的执行所有的依赖文件。所以我们这里就需要先实现执行入口文件的功能 12// 执行入口文件require(&quot;./src/index.js&quot;); 我们通过自定义一个 require 方法来实现执行文件的效果，这个方法需要有这样的几个功能 根据参数来执行对应的模块函数 返回值需要是导出的对象 这里我们注意一个问题，为了与 node 的 require 方法区别开来，我们这里将 require 方法命名为_webpack_require 1234567891011121314151617181920212223242526272829(function (module) &#123; function _webpack_require(moduleID) &#123; // 根据参数找到对应的模块函数 const func = module[moduleID]; // 定义执行函数所需要的参数 const _webpack_module = &#123; exports: &#123;&#125;, &#125;; const exports = _webpack_module.exports; // 执行函数,注意函数的三个参数 func(_webpack_module, exports, _webpack_require); // 返回值为导出的对象 return _webpack_module.exports; &#125; // 执行入口文件 _webpack_require(&quot;./src/index.js&quot;);&#125;)(&#123; &quot;./src/a.js&quot;: function (module, exports, require) &#123; console.log(&quot;a module&quot;); module.exports = &#123; a: 1, &#125;; &#125;, &quot;./src/index.js&quot;: function (module, exports, require) &#123; console.log(&quot;index module&quot;); var a = require(&quot;./src/a.js&quot;); console.log(a); &#125;,&#125;); 这里也需要注意一个问题，webpack 在打包的时候会把我们写的引用模块的路径给补充完整。例如我们代码里写的是 require(‘./a’)，那么他就会打包成为 require(‘./src/a.js’) 3. 完成模块缓存因为执行过的模块会被缓存起来，用来优化执行效率，所以这里主要是借助一个缓存对象来完成 初始化缓存对象 cache 判断该模块是否被缓存 如果有缓存，直接返回缓存的 exports 没有缓存，就正常下面的执行逻辑。加入缓存，然后更新缓存标识 1234567891011121314151617181920212223242526272829303132333435363738(function (module) &#123; // 初始化缓存对象 const cache = &#123;&#125;; function _webpack_require(moduleID) &#123; if (cache[moduleID]) &#123; return cache[moduleID].exports; &#125; // 根据参数找到对应的模块函数 const func = module[moduleID]; // 定义执行函数所需要的参数 const _webpack_module = &#123; exports: &#123;&#125;, l: false, &#125;; const exports = _webpack_module.exports; // 执行函数,注意函数的三个参数 func(_webpack_module, exports, _webpack_require); // 更新加载标识 _webpack_require.l = true; // 返回值为导出的对象 return _webpack_module.exports; &#125; // 执行入口文件 _webpack_require(&quot;./src/index.js&quot;);&#125;)(&#123; &quot;./src/a.js&quot;: function (module, exports, require) &#123; console.log(&quot;a module&quot;); module.exports = &#123; a: 1, &#125;; &#125;, &quot;./src/index.js&quot;: function (module, exports, require) &#123; console.log(&quot;index module&quot;); var a = require(&quot;./src/a.js&quot;); console.log(a); &#125;,&#125;); 对比真实打包文件下面是去除了注释之后的代码。首先来看整体的格式：是一个立即执行函数，并且参数就是由依赖形成的一个 module 对象然后我们来看看函数内部的实现，重点关注我标注的这些地方是不是和我们写的很像。然后我们来看看他的webpack_require函数里的实现","categories":[],"tags":[]},{"title":"手撕Promise","slug":"yuque/手撕Promise","date":"2021-06-05T06:09:42.000Z","updated":"2021-06-08T07:55:50.319Z","comments":true,"path":"2021/06/05/yuque/手撕Promise/","link":"","permalink":"https://blog.lqh.kim/2021/06/05/yuque/%E6%89%8B%E6%92%95Promise/","excerpt":"","text":"第一步：完成 Promise 的基本构造这一步主要是完成一个new Promise()的基本构造。从上图中的创建方法和参数我们可以确定两点 参数类型为一个函数,该函数接收两个函数类型的参数 resolve: 将 pending 状态推向已决状态的 fulfilled 状态 rejected: 将 pending 状态推向已决状态的 rejected 状态 调用构造函数时,需要将该函数类型的参数执行 执行时需要捕获该参数的错误,因为在该函数发生错误时,需要主动将状态推向 rejected 状态 ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const PROMISE_STATE = &quot;[[PromiseState]]&quot;; // 状态const PROMISE_RESULT = &quot;[[PromiseResult]]&quot;; // 结果值// 三种状态值const PENDING = &quot;pending&quot;; // 未决状态const FULFILLED = &quot;fulfilled&quot;; // 已决状态1const REJECTED = &quot;rejected&quot;; // 已决状态2class MyPromise &#123; /** * 构造函数 * @param &#123;function&#125; executor 传递进来的回调函数 */ constructor(executor) &#123; this[PROMISE_RESULT] = undefined; this[PROMISE_STATE] = PENDING; // 已决状态: fulfilled const resolve = (data) =&gt; &#123; this._changeState(data, FULFILLED); &#125;; // 已决状态: rejected const rejected = (err) =&gt; &#123; this._changeState(err, REJECTED); console.error(new Error(err)); &#125;; // 执行回调,从未决状态推向已决状态: 需要注意这里需要捕获错误,并且推向rejected状态 try &#123; executor(resolve, rejected); &#125; catch (err) &#123; rejected(err); &#125; &#125; /** * 改变状态 * @param &#123;*&#125; result 结果值 * @param &#123;*&#125; state 状态值 * @returns Undefined */ _changeState(result, state) &#123; // 改变状态只能在pending的状态下改变 if (this[PROMISE_STATE] !== PENDING) &#123; return; &#125; // 改变状态和结果 this[PROMISE_STATE] = state; this[PROMISE_RESULT] = result; &#125;&#125; 改变状态时需要注意两点: 状态必须是由未决状态的 pending 推向其他状态, 状态只能改变一次。如果不是 pending 状态则说明状态已经改变过一次,已经是已决状态了,所以不能再次改变状态了 第二步：实现 Promise 的.then()、.catch()调用从上图中调用方式我们可以知道： promise 类中需要返回两个方法，一个 then、一个 catch 可以添加多个 then 和 catch 方法，所以需要两个任务队列来将所有注册的方法存入队列中去执行 ​ 那么现在就牵扯到两个问题： 什么时候入队？ 什么时候执行？ ​ 什么时候入队？按照正常步骤来理解，在注册 then 或者 catch 函数的时候就应该入队。但是这里有一点需要注意的是：当状态已经变为已决状态的时候，应该立即执行 then 或者 catch 中传入的回调 1234567891011121314151617181920212223242526272829303132this.fuilledList = [];this.catchList = [];// .../** * then方法 * @param &#123;*&#125; fulfilledFn fulfilled状态下的处理回调 * @param &#123;*&#125; catchFn then函数的第二个参数是rejected状态下的处理函数 */then(fuilledFn,catchFn)&#123; if (this[PROMISE_STATE] === FULFILLED) &#123; setTimeout(() =&gt; &#123; fuilledFn(this[PROMISE_RESULT]); &#125;, 0); &#125; else &#123; this.fuilledList.push(fuilledFn); &#125; this.catch(catchFn)&#125;/** * catch方法 * @param &#123;*&#125; catchFn rejected状态的处理回调 */ catch(catchFn) &#123; if (this[PROMISE_STATE] === REJECTED) &#123; setTimeout(() =&gt; &#123; catchFn(this[PROMISE_RESULT]); &#125;, 0); &#125; else &#123; this.catchList.push(fuilledFn); &#125; &#125; 上面代码中 setTimeout 的作用：模拟 promise 的异步执行利用定时器将任务推入任务队列这里的区别就是 setTimeout 是宏任务队列,而 promise 是微任务队列​ 从上面代码中可以看出，then 和 catch 中的处理函数可以提取为公共函数 12345678910111213141516171819202122232425262728293031323334/** * 已决阶段的处理函数 * @param &#123;*&#125; callback 需要执行的回调函数 * @param &#123;*&#125; state 需要确定的状态 * @param &#123;*&#125; queue 需要装入的队列 */ _settleHandle(callback, state, queue) &#123; if (typeof callback !== &#x27;function&#x27;) return; if (this[PROMISE_STATE] === state) &#123; setTimeout(() =&gt; &#123; callback(this[PROMISE_RESULT]); &#125;, 0); &#125; else &#123; queue.push(callback); &#125; &#125;/** * then方法 * @param &#123;*&#125; fulfilledFn fulfilled状态下的处理回调 * @param &#123;*&#125; catchFn then函数的第二个参数是rejected状态下的处理函数 */ then(fulfilledFn, catchFn) &#123; this._settleHandle(fulfilledFn, FULFILLED, this.fulfilledList); this.catch(catchFn); &#125; /** * catch方法 * @param &#123;*&#125; catchFn rejected状态的处理回调 */ catch(catchFn) &#123; this._settleHandle(catchFn, REJECTED, this.catchList); &#125; 总结then 和 catch 的入队时机是在注册的时候。注意点就是：当状态已经成为已决状态时，不是执行入队操作，而是直接执行当前状态对应的回调​ 什么时候执行？执行对应任务队列里的 fuilled 或者 catch 函数，应该是在状态改变时执行。所以这里我们只需要改变一下之前的_changeState 函数 即可 添加一个参数 queue，即需要执行哪个队列里的任务 遍历队列，执行函数，在执行时将当前的 result 值作为参数，传递给 fn 123456789101112131415161718/** * 改变状态 * @param &#123;*&#125; result 结果值 * @param &#123;*&#125; state 状态值 * @param &#123;*&#125; queue 需要执行的任务队列 * @returns Undefined */ _changeState(result, state, queue) &#123; // 改变状态只能在pending的状态下改变 if (this[PROMISE_STATE] !== PENDING) &#123; return; &#125; // 改变状态和结果 this[PROMISE_STATE] = state; this[PROMISE_RESULT] = result; // 执行缓存队列里的对应函数 queue.forEach((fn) =&gt; fn(this[PROMISE_RESULT])); &#125; 接下来就是在不同的改变状态的函数中调用即可 123456789// 已决状态: fulfilledconst resolve = (data) =&gt; &#123; this._changeState(data, FULFILLED, this.fulfilledList);&#125;;// 已决状态: rejectedconst rejected = (err) =&gt; &#123; this._changeState(err, REJECTED, this.catchList); console.error(new Error(err));&#125;; 总结在状态发生变化的时候执行对应的队列中的函数。注意点： 执行函数时将此时的 PROMISE_RESULT 值当做参数传递进去 第三步：实现.then 或者.catch 的链式调用这里需要知道的就是，为了实现链式调用，那么 then 和 catch 返回值必定是一个新的 promise 对象。这里需要考虑的问题： 链式的 then 什么时候执行？ 很明显这里的，then 应该是等待上次的 then 执行完毕之后再去执行下一次的 then。那么这里就又需要考虑，我们怎么才能知道上一次的 then 执行完了呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 /** * then方法 * @param &#123;*&#125; fulfilledFn fulfilled状态下的处理回调 * @param &#123;*&#125; catchFn then函数的第二个参数是rejected状态下的处理函数 */ then(fulfilledFn, catchFn) &#123; return this.linkPromise(fulfilledFn, catchFn); &#125; /** * catch方法 * @param &#123;*&#125; catchFn rejected状态的处理回调 */ catch(catchFn) &#123; return this.linkPromise(undefined, catchFn); &#125; /** * 需要返回的promise对象 * @param &#123;*&#125; fulfilledFn fulfilled状态下的回调 * @param &#123;*&#125; catchFn rejected状态下的回调 * @returns Undefined */ linkPromise(fulfilledFn, catchFn) &#123; return new MyPromise((resolve, rejected) =&gt; &#123; this._settleHandle( (data) =&gt; &#123; try &#123; // then处理函数的返回值就是下一个then的data值 const result = fulfilledFn(data); resolve(result); &#125; catch (err) &#123; rejected(err); &#125; &#125;, FULFILLED, this.fulfilledList ); this._settleHandle( (err) =&gt; &#123; // then处理函数的返回值就是下一个then的data值 const result = catchFn(err); resolve(result); &#125;, REJECTED, this.catchList ); &#125;); &#125;&#125;","categories":[],"tags":[]},{"title":"webpack简介","slug":"yuque/webpack简介","date":"2021-06-03T22:53:20.000Z","updated":"2021-06-08T07:55:50.331Z","comments":true,"path":"2021/06/04/yuque/webpack简介/","link":"","permalink":"https://blog.lqh.kim/2021/06/04/yuque/webpack%E7%AE%80%E4%BB%8B/","excerpt":"","text":"webpack 简介webpack 通过一个开发时态的入口模块为起点，分析出文件中所有的依赖关系，然后经过一系列的压缩、合并过程，最终生成运行时态的文件 webpack 的特点 为前端工程化而生：让开发者集中注意力编写业务代码 简单易用： 支持零配置 强大生态： 灵活，可扩展，提供了使用第三方库来完成其他功能 基于 nodejs：由于 webpack 在构建过程中需要读取文件，所以是运行在 node 环境中的 基于模块化： 通过文件中的导入语句来分析依赖关系，它支持各种模块化标准，包括但不限于 commonjs，es module、amd、cmd 等 ​","categories":[],"tags":[]},{"title":"词法环境和词法作用域","slug":"yuque/词法环境和词法作用域","date":"2021-05-27T02:43:11.000Z","updated":"2021-06-08T07:55:50.399Z","comments":true,"path":"2021/05/27/yuque/词法环境和词法作用域/","link":"","permalink":"https://blog.lqh.kim/2021/05/27/yuque/%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83%E5%92%8C%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"词法环境概念词法环境（Lexical Environment）：是一种规范类型，是为了表明标识符与变量和函数之间的一种关联关系。词法环境包含两部分 环境记录（environment record）: 存储变量和函数声明的实际位置 外部词法环境（outer Lexical Environment）：可以访问的的外部词法环境。这里是实现作用域链的关键。每个环境能访问到的标识符集合叫做作用域，通过外部词法环境形成的层层嵌套的关系，叫做作用域链 外部词法环境的值可能为 null，比如全局环境的 outer 就是 null 代码演示12345678910let a = 20;const b = 30;var c;function foo(e, f) &#123; var g = 20; return e * f * g;&#125;c = multiply(20, 30); 上面一段代码所对应的词法环境的伪代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647GlobalExectionContext = &#123;// 全局执行上下文 ThisBinding: &lt;Global Object&gt;, LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Object&quot;, // 标识符绑定在这里 a: &lt; uninitialized &gt;, b: &lt; uninitialized &gt;, foo: &lt; func &gt; &#125; outer: &lt;null&gt; &#125;, VariableEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Object&quot;, // 标识符绑定在这里 c: undefined, &#125; outer: &lt;null&gt; &#125;&#125;FunctionExectionContext = &#123;// 函数执行上下文 ThisBinding: &lt;Global Object&gt;, LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Declarative&quot;, // 标识符绑定在这里 Arguments: &#123;0: 20, 1: 30, length: 2&#125;, // 接收的参数 &#125;, outer: &lt;GlobalLexicalEnvironment&gt; //指向的外部环境 &#125;, VariableEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Declarative&quot;, // 标识符绑定在这里 g: undefined &#125;, outer: &lt;GlobalLexicalEnvironment&gt; &#125;&#125; 从上面的代码演示中我们可以看出来，词法环境的形成其实是在变量和函数定义的时候就已经确定的，和他们调用的位置无关，这种特征就叫做静态作用域，也叫作词法作用域，而 JS 就是采用的词法作用域 词法作用域概念词法作用域（静态作用域）： 函数的作用域在函数定义的时候就已经确定了。动态作用域： 函数的作用域在函数调用的时候才会确定​ 代码演示1234567891011121314var x = 1;function foo() &#123; var y = x + 1; return y;&#125;function bar() &#123; var x = 2; return foo();&#125;foo();bar(); 上面代码中的执行结果是什么呢？两个都是 2.这里我们来分析一下这段代码对应的词法作用域 12345678910111213141516171819202122GlobalEnvironment = &#123; EnvironmentRecord: &#123; // 自定义标识符 x: 1 &#125;, outer: null&#125;;fooEnvironment = &#123; EnvironmentRecord: &#123; y: 2, bar: &#x27;&lt;func&gt;&#x27; &#125; outer: GlobalEnvironment&#125;;barEnvironment = &#123; EnvironmentRecord: &#123; z: 3 &#125; outer: fooEnvironment// 在定义的时候就确定了外部词法环境为foo函数的环境&#125;; 再来看一个 123456789101112131415161718192021// 1var scope = &quot;global scope&quot;;function checkscope() &#123; var scope = &quot;local scope&quot;; function f() &#123; return scope; &#125; return f();&#125;checkscope();// 2var scope = &quot;global scope&quot;;function checkscope() &#123; var scope = &quot;local scope&quot;; function f() &#123; return scope; &#125; return f;&#125;checkscope()(); 分析作用域 123456789101112131415161718192021GlobalEnvironment=&#123; Environment: &#123; scope: &quot;glbal scope&quot;, checkscope: &quot;&lt;fun&gt;&quot; &#125;, outer: null&#125;checkscopeEnvironment = &#123; Enviromnet: &#123; scope: &quot;local scope&quot;, f:&quot;&lt;fun&gt;&quot; &#125;, outer: GlbalEnvironment&#125;fEnvironment = &#123; Enviroment: &#123; &#125;, outer: checkscopeEnvironment&#125; 其实第一个和第二个是一样的，f 函数都是在 checkscope 的环境中定义的，所以它的 outer 指向的都是 checkscopeEnvironment，所以最后的打印结果两个都是local scope​","categories":[],"tags":[]},{"title":"编程题","slug":"yuque/编程题","date":"2021-05-26T02:41:44.000Z","updated":"2021-06-08T07:55:50.451Z","comments":true,"path":"2021/05/26/yuque/编程题/","link":"","permalink":"https://blog.lqh.kim/2021/05/26/yuque/%E7%BC%96%E7%A8%8B%E9%A2%98/","excerpt":"","text":"实现 setTimeout 方法123new Promise((resolve) =&gt; mySetTimeout(() =&gt; resolve(&quot;执行&quot;), 3000)).then( (data) =&gt; console.log(data)); 题解使用requestAnimationFrame（callback）来实现，该 API 的作用就是在浏览器下次重绘前进行回调函数的调用。我们可以用递归的方式来模拟定时期的效果回调函数执行次数通常是每秒 60 次，但在大多数遵循 W3C 建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配 123456789101112131415161718function mySetTimeout(callback, delay) &#123; let startTime = Date.now(); let timerId; // 回调函数 const loop = () =&gt; &#123; // 判断是否到达延时时间 if (Date.now() - startTime &gt;= delay) &#123; // 执行回调 callback(); window.cancelRequestAnimationFrame(timerId); &#125; else &#123; // 如果未到达延时时间，则递归调用回调，模拟定时器效果，在每次页面更新前都确保执行loop看是否到达延时时间 timerId = window.requestAnimationFrame(loop); &#125; &#125;; // 调用函数 window.requestAnimationFrame(loop);&#125; 数组扁平化将数组整个拍平 利用 reduce，每轮都去判断，当前值是否为数组，如果是数组，就递归调用 12345678910// 全部扁平化function allFlat(arr) &#123; return arr.reduce((prev, curr) =&gt; &#123; if (Array.isArray(curr)) &#123; return [...prev, ...allFlat(curr)]; &#125; else &#123; return [...prev, curr]; &#125; &#125;, []);&#125; 实现 flat 方法 通过传入的 depth 值来确定需要拍平几层数组 如果 depth 大于 0，则按照传入的值不断去拍平 如果 depth 小于 0，则直接返回原数组，不进行拍平 12345678910111213141516// 实现flatfunction myFlat(arr, depth = 1) &#123; if (depth &gt; 0) &#123; // 正常拍平数组的操作，多加一个depth的参数，每轮都在上一个depth基础上减1 return arr.reduce((prev, cur) =&gt; &#123; if (Array.isArray(cur)) &#123; return [...prev, ...myFlat(cur, depth - 1)]; &#125; else &#123; return [...prev, cur]; &#125; &#125;, []); &#125; else &#123; // depth小于等于0，证明已经拍平结束，直接返回原数组 return arr; &#125;&#125;","categories":[],"tags":[]},{"title":"TLS","slug":"yuque/TLS","date":"2021-05-25T11:53:10.000Z","updated":"2021-06-08T07:55:50.455Z","comments":true,"path":"2021/05/25/yuque/TLS/","link":"","permalink":"https://blog.lqh.kim/2021/05/25/yuque/TLS/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"应用层-HTTP/1.1协议","slug":"yuque/应用层-HTTP!1.1协议","date":"2021-05-23T12:47:58.000Z","updated":"2021-06-08T07:55:50.479Z","comments":true,"path":"2021/05/23/yuque/应用层-HTTP!1.1协议/","link":"","permalink":"https://blog.lqh.kim/2021/05/23/yuque/%E5%BA%94%E7%94%A8%E5%B1%82-HTTP!1.1%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"一种无状态的、应用层的、以请求/应答方式运行的协议，他使用可扩展的语义和自描述消息格式，与基于网络的超文本信息系统灵活的互动。​ 基于 ABNF 语法定义的 HTTP基本语法 SP：空白字符，用来分隔定义中的各个元素 /: 选择，就是或的意思 %cxx-xx：值范围，例如 %x30-37，十六进制中的 30-37 （）：组合，将括号中的视为一个单个元素 不定量重复 ： 表示 0~多次 1*： 表示 1~多次 2*4： 表示 2~4 次 [] : 可选序列，即可有可无 ABNF 的核心规则 基于 ABNF 描述的 http 格式第一行代码表示的就是 HTTP 信息的整体格式： 开始行（请求行） 0 或者多个请求头+换行符 换行符 信息体（请求体/响应体） 下面是对开始行和请求行以及信息体的具体描述： 开始行： 分为请求头和响应头 请求头：请求方法 空格符 请求地址 空格符 http 版本 换行 响应头：http 版本 空格符 状态码 空格符 原因短语 换行 请求头：属性名称 + 冒号 + OWS 属性值 OWS OWS 定义： 0~多个空格或制表符 field-name 定义：有效的 token 值 field-value 定义： 0~多个 消息体： 通过二进制的方式传递","categories":[],"tags":[]},{"title":"从输入URL到页面展示，这期间发生了神魔？","slug":"yuque/从输入URL到页面展示，这期间发生了神魔？","date":"2021-05-20T13:03:01.000Z","updated":"2021-06-08T07:55:50.571Z","comments":true,"path":"2021/05/20/yuque/从输入URL到页面展示，这期间发生了神魔？/","link":"","permalink":"https://blog.lqh.kim/2021/05/20/yuque/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E7%A5%9E%E9%AD%94%EF%BC%9F/","excerpt":"","text":"面试经典问题，为何经典？我觉得是因为这道题涵盖的内容太多了，网络、浏览器、操作系统等都可以聊到，每一块单拿出来又都可以挖很多坑，所以这道题作为面试题可以说是一个极好的切入点。今天就来整理一下自己学习整理之后的一些知识点。 导航阶段 从发起请求到页面解析的这个过程，称为导航阶段 浏览器进程将用户输入的 URL 处理完成后发送给网络进程 网络进程会根据该 URL 来首先查找本地缓存，看是否有该资源的缓存 有缓存：将缓存的资源副本发送给浏览器进程 没有缓存就会进行DNS 解析，DNS 解析的时候也会优先查找本地缓存，如果没有缓存就会去请求 DNS 服务器来获取到域名对应的IP 地址。 有了 IP 地址之后就会进行TCP 连接，这里会涉及到 TCP 的三次握手过程（TCP 相关链接） TCP 连接成功之后，就会将构建的请求头和请求行等信息发送给服务端，在发送的时候会将该域名下的 cookie 信息带在请求头中进行发送 服务端收到请求后，会构建对应的响应头和响应行以及响应体，然后返回给客户端 浏览器在接收到服务端返回的响应头和响应行等信息时，就会开始对响应数据进行解析（此时网络进程会将接受到数据转发给浏览器进程） 状态码 301、302：重定向。浏览器会根据响应头中的 location 字段进行新的 url 请求，重复上述流程 200：请求成功，继续处理该响应数据 content-type **application/octep-strame**：二进制流，网络进行会通知浏览器的下载管理器对资源进行下载，然后结束本次请求流程 **text/html**: 返回的 html 格式，通知渲染进行准备 **application/json**: json 字符串，一般为请求的接口数据 准备渲染进程，渲染进程准备好之后，现在还不能直接解析文档，因为此时的文档还在网络进程中 浏览器进程将网络进程请求到的数据交给渲染进程，提交文档 网络进程在接收到响应行等信息时，会将接收到的数据发送给浏览器进程 浏览器进程收到数据，会通知渲染线程进行准备接收提交的文档 渲染进程接收到浏览器进程的准备渲染消息时，就会开启提交文档阶段，并且会通知浏览器进程确认文档已提交的信息，表示自己已经准备好接收、解析文档了（接收文档的方式是和网络进程建立通信管道）—- 这里解析的时候就是渲染进程中的工作 浏览器进程收到确认提交的信息后，会移除掉旧的页面，然后的等待渲染进程加载解析文档，最后更新浏览器进程中的状态信息和页面 ​ 渲染阶段在提交文档阶段，其实就开始了渲染流程。渲染流程可以分为很多个小的子流程，对于每个子流程都有一个输入输出。 构建 DOM 树将 html 文件通过词法解析来生成 DOM 树。 计算样式样式计算这里可以分为三步来进行 1. 将 css 文件转换为 styleSheets渲染引擎在接收到 css 文件后，会首先将其转换成为可以理解的结构—styleSheets我们可以通过document.styleSheets来查看其结构： 2. 将属性值标准化因为我们在写样式的时候会有很多类似 em、rem 的单位，浏览器需要将其转换成为 px 等标准值例如： 123em ===&gt; pxcolor：blue ===&gt; rgb（0，0，255）font-weight：bold ===&gt; font-weight：700 这里涉及到一个性能优化点，就是我们在写样式的时候可以直接写成标准单位，就会节省将属性值标准化这一步的耗时 3. 计算出 DOM 树中每个节点的样式在计算节点样式的时候，需要遵循继承和层叠两大规则，样式计算完毕之后会将计算后的样式保存在computedStyle中。 继承：常见的能够继承的属性包括：color、text-align、line-height、font-size、font-family、font-weight… … 层叠其实就是涉及到 css 优先级计算的一些东西（css 优先级计算​） 构建 Layout Tree我们目前这个阶段是已知了 DOM 树和每个节点的样式，但是现在还没办法展示，因为还不知道每个元素的几何位置信息。所以接下来就需要计算出 DOM 树中可见元素的几何位置信息，这个阶段叫布局在这个阶段，首先会构建出来一颗Layout Tree，这个数和 DOM 树不同，在 Layout Tree 中只存在那些需要展示的节点。 例如 html、head、以及设置了 display：none 属性的就不会出现在 layout tree 中。Layout Tree 生成之后就会就行布局计算，就是将每个节点需要展示在屏幕上的坐标位置计算出来，然后将这些计算出来的值去重新写到 Layout Tree 中。 分层Layout Tree 构建出来之后，接下来还不能显示，而要进行的步骤就是对特定属性的元素进行分层处理，构造出来Layer Tree。在分层时，如果一个元素没有被分层，那它就属于父级的那一个层级 触发分层的条件能够触发分层属性的元素有这样两个特征： 触发了层叠上下文的元素 文档根元素 html 标签 position 为 absolute 或者 relative，并且 z-index 属性不为 auto position 为 fixed 或者 sticky flex 元素，并且 z-index 不为 auto grid 元素，并且 z-index 不为 auto opacity 小于 1 transform 不为 none will-change 需要裁剪的元素 当一个元素内的文本长度超过元素区域时，也会触发分层 绘制图层绘制图层时，会将绘制的操作划分为一个个的绘制指令，由这些指令组成一个待绘制列表 栅格化待绘制列表只负责记录指令，而不负责具体的执行，而实际的执行是由渲染进程中的合成线程来完成的 如上图，在渲染进程的主线程中完成了 DOM Tree 的构建，然后根据 css 文件生成的 styleSheets 结构进行样式计算，并且将可见元素和计算的几何位置信息生成布局树，再对特定的元素进行分层操作，生成绘制列表，最后将绘制列表提交给合成线程进行下面的执行 合成线程会对图层进行分块处理，将每个图层分成不同的图块（title）。合成线程会优先将视口附近的图块生成位图，由图块生成位图的这一操作就叫做栅格化。栅格化其实是有栅格化线程来进行的。渲染引擎维护了一个栅格化线程池，一般栅格化会用的 GPU 加速，如果栅格化时用到了 GPU，那么栅格化就会在 GPU 进程中执行，执行完毕之后位图会存放在 GPU 的内存中 合成与显示当所有图层都被栅格化之后，合成线程就会生成一个绘制图块的命令—DrawQuad 命令，然后将命令提交给浏览器进程。浏览器进程收到指令后，就会将页面绘制到内存中，再由内存中显示到页面上​ 相关优化：重排、重绘、合成重排当我们修改一个元素的高度时：就会重新计算样式以及布局，随之就会触发绘制以及分层和栅格化的一系列操作，可以看到是极其消耗性能的。像这种修改元素的宽高和位置进而直接影响页面的操作，就是重排 重绘当我们修改一个元素的颜色时：会重新计算样式，但是由于没有改变元素的几何信息，所以不会触发布局和分层操作，而直接进行绘制，并且绘制后的整个流程是运行在非主线程中的，所以相对重排来说性能会好一些像这种修改元素的颜色这些不影响元素几何信息的操作，就是重绘 合成当我们利用transform：translateY(50)来进行布局时：对样式进行重新计算后，就直接触发合成线程中的合成事件，可以说是极大的节约了性能","categories":[],"tags":[]},{"title":"虚拟列表","slug":"yuque/虚拟列表","date":"2021-05-13T06:31:55.000Z","updated":"2021-06-08T07:55:50.583Z","comments":true,"path":"2021/05/13/yuque/虚拟列表/","link":"","permalink":"https://blog.lqh.kim/2021/05/13/yuque/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/","excerpt":"","text":"首先需要一个能够模拟出滚动区的页面结构按照虚拟列表的方式，计算出来渲染区每次可以渲染出来的总数，但是渲染去并不会被撑开，比如渲染区只能渲染 10 条，俺正常来说渲染区是没滚动条的，那就无法进行滚动，所以我们接下来需要将完整数据的渲染区滚动条给模拟出来​ useRef 的作用我们在函数组件中这样去定义一个变量时，会发生一个问题： 就是每次渲染之后，这个变量都会重新被定义，也就是每次渲染之后都会重新变成初始值 0那么我们应该怎么样去保持这个值在整个生命周期里都是不变的呢，有两个方法： useState useRef 第一种方法是比较常见的，但是有一个弊端就是每次更新值的时候都会重新触发渲染，所以对于那些我们只是想记录一个值的变量来说不是好的解决方案，useRef 就是一个可以实现跨生命周期保持不变的一个对象。","categories":[],"tags":[]},{"title":"TCP初探","slug":"yuque/TCP初探","date":"2021-05-12T23:03:11.000Z","updated":"2021-06-08T07:55:50.639Z","comments":true,"path":"2021/05/13/yuque/TCP初探/","link":"","permalink":"https://blog.lqh.kim/2021/05/13/yuque/TCP%E5%88%9D%E6%8E%A2/","excerpt":"","text":"五层网络模型的流程首先是应用层，应用层提供的就是Aplication-to-Aplication的协议。就比如我们日常使用的微信就是一个应用，当我们使用微信和别人聊天的时候就相当于是从我们的微信应用发送到对方的微信应用中，就是使用的微信的聊天协议（应用到应用的协议），想要达到这个聊天的功能，我们还需要一个主机到主机（Host-to-Host)的协议来帮助应用层的协议工作。应用层往往有众多的应用类型，比如微信、qq、网易云音乐等等，那在我们使用 Host-to-Host 的协议时就需要提供一个标识，来区分这些应用（相当于每个应用的身份证号），而这个标识就是端口号。 TCP是传输层的一个协议，提供Host-to-Host数据的可靠传输。TCP 协议会把应用层提供的端口号（用来区分该 tcp 的包是给哪个应用的），组装到 TCP 段（TCP Segment）中去。而 tcp 在实现主机到主机间通讯的时候还需要两个主机的地址（IP 地址），但是 tcp 并不负责网络地址间的传输，于是就会交给下一层—网络层。 网络层提供的是地址到地址（Adress-to-Adress)之间的传输，IP 协议就在这层工作，但是网络层不负责两个设备间的传输，于是会交给下一层，数据链路层来进行两个相邻设备间的传输，当信号在两个设备之间工作的时候，科学家又封装了最底层的物理设备、传输介质等，由最下方的物理层来提供最底层的信息传输 TCP 头格式（TCP Segment）TCP 协议会将数据拆分成一个个的部分，被称为TCP Segment（拆包）。在接收数据的时候，会讲这些部分进行拼接，形成一个完整的数据包​ （图片来源） TCP 包是没有 IP 地址的，那是 IP 层的事情 Source Port： 源端口号（端口号就是用来确定应用的） Destination Port： 目标端口号 Sequence Number： 序列号，用来解决网络传输时包乱序的问题 Acknowledgment Number：确认收到，用来解决丢包的问题 Window： 滑动窗口，用于解决流控 TCP Flags：包的类型，用来控制 TCP 的状态机的（五个标志位，每个占一比特） … … TCP 的基本操作 一个 Host 主动向另一个 Host 发起连接，称为SYN（Synchronization），请求同步 一个 Host 主动断开请求，称为FIN（Finish），请求完成 一个 Host 向另一个 Host 发送数据，称为PSH（Push），数据推送 每一个 Host 在接收到上面的几种请求时，都需要回复一个ACK（Acknowledge），用来确认请求收到。如果不回复 ACK 的话，主机会认为丢包了，就会重发 ​ TCP 的三次握手和四次挥手 建立连接时双方都需要发送自己初始化的序列号（缩写为ISN：Inital Sequence Number)，也就是上图中的 seq，这个序列号会作为数据传输时的通讯序号，之后 tcp 会用这个序号来进行拼接数据 ISN 的初始化是随机的，是和一个时钟绑定的，这个时钟每过 4 微秒就会将数字+1，直到 2^32 就又会从 0 开始。这样一来一个 ISN 的周期大概是 4.5 个小时。所以只要我们的 TCP segement 在网络上的存活时间不超过 Maximum Segment Lifetime(MSL),也就是 MSL 不超过 4.5 个小时，就不会重用 ISN ​ 数据传输中的 Sequence Number上图中红框中标出的是三次握手的过程，我们着重看下面用紫色线条标注的部分。可以看到seq和ack的变化是根据发送、接收的字节数相关的发送了 1440 字节的数据，seq = 上次的 seq + len接收到了 1440 字节的数据，ack = 上次的 ack + len分别有发送了 1440 字节的数据表示接收到了第二个 1440 字节的数据表示接收到了第三第四个 1440 字节的数据TCP 利用（发送字节数、接收字节数）的唯一性来确定封包之间的顺序关系 为什么需要三次握手？tcp 是一个稳定可靠的传输协议，对于每个端发起的请求，另一端都需要做出回应即 ACK，所以当在发送请求同步 SYN 的时候都需要对方回复一个 ACK，来确保连接的顺利​ 为什么需要四次挥手在断开连接的时候，每一端都需要发送 FIN 的标志位，当对端收到该标志位时，有需要回复 ACK 来确保自己已经收到请求完成的信息，所以当客户端主动发送 FIN 时，服务端端除了回复 ACK 之外，在自己接收完所有数据后也要主动给客户端发送一个 FIN，来说明自己已经接受完所有数据了，可以断开链接了，客户端在收到服务端的 FIN 标志位的时候也需要回复给客户端 ACK，这样才能确保数据已经完全传输过去了，并安全可靠的断开该连接。​ ​ 参考资料 浩叔-TCP 的那些事儿（上） 拉钩教育-计算机网络通关 29 讲","categories":[],"tags":[]},{"title":"二、设计原则","slug":"yuque/二、设计原则","date":"2021-04-08T03:14:37.000Z","updated":"2021-06-08T07:55:50.663Z","comments":true,"path":"2021/04/08/yuque/二、设计原则/","link":"","permalink":"https://blog.lqh.kim/2021/04/08/yuque/%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","excerpt":"","text":"何为设计？ 即按照哪一种思路或者标准来实现功能 功能相同，可以有不同的设计方案来实现 伴随着需求增加，设计的作用才能体现出来 《UNIX/LINUX 设计哲学》一书中提出了几个设计的准则： 准则 1： 小即是美 准则 2： 让每个程序只做好一件事 准则 3： 快速建立原型 准则 4： 舍弃高效率而取可移植性 准则 5： 采用纯文本来存储数据（可读性） 准则 6： 充分利用软件的杠杆效应（复用性） 准则 7： 使用 shell 脚本来提高杠杆效应和可移植性 准则 8： 避免强制性的用户界面 准则 9： 让每个程序都成为过滤器 几个小准则： 允许用户定制环境 尽量使操作系统内核小而轻量化 使用小写字母和简写 沉默是金 各部分之和大于整体 寻求 90%的解决方案（100 个人里只需要满足 90 个用户的需求 - 28 准则） S O L I D 五大设计原则** S 单一职责 O 开放封闭（对扩展开放，对修改封闭） L 李氏置换 I 接口独立 D 依赖导致 单一职责原则 一个函数只负责一件事 专职专用 开放封闭 对扩展开放，对修改封闭 增加需求时，应该是增加代码，而不是去修改已有的代码 李氏置换 子类能覆盖父类 父类能出现的地方子类就能出现 JS 中使用较少（弱类型 &amp; 继承使用较少） 接口独立 保持接口的单一独立，避免出现“胖接口” JS 中是没有接口接口的，使用较少 类似于单一职责，但是更关注接口 依赖倒置 面向接口编程，只关注接口而不关注具体类的实现 JS 中使用较少 23 种设计模式","categories":[],"tags":[]},{"title":"一、面向对象","slug":"yuque/一、面向对象","date":"2021-04-08T03:13:17.000Z","updated":"2021-06-08T07:55:50.903Z","comments":true,"path":"2021/04/08/yuque/一、面向对象/","link":"","permalink":"https://blog.lqh.kim/2021/04/08/yuque/%E4%B8%80%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"什么是面向对象？概念： 类： 抽象出来的一个具有一些通用特征的模板 实例： 通过类构造出来的的具体对象 三要素： 继承：子类继承父类 封装：数据的权限和保密 多态：统一接口的不同实现 继承子类继承父类。 在 js 中实现继承的方式是通过原型链的方式实现的，大概有六种，详情可以看这里https://www.notion.so/callmew/JavaScript-c6f0e1fea7d845a298dbb8f773fd1d66 封装 public 完成开发 protected 对子类开放 private 对自己开放 TS Playground - An online editor for exploring TypeScript and JavaScript 1234567891011121314151617181920212223242526272829class People &#123; name; age; protected weight; // 只对子类公开 constructor(name: string, age: number) &#123; this.name = name; this.age = age; this.weight = 120; &#125;&#125;class Student extends People &#123; number; private girlFriend; // 只对自己开放 constructor(name: string, age: number, number: number) &#123; super(name, age); this.number = number; this.girlFriend = &quot;Lily&quot;; &#125; getWeight() &#123; console.log(this.weight); &#125;&#125;const xiaoMing = new Student(&quot;小名&quot;, 18, 20);xiaoMing.getWeight();xiaoMing.girlFriend; // 私有变量，只能在类内部访问，不能在实例中访问 封装总结： 减少耦合，不该外露的不外露 利于数据、接口的权限管理 ES6 目前不支持，一般认为_开头的属性是 private 多态 同一个接口不同的表现 保持子类的开放性和灵活性 面向接口编程 需要和重载进行区分： 重载：允许存在多个同名函数，然后通过不同的参数来进行调用对应的方法 多态：是对父类的方法进行重新定义，定义一个接口，然后在子类中完成不同的功能 为什么要使用面向对象？编程应该： 简单 &amp; 抽象 UML 类图","categories":[],"tags":[]},{"title":"队列","slug":"yuque/队列","date":"2021-02-06T06:32:18.000Z","updated":"2021-06-08T07:55:50.923Z","comments":true,"path":"2021/02/06/yuque/队列/","link":"","permalink":"https://blog.lqh.kim/2021/02/06/yuque/%E9%98%9F%E5%88%97/","excerpt":"","text":"具体请移步git 仓库查看 【933】最近的请求次数题目描述这道题可能读起来有点难懂，我们这里先来梳理一下题意：我们配合示例来看，首先输入是两个数组 第一个数组是字符串组成的，这个字符串其实对应的是方法的调用 第二个数组是由数字组成的，这个就是在调用的第一个数组时传入的参数 两个数组两两对应 题解1234567891011121314151617181920212223242526var RecentCounter = function () &#123; // 创建缓存队列 this.q = [];&#125;;/** * @param &#123;number&#125; t * @return &#123;number&#125; */RecentCounter.prototype.ping = function (t) &#123; // 将传入的每一个参数入队 this.q.push(t); // 判断队列的首元素是否在当前参数的值到3000之间[t-3000,t] while (this.q[0] &lt; t - 3000) &#123; // 不在就剔除队列中 this.q.shift(); &#125; // 返回队列的长度 return this.q.length;&#125;;/** * Your RecentCounter object will be instantiated and called as such: * var obj = new RecentCounter() * var param_1 = obj.ping(t) */ 时间复杂度：O(n)空间复杂度：O(1)","categories":[],"tags":[]},{"title":"栈","slug":"yuque/栈","date":"2021-02-02T06:10:34.000Z","updated":"2021-06-08T07:55:50.967Z","comments":true,"path":"2021/02/02/yuque/栈/","link":"","permalink":"https://blog.lqh.kim/2021/02/02/yuque/%E6%A0%88/","excerpt":"","text":"具体请移步git 仓库查看 【20】有效的括号描述 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 提示： ** ** 1 &lt;= s.length &lt;= 10 s 仅由括号 &#39;()[]&#123;&#125;&#39; 组成 链接 题解 首先要明确一点，最后出现的左括号一定是匹配第一次出现的右括号（这就可以从栈的后进先出去匹配遇到右括号时是否能和栈顶的左括号相匹配） 1234567891011121314151617181920212223242526var isValid = function (s) &#123; // 如果字符长度是奇数直接返回false if (s.length % 2 === 1) return false; // 构建map字典 const map = new Map([ [&quot;)&quot;, &quot;(&quot;], [&quot;&#125;&quot;, &quot;&#123;&quot;], [&quot;]&quot;, &quot;[&quot;], ]); // 创建缓存栈 const stack = []; // 循环字符串 for (let val of s) &#123; // 符合左括号规则入栈 if (val === &quot;(&quot; || val === &quot;[&quot; || val === &quot;&#123;&quot;) &#123; stack.push(val); &#125; else &#123; // 判断右括号是否和栈顶的左括号匹配 const top = stack.pop(); // 不匹配直接返回false，匹配循环继续 if (map.get(val) !== top) return false; &#125; &#125; // 字符匹配完毕，判断栈内是否清空 return stack.length === 0;&#125;; 时间复杂度： O(n） ：一个循环解决的 空间复杂度：O(n) ：stack 最大可能就是将 s 字符串的所有字符压入，所以为 O(n) 【144】二叉树的前序遍历 - 迭代描述 给你二叉树的根节点 root ，返回它节点值的 前序_ _遍历。 &gt; 链接 题解 首先明确前序遍历的规则：DLR ，即先找自身（D）节点，然后找左（L）节点，最后找右（R）节点 延伸：中序遍历： LDR后续遍历： LRD 2. 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var preorderTraversal = function (root) &#123; if (!root) return []; const res = []; const stack = []; // 将根节点首先压入栈中 stack.push(root); while (stack.length) &#123; // 取出栈顶元素进行遍历操作,栈顶元素就是根元素即D const d = stack.pop(); res.push(d.val); // 分别取出左右节点,分别压入栈中 // 这里需要注意因为栈的特性是后进先出，所以我们前序遍历要先取出左节点，因为这里左节点要最后入栈 if (d.right) stack.push(d.right); if (d.left) stack.push(d.left); &#125; return res;&#125;; 时间复杂度：O(n)空间复杂度：O(n)","categories":[],"tags":[]},{"title":"数据结构","slug":"yuque/数据结构","date":"2021-02-02T03:35:18.000Z","updated":"2021-06-08T07:55:51.139Z","comments":true,"path":"2021/02/02/yuque/数据结构/","link":"","permalink":"https://blog.lqh.kim/2021/02/02/yuque/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"栈 定义一种后进先出的数据结构。 类似于一个麻袋，先装进去的就在袋子的最底部，所以只能先拿出来最上面的 名词解释push： 入栈pop： 出栈top：栈顶JavaScript 中的栈在 js 中是没用栈这种数据结构的，不过我们可以利用数组来模拟。而且在 js 中也是有对应的 push 和 pop 方法的: push: 向数组末尾添加一个元素，返回值是数组的长度pop：移除数组的第一个元素，返回值是移除的元素 什么场景下用栈？ 最直白的讲就是需要后进先出的场景 十进制转二进制我们计算十进制转二进制时，就是不断除以 2，然后取余数然后将最后一位的余数与第一位的余数拼成二进制 这样的后进先出的手法有没有想到栈！ 判断字符串的括号是否有效我们验证括号是否有效其实就是在验证是不是能够凑齐一对完整的闭合括号。 而且我们可以发现一个规律，越靠左的左括号，它对应的右括号就越靠右。反之也就是最后面的左括号，对应的必定是出现的第一个右括号。 所以我们就可以在遇到左括号时就入栈，遇到右括号时就与栈顶的括号就行配对比较，若果符合配对规则则出栈，否则就不符合规则直接判定无效。匹配到最后结如果栈内是空就证明可以完整闭合 函数调用栈等这个可以看浏览器，js 的解释器就是通过调用栈的形式实现的 执行 fun1 时先将 fun1 入栈，然后调用 fun2，入栈；然后调用 fun3 入栈。 fun3 执行完毕出栈fun2 执行完毕出栈fun1 执行完毕出栈程序执行完毕 队列 定义一种先进先出的数据结构，类似一个管道，这边进那边出 名词解释enqueue: 入队dequeue：出队JavaScript 中模拟队列JavaScript 中没有队列，但是可以使用数组来模拟 push shift: 移除数组中最后一个个元素，返回值是被移除的元素 应用场景js 中的异步任务队列 计算最近请求次数链表线性表是 n 个元素的有限序列，最常用的是链式表达式，通常也叫作线性链表或者链表。**在链表中存储的数据元素也叫作*节点，\\*一个节点存储的就是一条数据记录。每个节点的结构包括两个部分： 具体的数据值 指向下一个节点的指针 在链表的最前面通常有一个头指针用来指向第一个节点。对于链表的最后一个节点，由于在他之后没有下一个节点，因此它的指针是一个空指针。** 单向链表 如上图所示：只能通过上一个节点的指针找到下一个节点，而不能通过下一个节点去找到上一个节点 循环链表 让最后一个元素的指针指向第一个元素，就形成了循环链表 双向链表 给每个元素增加一个指向上一个元素的指针就形成了双向链表双向链表可以通过自身查找到上一个元素，也可以查找到下一个元素 双向循环链表 同样的还可以将双向链表和循环链表相结合，形成双向循环链表 单向链表的增删查增当我们想要在一个链表A节点和B节点的中间增加节点C时，需要进行以下两步： 使 C 节点的 net 等于 A 节点的 next 改变 A 节点的 next 等于 C 节点 第一步和第二步的顺序不能调换，如果先执行第一步的话，那么就没办法获取到指向 B 节点的指针了，除非是新建一个变量提前缓存该指针 12C.next = A.next;A.next = C; 删当我们想要在一个链表中删除B节点时，需要进行以下一步： 使 A 的 next 等于 B 的 next 这里需要注意，A.next = B， 所以我们在处理这一步的时候，完全可以写成 A.next = A.next.next ; 1A.next = A.next.next; 查链表这种数据结构对于查找操作来说是弱项。因为链表的查找只能从第一个节点开始，逐个查找。 通过上面的增删查操作我们可以明显感知到，链表这种数据结构在增、删的操作上是比较方便的，可以在O(1)的时间复杂度内完成，但是查的话就是O(n)的时间复杂度了。但是链表在增删上的优势并不明显，因为我们在增删的时候往往会伴随着查找的动作，比如我们在第五个节点后面添加一个新的节点，就会有这样的过程： 查找到链表中的第 5 个节点 在他后面新增节点 那这么说链表就没什么用了吗？ 当然不是，链表的真正价值在于它存储的数据方式是按照顺序进行关联存储的，如果对于元素个数不确定，并且经常进行增删的数据来说，链表是比较合适的 链表在内存中可以存储在不连续的内存空间内因为链表的顺序关联是通过指针进行关联的所以对于不确定元素个数的数据来说，存储在内存空间中的各个位置，然后通过 next 指针关联是较好的 对于元素个数确定的数据，那么数组就是比较好的选择了 数组在内存中开辟的是一块固定的连续内存空间 集合定义一种无序且唯一的数据结构。 JavaScript 中的集合 set 123456const arr = [1, 1, 2, 3, 4, 5, 6, 7, 5, 7];// 去重const arr2 = [...new Set(arr)];// 判断集合中是否有某元素const set = new Set([1, 2, 3]);set.has(1); 应用场景 去重 求交集 判断某元素是否在集合中 字典定义与集合类似，字典也是一种存储唯一值的数据结构，但它是以键值对的形式来存储的. JavaScript 中的字典 ES6 中的字典，名为 Map 1234567891011121314const map = new Map();// 增map.set(&quot;a&quot;, &quot;123&quot;);map.set(&quot;b&quot;, &quot;456&quot;);// 删map.delete(&quot;a&quot;);map.clear(); // 清空字典// 改map.set(&quot;a&quot;, &quot;233&quot;);// 查map.get(&quot;a&quot;);// 这些操作的时间复杂度都为O(1) 图定义 图是网络结构的抽象模型，是一组由边连接的节点 图可以表示任何二元关系，比如道路、航班 二元关系： 一条边只能连接两个节点 JavaScript 中的图 js 中没有图，但是可以用 Object 和 Array 构建图 图的表示法： 邻接矩阵、邻接表、关联矩阵 操作 深度优先遍历 访问根节点 对根节点的没访问过的相邻节点挨个进行深度优先遍历 广度优先遍历 新建一个队列，将根节点入队 将队头取出并访问 把队头的没访问过的相邻节点入队 重复 2、3、4 步，直到队列为空 堆 堆是一种特殊的完全二叉树 所有的节点都大于等于（最大堆）或者小于等于（最小堆）他的子节点 Javascript 中的堆 js 中通常用数组表示堆 左侧子节点的位置是： 2*index+1 右侧子节点的位置是： 2*index+2 父节点的位置是： （index-1）/ 2 向下取整 堆的应用 高效快速的找到最大或者最小的元素 因为堆是有顺序的，不是最大堆就是最小堆 找到最大或者最小的第 K 个元素 JavaScript 实现最小的堆类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class MinHeap &#123; constructor() &#123; this.heap = []; &#125; // 交换元素 swap(i1, i2) &#123; [this.heap[i2], this.heap[i1]] = [this.heap[i1], this.heap[i2]]; &#125; // 元素上移 shiftUp(index) &#123; // 比较到堆顶元素直接返回 if (index === 0) return; const parentIndex = this.parentIndex(index); // 比较当前节点与父节点的大小 if (this.heap[index] &lt; this.heap[parentIndex]) &#123; this.swap(index, parentIndex); // 递归比较下一个节点与父节点 this.shiftUp(parentIndex); &#125; &#125; // 元素下移 shiftDown(index) &#123; const left = this.leftIndex(index); const right = this.rightIndex(index); // 判断左子节点是否比自己小 if (this.heap[left] &lt; this.heap[index]) &#123; this.swap(left, index); this.shiftDown(left); &#125; // 判断右子节点是否比自己小 if (this.heap[right] &lt; this.heap[index]) &#123; this.swap(right, index); this.shiftDown(right); &#125; &#125; // 插入 insert(n) &#123; this.heap.push(n); // 插入之后需要考虑将该元素上移 this.shiftUp(this.heap.length - 1); &#125; // 删除堆顶 pop() &#123; // 用堆底元素替换堆顶元素 this.heap[0] = this.heap.pop(); // 将更新后的堆顶元素向下移动 this.shiftDown(0); &#125; // 获取堆顶元素 peek() &#123; return this.heap[0]; &#125; // 获取堆的大小 size() &#123; return this.heap.length; &#125; // 获取父节点的下标 parentIndex(index) &#123; return Math.floor((index - 1) / 2); &#125; // 获取左侧子节点下标 leftIndex(index) &#123; return index * 2 + 1; &#125; // 获取右侧子节点下标 rightIndex(index) &#123; return index * 2 + 2; &#125;&#125;// 测试是否可以正常运行const h = new MinHeap();h.insert(3);h.insert(2);h.insert(1);h.insert(0);h.pop();console.log(h.heap);","categories":[],"tags":[]},{"title":"时间复杂度&空间复杂度","slug":"yuque/时间复杂度&空间复杂度","date":"2021-02-01T23:09:37.000Z","updated":"2021-06-08T07:55:51.187Z","comments":true,"path":"2021/02/02/yuque/时间复杂度&空间复杂度/","link":"","permalink":"https://blog.lqh.kim/2021/02/02/yuque/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"","text":"复杂度的作用一般我们会从两个维度去考虑一段代码的质量： 时间复杂度 空间复杂度 顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。 所以时间复杂度和空间复杂度一般是用来衡量一段代码的优劣的。 那么我们应该怎么来定义复杂度呢？ 复杂度的定义与特点定义 复杂度是一个关于输入量 n 的函数。eg：假设你的代码复杂度是 f(n),那么用大写字母 O 将其括起来就可以表示复杂度了 — O(f(n)) 特点与常系数无关 例如 O(n) + O(n) = O(2n), 其实 O(n)复杂度和 O(2n)复杂度是一样的，我们通常会忽略常系数对复杂度的影响 多项式级相加的复杂度，会取结果最大的那一个作为最后的结果 O(n^2) + O(n)，明显 n^2 在输入量 n 逐渐变大的情况下，变化会更大，所以我们就说复杂度是 O(n^2)即可 O(1)是一个特殊的复杂度：输入量 n 与消耗的资源无关 O（1）表示的是当前复杂度和输入 n 无关。例如你的代码处理 100 条数据是消耗 3 个时间单元和 1 个空间单元，处理 500 条数据依然还是消耗 3 个时间单元和 1 个空间单元，那么就是输入量与消耗资源无 案例分析O(1)12let num = 0;num += 1; 时间复杂度：O(1)空间复杂度：O(1) O(n)123for (let i = 0; i++; i &lt; n) &#123; console.log(i);&#125; 时间复杂度：O(n)空间复杂度：O(1) 单个变量所占的空间永远都是一个常量所以是 O(1) 1234const arr = [];for (let i = 0; i++; i &lt; n) &#123; arr.push(i);&#125; 时间复杂度：O(n)空间复杂度：O(n) 这段代码相当于我们给数组 arr 中添加了 n 个元素，所以占用了 n 个内存单元，因此空间复杂度为 O(n) O(logn)1234let i = 1;while (i &lt;= n) &#123; i *= 2;&#125; 时间复杂度：O(n)空间复杂度：O(1) 这段代码相当于是在计算 2&lt;=n，也就是 x 次之后循环结束那么 x=logn","categories":[],"tags":[]},{"title":"动画与绘制","slug":"yuque/动画与绘制","date":"2020-12-27T13:02:11.000Z","updated":"2021-06-08T07:55:51.235Z","comments":true,"path":"2020/12/27/yuque/动画与绘制/","link":"","permalink":"https://blog.lqh.kim/2020/12/27/yuque/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%88%B6/","excerpt":"","text":"Animation @keyframes 定义 可以使用百分比表示进度 也可以使用 from、to 1234567@keyframes mykf&#123; form&#123; background: red &#125; to&#123; background: blue &#125; animation：使用 animation-name 动画名称 animation-duration 动画的时长 animation-timing-function 动画的时间曲线 贝塞尔曲线：https://cubic-bezier.com/#.17,.67,.83,.67 一次贝塞尔曲线（直线） 二次贝塞尔曲线 三次贝塞尔曲线（常用） animation-delay 动画开始前的延迟 animation-iteration-count 动画的播放次数 animation-rirection 动画的方向 transition transition-property 需要变换的属性 transition-duration 变换的时长 transition-timing-function 时间曲线 transition-delay 延迟 颜色在自然界中我们看到的光都是混色光，极少有纯色光（激光笔可以达到纯色光）正常人类看到的光的波长在 400~760nm。 人眼内有三种视锥细胞，这三种细胞分别用来识别三种颜色：红绿蓝（RGB） HSL 和 HSV Hue： 色相（将颜色分成一个色盘，然后我们通过制定一个色盘中的角度，来决定他的颜色） Ssturation：纯度 Lightness： 亮度（到达 100 是白色，到达 0 是黑色，中间的才是纯色） Value：明度 （value 到达 100%时，就相当于是一个纯色） （HSL： W3C 采用的标准） 绘制几何图形 border box-shadow border-radius 文字 font text-decoration 位图 background-image","categories":[],"tags":[]},{"title":"CSS排版","slug":"yuque/CSS排版","date":"2020-12-20T23:28:21.000Z","updated":"2021-06-08T07:55:51.351Z","comments":true,"path":"2020/12/21/yuque/CSS排版/","link":"","permalink":"https://blog.lqh.kim/2020/12/21/yuque/CSS%E6%8E%92%E7%89%88/","excerpt":"","text":"盒（Box) HTML 代码中可以书写开始标签，结束标签，和自封闭标签一对起止标签，表示一个元素DOM 树中存储的是元素和其他类型的节点（Node)CSS 选择器选中的是元素CSS 选择器选中的元素，在排版时可能产生多个盒排版和渲染的基本单位是盒 盒模型盒模型分为两种： 可以通过 box-sizing 来设置不同的盒模型box-sizing 默认值是 content-box 怪异盒模型（border-box)： box-width = content + padding + border 标准盒模型 (content-box)： box-width = content 怪异盒模型在增加 padding 和 border 的宽度时，会保持原有的 box-width 而去对应减少 content 的 width 的所占空间 正常流正常流的排版： 收集盒和文字进行计算 计算盒和文字在行中的排布 计算行的排布 IFC：行内级格式化上下文（从左到右排列）BFC：块级格式化上下（从上到下排列） 正常流的行级排布（IFC）Baseline下图中黄色的线就是基线，文字是基于基线来对齐的。 Text底层软件定义的文字 origin：基线的原点 advance：排版中文字占据的空间 bearingX：文字之间的间距 yMin：文字基线距离文字底部的距离 行模型 base-line：基线，文字默认对齐的线 text-top、text-bottom：文字的上下边缘线 只要字体的大小不变，text-top 和 text-bottom 就是不变的如果用了多种字体混排的话，那么这个文字的上下边缘就是有 font-size 最大的字体决定的。我们基本可以认为这两条线是固定不变的 line-top、line-bottom：行的上下边缘线 这两条线的产生是因为行高大于文字的高度 文字和盒混排时产生的问题当一个行内盒是按照 text-bottom 来对齐的话，它就会撑开该行的高度，造成偏移的情况。 当没有蓝色的行内盒的时候，只有文字那么该盒是只有 text-top 和 text-bottom 的高度时，文字看起来排版就比较正常，但是当蓝色盒子出现的时候撑开了 line-top，导致该行整体高度都被撑开了，那么文字相较之前的就会看起来偏下了许多。 Eg： 123456789101112&lt;div style=&quot;font-size: 50px; line-height: 100px; background-color: bisque&quot;&gt; &lt;span&gt;Hello good 国&lt;/span&gt; &lt;div style=&quot; display: inline-block; line-height: 70px; width: 100px; height: 150px; background-color: cadetblue; &quot; &gt;&lt;/div&gt;&lt;/div&gt; 效果如下：文字正常情况按照基线对齐：当我们添加一个行内盒的时候：蓝色的线是 line-top，就被撑开了（该行的整体高度被撑开）。绿色的线是 text-top，行内盒不会影响 text 的边缘线高度。当我们在行内盒添加上一个文字时：这种情况就相当于，当一个行内盒中有了文字之后，那么对齐的时候就会按照文字的基线去对齐当我们呢在行内盒再添加一个换行和文字时：会按照最下面文字的基线去进行对齐上面的演示代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;div style=&quot;font-size: 50px; line-height: 100px; background-color: bisque&quot;&gt; &lt;!-- line-top --&gt; &lt;div style=&quot; vertical-align: top; width: 1px; height: 1px; display: inline-block; &quot; &gt; &lt;div style=&quot;width: 100vw; height: 1px; background-color: blue&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- text-top --&gt; &lt;div style=&quot; vertical-align: text-top; width: 1px; height: 1px; display: inline-block; &quot; &gt; &lt;div style=&quot;width: 100vw; height: 1px; background-color: green&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 基线 --&gt; &lt;div style=&quot; vertical-align: baseline; width: 1px; height: 1px; display: inline-block; &quot; &gt; &lt;div style=&quot;width: 100vw; height: 1px; background-color: red&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- text-bottom --&gt; &lt;div style=&quot; vertical-align: text-bottom; width: 1px; height: 1px; display: inline-block; &quot; &gt; &lt;div style=&quot;width: 100vw; height: 1px; background-color: green&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- line-bottom --&gt; &lt;div style=&quot; vertical-align: bottom; width: 1px; height: 1px; display: inline-block; &quot; &gt; &lt;div style=&quot;width: 100vw; height: 1px; background-color: blue&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;span&gt;Hello good 国&lt;/span&gt; &lt;div style=&quot; display: inline-block; line-height: 70px; width: 100px; height: 150px; background-color: cadetblue; &quot; &gt; M N &lt;/div&gt;&lt;/div&gt; 正常流的块级排布（BFC)float 和 clearfloat： 严格来说是已经脱离文档流的，他在排列时可以完成图文环绕排的形式。 多个 float 元素会依次排列，不会占据对方的空间 float 会造成重排的问题 clear：与其说是清除浮动，不如说是在某个方向上找个干净的地方去完成浮动的排列 与上面同样的代码，只要给第二个 float 的红色 div 设置 clear: right 就可以实现下面这种效果 所以说 clear 更像是在右面找了一个干净的地方进行浮动排列 margin 折叠这种现象只会发生在正常流中，在正常流中只有 BFC 才会有！ 上下两个块级元素都有 margin 的情况下，在排列的时候会选取一个 margin 的最大值作为其最终排版的结果 =====&gt; BFC 合并 Block Container： 里面有 BFC 能容纳正常流的盒，里面就有 BFC BLock-level Box： 外面有 BFC 的 Block Box = Block container + Block-level Box：里外都有 BFC 的","categories":[],"tags":[]},{"title":"Pseudo-element: 伪元素","slug":"yuque/Pseudo-element! 伪元素","date":"2020-12-20T11:07:45.000Z","updated":"2021-06-08T07:55:51.367Z","comments":true,"path":"2020/12/20/yuque/Pseudo-element! 伪元素/","link":"","permalink":"https://blog.lqh.kim/2020/12/20/yuque/Pseudo-element!%20%E4%BC%AA%E5%85%83%E7%B4%A0/","excerpt":"","text":"::before ::after ::first-line 选中第一行 ::first-letter 选中第一个字母 1234&lt;div&gt; &lt;::before/&gt; content content content content content content content content &lt;::after/&gt;&lt;/div&gt; 1234&lt;div&gt; &lt;::first-letter&gt;c&lt;/::first-letter&gt;ontent content content content content content content content&lt;/div&gt; first-line 和 first-letter 支持的 css 属性设置：","categories":[],"tags":[]},{"title":"Calculating specificity：计算优先级","slug":"yuque/Calculating specificity：计算优先级","date":"2020-12-20T00:34:25.000Z","updated":"2021-06-08T07:55:51.451Z","comments":true,"path":"2020/12/20/yuque/Calculating specificity：计算优先级/","link":"","permalink":"https://blog.lqh.kim/2020/12/20/yuque/Calculating%20specificity%EF%BC%9A%E8%AE%A1%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7/","excerpt":"","text":"优先级概念优先级其实就是分配给某一个 css 声明的权重，它是由该声明中匹配到的每个选择器类型的数值来决定的​ 当同一个元素有多个声明的时候，优先级才会有意义。因为每一个直接作用于元素的 CSS 规则总是会接管/覆盖（take over）该元素从祖先元素继承而来的规则。 通用规则（优先级从左到右依次递减） !imporant &gt; 行内 &gt; id 选择器 &gt; 类、伪类、属性选择器 &gt; 标签、伪元素选择器 &gt; *通用选择器 从上面的图片可以看到，其实权重的计算很简单，它是由四个部分组成的，我们可以用这样的形式来表达[ L , A, B, C ]。在优先级概念中我们也提到了，他的权重是由匹配到的选择器的数值来决定的。所以当我们在一个 css 声明中没匹配到对应位置上的一个选择器时，这个数组中的对应位置就+1.例如： 1234567891011121314/* [ 0, 0, 1, 1] */div .item &#123; color: red;&#125;/* [ 0, 1, 0, 1] */#id p &#123; color: blue;&#125;/* [ 0, 0, 2, 1] */.item1 .item2 span &#123; color: yellow;&#125; ​ 在样式计算优先级时遵循权重值高的样式，覆盖权重低的样式（弱肉强食法则）当权重值相同时，根据声明的时间来决定样式的显示，声明时间越靠后，也就是在样式表中的位置越靠下优先级就越高。 特殊伪类计算 :is()**、:not()、:has() 这三个伪类选择器的计算值将被其参数中优先级最高的一个所代替** 123456789:is(#id) &#123; color: red;&#125;:is(#id, .item) &#123; color: blue;&#125;参数中的id选择器是优先级最高的,所以两个的权重都为: [0, 1, 0, 0] 那么决定最后颜色显示的就是他们的顺序，谁最后定义的就是设么颜色; :nth-child()**、:nth-last-child()的计算值是一个伪类的值加上其他选择器的值：伪类值+其他选择器值。（这里有一点需要注意的是:nth-child(n),中的 n 可以是数字、关键词和表达式，关键词是 odd（偶数）、even（奇数）。并且这个 n 是针对父级元素**来计算的） 123456p:nth-child(3)&#123; color: yellow;&#125;标签选择器+伪类选择器：[0, 0, 1, 1] :where() 伪类的计算值为 0 123456.item:where(p) &#123; color: red;&#125;where伪类的权重值为0：[0, 0, 1, 1] 参考表： 选择器 计算 权重 * （通用选择器） L=0, A=0, B=0, C=0 [0, 0, 0, 0] li L=0, A=0, B=0, C=1 [0, 0, 0, 1] ul li L=0, A=0, B=0, C=2 [0, 0, 0, 2] ul ol + li L=0, A=0, B=0, C=3 [0, 0, 0, 3] h1 + [id=”someElement”] L=0, A=0, B=1, C=1 [0, 0, 1, 1] #id:not(.foo) L=0, A=1, B=1, C=0 [0, 1, 1, 0] .foo:is(.bar,#baz) L=0, A=1, B=1, C=0 [0, 1, 1, 0] 练习12345678910111213141516171819&lt;style&gt; .red p &#123; color: red; &#125; .blue p &#123; color: blue; &#125;&lt;/style&gt;&lt;div class=&quot;red&quot;&gt; &lt;div class=&quot;blue&quot;&gt; &lt;p&gt;我是什么颜色&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;blue&quot;&gt; &lt;div class=&quot;red&quot;&gt; &lt;p&gt;我是什么颜色&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 分析： .red p 权重为 [0, 0, 1, 1] .blue p 权重为 [0, 0, 1, 1] 可以看到权重相同，和 DOM 的结构无关，根据优先级顺序可以确定显示的都为 blue","categories":[],"tags":[]},{"title":"Pseudo-Class：伪类","slug":"yuque/Pseudo-Class：伪类","date":"2020-12-20T00:33:41.000Z","updated":"2021-06-08T07:55:51.479Z","comments":true,"path":"2020/12/20/yuque/Pseudo-Class：伪类/","link":"","permalink":"https://blog.lqh.kim/2020/12/20/yuque/Pseudo-Class%EF%BC%9A%E4%BC%AA%E7%B1%BB/","excerpt":"","text":"链接/行为之前这些伪类的实现都是为了超链接设计的，但是现在有很多伪类都可以用到其他元素上了。 :any-link 任何超链接 :link 没有访问过的超链接 :visited 已经访问过的超链接 any-link 可以看做是 link 和 visited 的结合Tips：一旦使用了 link 或者 visited 伪类之后，就没有办法去修改除了颜色以外的 css 属性了。这样做是为了浏览器安全考虑的。因为一旦你更改了像 visited 超链接的大小的时候，就可以让别人明显感受到你访问过哪些网站，这对于用户来说是不太容易接受的，就像泄漏了隐私一样，也不符合浏览器安全的相关策略。 :hover :active :focus :target 树结构 :empty :nth-child() 从前让后数 :nth-last-child() 从后往前数 :first-child :last-child :only-child 逻辑型 :not 伪类 :where :has 在 css 书写过程中，我们不应该写过于复杂的选择器，这样一是对性能不好，二是可能自己 HTML 结构设计的有问题。","categories":[],"tags":[]},{"title":"Selector: 选择器","slug":"yuque/Selector! 选择器","date":"2020-12-20T00:28:48.000Z","updated":"2021-06-08T07:55:51.495Z","comments":true,"path":"2020/12/20/yuque/Selector! 选择器/","link":"","permalink":"https://blog.lqh.kim/2020/12/20/yuque/Selector!%20%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"选择器简单选择器 - div、svg、a .class #id [attr=value] :hover ::before 复合选择器 &lt;简单选择器&gt;&lt;简单选择器&gt;&lt;简单选择器&gt; 或者 div 必须写在最前面 复杂选择器 &lt;复合选择器&gt;&lt;复合选择器&gt; &lt;复合选择器&gt;”&gt;”&lt;复合选择器&gt; &lt;复合选择器&gt;”~”&lt;复合选择器&gt; &lt;复合选择器&gt;”+”&lt;复合选择器&gt; &lt;复合选择器&gt;”||”&lt;复合选择器&gt;","categories":[],"tags":[]},{"title":"翻译记录","slug":"yuque/翻译记录","date":"2020-12-14T23:42:53.000Z","updated":"2021-06-08T07:55:51.535Z","comments":true,"path":"2020/12/15/yuque/翻译记录/","link":"","permalink":"https://blog.lqh.kim/2020/12/15/yuque/%E7%BF%BB%E8%AF%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Selectors Level 4Selector syntax(选择器语法）一个选择器是由一个或者多个简单选择器序列组合而成的，他们通过连接符（Combinators）分割开。并且在一个选择器中的最后一个简单选择器的末尾可以添加一个伪元素。 简单选择器序列（sequences of simple selectors)：由一连串没有使用连接符（Combinators）分割开来的简单选择器组合而成。通常是由标签选择器（h1、div）和通用选择器（*）作为开头。在简单选择器序列中不允许其他的标签选择器或者是通用选择器。 简单选择器（simple selectors）： 标签选择器(h1) 通用选择器(*) 属性选择器（[]) 类选择器(.) id 选择器(#) 伪类选择器（::) 连接符（Combinators）： whitespace 空格 - ~ Calculating a selector’s specificity(计算选择器的优先级）为给定元素计算它的优先级，遵循以下原则： 计算 ID 选择器的值 A 计算类选择、属性选择器、伪类选择器的值 B 计算标签选择器和伪元素选择器的值 C 忽略通用选择器* :is()、:not()、:has(),这三个伪类选择器的计算值将被其中优先级最高的值所代替 eg::is(#id) [1,0,0] 伪类的优先级值 B 被 id 的高优先值所代替 类似的, :nth-child()、：nth-last-child()的计算值是一个伪类的值加上参数的计算值之和。 eg::nth-child(.item) [0,2,0] 伪类的值加上参数.item 的值 :where() 伪类的计算值为 0 eg:.item:where(em,#foo) [0,1,0] where 伪类的值为 0 【A，B，C】 /_ a=0 b=0 c=0 /LI / a=0 b=0 c=1 /UL LI / a=0 b=0 c=2 _/ UL OL+LI /_ a=0 b=0 c=3 _/ H1 + [REL=up] / a=0 b=1 c=1 */ UL OL LI.red /_ a=0 b=1 c=3 _/ LI.red.level /_ a=0 b=2 c=1 _/ #x34y /_ a=1 b=0 c=0 _/ #s12:not(FOO) /_ a=1 b=0 c=1 _/ .foo :is(.bar, #baz) /_ a=1 b=1 c=0 _/ Grammar","categories":[],"tags":[]},{"title":"CSS结构","slug":"yuque/CSS结构","date":"2020-12-13T23:30:32.000Z","updated":"2021-06-08T07:55:51.583Z","comments":true,"path":"2020/12/14/yuque/CSS结构/","link":"","permalink":"https://blog.lqh.kim/2020/12/14/yuque/CSS%E7%BB%93%E6%9E%84/","excerpt":"","text":"因为找不到一个明确的语法线索，所以我们这里根据 2.1 版本的语法来进行学习。现版本 css 多了很多 css3 的语法，但是不影响我们理解他的语法结构。 CSS2.1 语法 css2.1Grammar 中文对照版 总体结构一个样式文件从上到下的顺序结构： @charset @charset &#39;UTF-8&#39;; 声明 css 文件的字符编码标准。 必须在样式表的第一行声明 如果有多个@charset 声明，那么只有第一个会生效 无法在 HTML 的 style 标签里使用该 at-rule 规则 Tip:在样式表中声明字符编码有很多种方式，浏览器会按照以下顺序去尝试确定文件的编码方式（只要找到一种就会停止并得出结果）： 文件开头的 Unicode byte-order 字符值 由 Content-type 确定：HTTP 协议中的 charset 属性给出的值或用于提供样式表的协议中的等效值 CSS @rule 规则：@charset 假设文档上是 UTF-8 的格式 @import rules （这部分是我们日常最常用到的部分） @media @page rule CSS 规则的结构1234div /* selector */ &#123; /* key */ background-color: /* value */ red;&#125; 由上面的 css 代码可以明确 css 规则的结构分为以下两个部分： Selector（选择器） Declare（声明） key value 爬取 w3c 的 css 规则123456789JSON.stringify( Array.prototype.slice .call(document.querySelector(&quot;#container&quot;).children) .filter((e) =&gt; e.getAttribute(&quot;data-tag&quot;).match(/css/)) .map((e) =&gt; (&#123; name: e.children[1].children[0].innerText, url: e.children[1].children[0].href, &#125;))); 思维导图","categories":[],"tags":[]},{"title":"链表篇","slug":"yuque/链表篇","date":"2020-12-10T06:10:05.000Z","updated":"2021-06-08T07:55:51.639Z","comments":true,"path":"2020/12/10/yuque/链表篇/","link":"","permalink":"https://blog.lqh.kim/2020/12/10/yuque/%E9%93%BE%E8%A1%A8%E7%AF%87/","excerpt":"","text":"【206】反转链表描述 反转一个单链表。 示例: &gt; 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 题解这是个经典的链表问题，其实这个问题的关键就在于要提前保存下一个节点的值。因为你在让当前节点指向上一个节点的过程中，就会把当前节点的 next 指向改变，如果不提前保存当前节点的 next 值的话，就会找不到原有的当前节点的 next 值。 迭代大法 时间复杂度：O(n) 空间复杂度：O(1) 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */const reverList = (head) =&gt; &#123; let cur = head; let prev = null; let tmp; while (cur) &#123; // 记录当前节点的下一个节点 tmp = cur.next; // 改变当前节点的next指针指向 cur.next = prev; // 更新上一个节点的值 prev = cur; // 更新当前节点 cur = tmp; &#125; return prev;&#125;; 递归方法 时间复杂度：O(n) 空间复杂度：O(1) 1234567891011const reverList = (head) =&gt; &#123; const rever = (prev, cur) =&gt; &#123; // 严谨性判断，当cur为空时链表翻转结束 if (!cur) return prev; // 提前保存上一个节点的值 const tmp = cur.next; cur.next = prev; return rever(cur, tmp); &#125;; return rever(null, head);&#125;; 【237】删除链表中的节点描述 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。 现有一个链表 – head = [4,5,1,9]，它可以表示为:&gt; &gt; &gt; 链接 题解这道题的总体思路就是狸猫换太子。 单向链表我们无法获取到上一项的值，去改变上一项的 next 指向 所以我们换种思路，将传入的这个需要删除的节点直接替换成下一个节点，具体替换步骤也是分为两步： 替换 val 值 替换 next 节点 1234567891011121314151617/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; node * @return &#123;void&#125; Do not return anything, modify node in-place instead. */var deleteNode = function (node) &#123; // 将需要删除的当前节点的值替换为下一个节点的值 node.val = node.next.val; // 将需要删的节点next指向下一个节点的next node.next = node.next.next;&#125;; 时间复杂度：O(1)空间复杂度：O(1) 【2】两数相加描述 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2： 输入：l1 = [0], l2 = [0] 输出：[0] 示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 链接：https://leetcode-cn.com/problems/add-two-numbers 题解1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function (l1, l2) &#123; // 创建一个需要返回的新链表 const l3 = new ListNode(); // 保存每个链表的节点指针 let p1 = l1; let p2 = l2; let p3 = l3; // 创建变量来存储进位 let carry = 0; // 遍历 p1 和 p2 每个节点的val值进行相加 // 这里需要注意： 因为p1和p2可能长度不同，所以当其中一个有值时都需要相加，没有值的那个用0代替 while (p1 || p2) &#123; const v1 = p1 ? p1.val : 0; const v2 = p2 ? p2.val : 0; // 计算和，要加上前一个数字相加的进位 const sum = v1 + v2 + carry; // 计算进位，这里需要注意要将进位向下取整 carry = Math.floor(sum / 10); // 将个位数字放入l3链表中 p3.next = new ListNode(sum % 10); // 更新指针 if (p1) p1 = p1.next; if (p2) p2 = p2.next; p3 = p3.next; &#125; // 遍历结束后，判断进位，如果扔有进位放入l3链表中 if (carry) p3.next = new ListNode(carry); // 因为我们在创建新链表时，首位是0，所以我们要从头节点的下一位开始 return l3.next;&#125;;","categories":[],"tags":[]},{"title":"why-what","slug":"yuque/why-what","date":"2020-12-10T00:18:06.000Z","updated":"2021-06-08T07:55:51.707Z","comments":true,"path":"2020/12/10/yuque/why-what/","link":"","permalink":"https://blog.lqh.kim/2020/12/10/yuque/why-what/","excerpt":"","text":"Why为什么要有 hooks 这种方式？ 类组件通过 ES6 的 class 形式，继承 component 形成的组件，在该组件内有一系列的生命周期函数供开发者使用 1234567891011121314151617181920212223242526272829class DemoClass extends React.Component &#123; constructor(props) &#123; super(props); // 初始化类组件的 state state = &#123; text: &quot;&quot;, &#125;; &#125; // 编写生命周期方法 didMount componentDidMount() &#123; // 省略业务逻辑 &#125; // 编写自定义的实例方法 changeText = (newText) =&gt; &#123; // 更新 state this.setState(&#123; text: newText, &#125;); &#125;; // 编写生命周期方法 render render() &#123; return ( &lt;div className=&quot;demoClass&quot;&gt; &lt;p&gt;&#123;this.state.text&#125;&lt;/p&gt; &lt;button onClick=&#123;this.changeText&#125;&gt;点我修改&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 类组件是一个封装好的“重型战舰”，它里面有一系列的生命周期，可以很方便的让我们使用，而我们只需要继承一下 React.component 即可。但是类组件的全，并不一定是好事，大而全的背后必定是昂贵的学习代价。比如说如果我们不了解生命周期的话，那写出来的代码逻辑顺序大概率会变得一团糟。 函数组件函数组件在早期又叫做无状态组件，因为当时没有 hooks 的加持，它没有办法维持自身状态，只能通过父组件传递的 props 来维护一个值。 12345function DemoFun(props) &#123; const &#123; value &#125; = props; return &lt;div&gt;这是一个函数组件&lt;/div&gt;;&#125; 函数组件相较于类组件，肉眼可见的轻便、简单、易于维护。 二者的对比（无关优劣，之谈区别） 类组件需要继承 component 或者 pureComponent，函数组件不需要 类组件中有众多生命周期可以使用，函数组件中没有 类组件中可以通过访问 this 来做一些事情，函数组件中不行 类组件中可以维护自己的状态（state），函数组件中不行（以前不行，现在有了 hooks 就可以了） 函数组件会捕获 render 内部的状态，这是两者之间最大的区别 这里就最后一条进行展开描述，因为这条区别可以说是两者之间的本质区别，react 团队也是意识到了这个问题，才开始拥抱函数组件的。 为什么说函数组件会捕获 render 内部的状态可以说函数组件其实才是更契合 React 设计理念的。从上面这个图中可以看到，其实 react 的组件本身就是一个吃进数据，并且吐出 UI 的一种设计。 函数组件可以将数据处理并且最后映射到 UI 中去。React 数据应该总是和渲染紧密绑定在一起的，而类组件就做不到这一点。 https://codesandbox.io/s/focused-sun-si5pu?file=/src/index.js 虽然 props 本身是不可变的，但 this 却是可变的，this 上的数据是可以被修改的？ 怎么理解 props 本身是不可变的这句话？和 immutable 数据有关系吗？ 为什么类组件中的方法，不 bind this 就无法获取到 this 实例？设计缺陷，而我们都是在代码层面去弥补它设计上的缺陷 为什么需要 React-hooks 呢？（总结） 解决难以理解的 class 模式（this 问题和生命周期。在函数组件里不需要用到 this，生命周期会加重学习负担） 函数组件更加符合 react 的设计：UI=f(data) 使组件的状态和逻辑可以进行拆分和维护 函数组件其实更加符合 react 的设计理念。React 的定位其实就是一个吃进 data，然后吐出 UI 的这样一个框架，有个很著名的公式就体现出了这一点： UI = F（data）。而 hooks 的出现就是为了补齐函数组件无法维持状态等等一系列的问题，也是 react 拥抱函数组件的体现还有就是对比之下，其实函数组件要比类组件方便一些。类组件很多处理逻辑都要在生命周期里来处理，就会造成有一些状态和逻辑没办法轻易的做到抽离和复用。其次就是生命周期出现虽然方便了开发者，但是也对应的加大了学习成本。 hooks 的缺点 无法为函数组件补齐所有类组件的功能，比如类组件的几个特殊生命周期：getSnapshotBeforeUpdate、componentDidCatch Hooks 在使用层面有这严格的限制。最明显的就是不能写在循环或者判断里 只在 React 函数中调用 Hook；​ b. 不要在循环、条件或嵌套函数中调用 Hook。 What什么是 hooksReact-hooks 是一套能够使函数组件更加强大、更加灵活的“钩子”。 怎么使用useState：为函数组件引进了状态。该 hook 返回一个数组，我们可以用解构的形式来获取。数组第一项是我们需要使用的状态，第二项是我们用来修改该状态的一个方法。useEffect：允许我们在函数组件里进行副作用的操作。该 hook 接收两个参数：第一个参数是一个回调，用来写一些处理逻辑，该回调的返回值如果是一个函数的话会在组件被卸载时执行。第二个参数是一个数组，当然也可以不传。当传入的是一个空数组的时候只在页面挂载时调用。当数组中传入了对应的变量时，会作为一个依赖存在，就是这个变量变化时就会触发对应的回调","categories":[],"tags":[]},{"title":"Toy-Brower","slug":"yuque/Toy-Brower","date":"2020-12-02T13:38:57.000Z","updated":"2021-06-08T07:55:51.755Z","comments":true,"path":"2020/12/02/yuque/Toy-Brower/","link":"","permalink":"https://blog.lqh.kim/2020/12/02/yuque/Toy-Brower/","excerpt":"","text":"为了更加了解浏览器的工作原理，我们来自己用代码搞一个浏览器玩一下。 基本功能描述 功能实现HTTP 实现为了实现浏览器发送网络请求的这一部分，需要梳理一下这部分所需要的功能。 构建请求信息（请求方法、请求行、请求头、请求体） 建立网络连接（net.createServer()） 接收响应结果 处理响应结果 处理响应头 处理响应体 - 利用单独的子类进行 body text 的处理 构造一个发送请求的类 Request 思考：这个类都需要什么东西？ 首先需要一些发送请求时需要配置的基本配置项（options） url 请求路径 port 请求端口 method 请求方法 headers 请求头 body 请求体 其次需要一个发送该请求的方法（send） 该方法返回一个 promise 对象，该对象是请求回来的结果 该方法的功能： 构造请求并发送，发送前需要拼接上请求行、请求头、换行、请求体等信息。 接受请求结果 构造一个解析响应的类 ResponseParse response 返回的结果需要分段来进行处理，所以我们需要一个 ResponseParse 来进行装配 ResponseParse 来分段处理返回的结果，我们用有限状态机来记录完成这一个过程 针对 response body 中的内容采用另一个方法进行分段解析 构造一个类 TrunkedBodyParser response body 针对不通的 Content-type 类型会有不同的处理方法 我们这里针对 chunk 类型进行解析 HTML 解析的实现 接收响应体进行解析 构造状态机进行标签解析 开始标签 &lt; 开始标签的标志 /n/t 空格标志后面是标签属性 结束标签 / 结束标签的标志 &gt; 标签解析结束，开始下一个标签解析 自封闭标签 &lt;/ 自闭和标签的标志 利用 currentToken 变量接受解析结果 text文本类型 statTag开始标签类型 endTag结束标签类型 isSelfCloseTag自闭和标签标志 每次当前标签结束时需要emit(currentToken)来触发当前标签结束的事件 解析标签属性 氛围 attributeName 和 value 两部分进行解析 解析完成之后 emit 对应数据 构建 DOM 树 使用栈进行构造 遇到开始标签就处理好相关属性和元素名入栈 遇到自闭和标签就相当入栈后立即出栈 遇到闭合标签就找到对应标签出栈 CSS 计算 遇到 style 标签时，将 css 规则保存起来，使用 css parser 解析规则 当创建一个元素后应立即计算 css 理论上当我们分析一个元素时，是假设这个元素的 css 规则已经全部收集完毕的 在 computedCss 函数中，我们需要知道所有元素的父元素才可以去判断元素是否与规则匹配 由于我们首先获取的是当前元素，所以我们获得和计算父元素匹配的顺序是由内到外的 选择器也是由内向外匹配排列的 根据选择器的类型和元素属性，计算是否当前的元素匹配 元素匹配完成就应用选择器到元素上，形成 computedSty css 规则具有优先级，我们利用 specificity 特征去进行判断比较 specificity 是一个四元组，越左边权重越重 [0,0,0,] inline、id、class、tag css 规则的 specificity 是根据所包含的简单选择器相加形成的","categories":[],"tags":[]},{"title":"代码效率优化方法论","slug":"yuque/代码效率优化方法论","date":"2020-12-02T01:26:57.000Z","updated":"2021-06-08T07:55:51.791Z","comments":true,"path":"2020/12/02/yuque/代码效率优化方法论/","link":"","permalink":"https://blog.lqh.kim/2020/12/02/yuque/%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%AE%BA/","excerpt":"","text":"如何衡量一段代码的优劣呢？一般我们会从两个维度去考虑一段代码的质量： 时间复杂度 空间复杂度 顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。那么我们应该怎么取舍这两个标准呢？ 提高代码效率的方法我们从上面已经知道了衡量代码效率的方法，那么我们应该怎么着手去优化提高我们代码的效率呢？ 总的策略就是降低代码的时间复杂度和空间复杂度。 但是对于一段代码来说往往时间和空间两个是互斥的，如果我们想要降低时间复杂度，那么无疑就会增加空间复杂度。举一个生活中的 🌰，就像我们平时生活中开车过红绿灯，如果只有这一条路（空间）那么我们就只能在这等着红灯，当车越来越多的时候，就会消耗大家很多时间，但是当我们修建了立交桥之后，就会有更多的选择空间，就会大大减少等待红灯的时间。（图片来自拉钩教育-公瑾老师的重学算法与数据结构一课中）而对我们来说，时间永远都要比空间更加重要，因为时间拿钱买不来，而空间我们起码可以拿钱来进行扩容。空间是廉价的，时间是昂贵的 暴力解法：在没有任何时间和空间的限制下，将目标达成 剔除无效操作：将代码中没有必要的计算、无效的存储删除来优化时间和空间复杂度 时空转换：设计合理的数据结构，将时间向空间转换 增删查：数据的基本操作一般一段算法的实现最常设计的三个操作就是：增、删、查。而我们对一个算法的优化和实现只要围绕这三个为重心去思考展开即可： 分析这段代码对数据进行了那些操作 这些操作中有哪些操作是最消耗性能的，对时间复杂度的损耗是最高的？ 考虑有哪种数据结构可以帮助提高数据操作的使用效率。 以上三点就是构成我们实现代码效率优化的方法论。 查 按照元素索引查找 对于数组这些天生拥有索引的数据结构来说十分简单 对于链表这种，通过指针进行连接的就需要知道前面一个元素 按照元素特征值查找 对于字典类型的数据来说，key 就相当是特征，value 就是值，查找起来非常方便 对于数组和链表来说就需要循环对比每个元素来进行比较值的特征是否符合 增 在复杂数据结构的末尾添加数据 不会影响数据的原始位置 在复杂数据结构的中间添加数据 会影响到数据原始的位置 删 在复杂数据结构的末尾删除 不会影响到原先数据的位置 在复杂数据结构的中间位置进行删除 会影响到之前数据的原始位置","categories":[],"tags":[]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.lqh.kim/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}
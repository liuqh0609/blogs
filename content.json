{"meta":{"title":"火热","subtitle":"","description":"你我山巅自相逢，予你与我遇清风","author":"火热","url":"https://liuqh0609.github.io/blogs","root":"/blogs/"},"pages":[{"title":"","date":"2021-02-03T07:59:45.033Z","updated":"2021-02-03T07:59:45.033Z","comments":true,"path":"404.html","permalink":"https://liuqh0609.github.io/blogs/404.html","excerpt":"","text":""},{"title":"","date":"2021-02-03T06:26:03.179Z","updated":"2021-02-03T06:26:03.179Z","comments":true,"path":"about/index.html","permalink":"https://liuqh0609.github.io/blogs/about/index.html","excerpt":"","text":"对生活保持热爱对知识保持敬畏"},{"title":"所有分类","date":"2021-02-03T01:56:27.589Z","updated":"2021-02-03T01:56:27.589Z","comments":true,"path":"categories/index.html","permalink":"https://liuqh0609.github.io/blogs/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-02-03T01:56:44.460Z","updated":"2021-02-03T01:56:44.460Z","comments":true,"path":"tags/index.html","permalink":"https://liuqh0609.github.io/blogs/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"栈 - 基础知识","slug":"栈","date":"2021-02-03T09:51:40.037Z","updated":"2021-02-03T09:54:49.682Z","comments":true,"path":"2021/02/03/栈/","link":"","permalink":"https://liuqh0609.github.io/blogs/2021/02/03/%E6%A0%88/","excerpt":"","text":"栈 定义一种后进先出的数据结构。 类似于一个麻袋，先装进去的就在袋子的最底部，所以只能先拿出来最上面的 名词解释push： 入栈pop： 出栈top：栈顶JavaScript 中的栈在 js 中是没用栈这种数据结构的，不过我们可以利用数组来模拟。而且在 js 中也是有对应的 push 和 pop 方法的: push: 向数组末尾添加一个元素，返回值是数组的长度pop：移除数组的第一个元素，返回值是移除的元素 什么场景下用栈？ 最直白的讲就是需要后进先出的场景 十进制转二进制我们计算十进制转二进制时，就是不断除以 2，然后取余数然后将最后一位的余数与第一位的余数拼成二进制 这样的后进先出的手法有没有想到栈！ 判断字符串的括号是否有效我们验证括号是否有效其实就是在验证是不是能够凑齐一对完整的闭合括号。 而且我们可以发现一个规律，越靠左的左括号，它对应的右括号就越靠右。反之也就是最后面的左括号，对应的必定是出现的第一个右括号。 所以我们就可以在遇到左括号时就入栈，遇到右括号时就与栈顶的括号就行配对比较，若果符合配对规则则出栈，否则就不符合规则直接判定无效。匹配到最后结如果栈内是空就证明可以完整闭合 函数调用栈等这个可以看浏览器，js 的解释器就是通过调用栈的形式实现的 执行 fun1 时先将 fun1 入栈，然后调用 fun2，入栈；然后调用 fun3 入栈。 fun3 执行完毕出栈fun2 执行完毕出栈fun1 执行完毕出栈程序执行完毕","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liuqh0609.github.io/blogs/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liuqh0609.github.io/blogs/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"代码效率优化方法论","slug":"代码效率优化方法论","date":"2021-02-03T09:51:37.217Z","updated":"2021-02-03T11:53:25.822Z","comments":true,"path":"2021/02/03/代码效率优化方法论/","link":"","permalink":"https://liuqh0609.github.io/blogs/2021/02/03/%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%AE%BA/","excerpt":"","text":"代码效率优化方法论如何衡量一段代码的优劣呢？一般我们会从两个维度去考虑一段代码的质量： 时间复杂度 空间复杂度 顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。那么我们应该怎么取舍这两个标准呢？ 提高代码效率的方法我们从上面已经知道了衡量代码效率的方法，那么我们应该怎么着手去优化提高我们代码的效率呢？ 总的策略就是降低代码的时间复杂度和空间复杂度。 但是对于一段代码来说往往时间和空间两个是互斥的，如果我们想要降低时间复杂度，那么无疑就会增加空间复杂度。举一个生活中的 🌰，就像我们平时生活中开车过红绿灯，如果只有这一条路（空间）那么我们就只能在这等着红灯，当车越来越多的时候，就会消耗大家很多时间，但是当我们修建了立交桥之后，就会有更多的选择空间，就会大大减少等待红灯的时间。（图片来自拉钩教育-公瑾老师的重学算法与数据结构一课中）而对我们来说，时间永远都要比空间更加重要，因为时间拿钱买不来，而空间我们起码可以拿钱来进行扩容。空间是廉价的，时间是昂贵的 暴力解法：在没有任何时间和空间的限制下，将目标达成 剔除无效操作：将代码中没有必要的计算、无效的存储删除来优化时间和空间复杂度 时空转换：设计合理的数据结构，将时间向空间转换 增删查：数据的基本操作一般一段算法的实现最常设计的三个操作就是：增、删、查。而我们对一个算法的优化和实现只要围绕这三个为重心去思考展开即可： 分析这段代码对数据进行了那些操作 这些操作中有哪些操作是最消耗性能的，对时间复杂度的损耗是最高的？ 考虑有哪种数据结构可以帮助提高数据操作的使用效率。 以上三点就是构成我们实现代码效率优化的方法论。 查 按照元素索引查找 对于数组这些天生拥有索引的数据结构来说十分简单 对于链表这种，通过指针进行连接的就需要知道前面一个元素 按照元素特征值查找 对于字典类型的数据来说，key 就相当是特征，value 就是值，查找起来非常方便 对于数组和链表来说就需要循环对比每个元素来进行比较值的特征是否符合 增 在复杂数据结构的末尾添加数据 不会影响数据的原始位置 在复杂数据结构的中间添加数据 会影响到数据原始的位置 删 在复杂数据结构的末尾删除 不会影响到原先数据的位置 在复杂数据结构的中间位置进行删除 会影响到之前数据的原始位置","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liuqh0609.github.io/blogs/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liuqh0609.github.io/blogs/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"时间复杂度&空间复杂度","slug":"时间复杂度&空间复杂度","date":"2021-02-03T09:50:44.141Z","updated":"2021-02-03T09:54:13.832Z","comments":true,"path":"2021/02/03/时间复杂度&空间复杂度/","link":"","permalink":"https://liuqh0609.github.io/blogs/2021/02/03/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"","text":"时间复杂度&amp;空间复杂度复杂度的作用一般我们会从两个维度去考虑一段代码的质量： 时间复杂度 空间复杂度 顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。 所以时间复杂度和空间复杂度一般是用来衡量一段代码的优劣的。 那么我们应该怎么来定义复杂度呢？ 复杂度的定义与特点定义 复杂度是一个关于输入量 n 的函数。eg：假设你的代码复杂度是 f(n),那么用大写字母 O 将其括起来就可以表示复杂度了 — O(f(n)) 特点与常系数无关 例如 O(n) + O(n) = O(2n), 其实 O(n)复杂度和 O(2n)复杂度是一样的，我们通常会忽略常系数对复杂度的影响 多项式级相加的复杂度，会取结果最大的那一个作为最后的结果 O(n^2) + O(n)，明显 n^2 在输入量 n 逐渐变大的情况下，变化会更大，所以我们就说复杂度是 O(n^2)即可 O(1)是一个特殊的复杂度：输入量 n 与消耗的资源无关 O（1）表示的是当前复杂度和输入 n 无关。例如你的代码处理 100 条数据是消耗 3 个时间单元和 1 个空间单元，处理 500 条数据依然还是消耗 3 个时间单元和 1 个空间单元，那么就是输入量与消耗资源无 案例分析O(1)12let num = 0;num += 1; 时间复杂度：O(1)空间复杂度：O(1) O(n)123for (let i = 0; i++; i &lt; n) &#123; console.log(i);&#125; 时间复杂度：O(n)空间复杂度：O(1) 单个变量所占的空间永远都是一个常量所以是 O(1) 1234const arr = [];for (let i = 0; i++; i &lt; n) &#123; arr.push(i);&#125; 时间复杂度：O(n)空间复杂度：O(n) 这段代码相当于我们给数组 arr 中添加了 n 个元素，所以占用了 n 个内存单元，因此空间复杂度为 O(n) O(logn)1234let i = 1;while (i &lt;= n) &#123; i *= 2;&#125; 时间复杂度：O(n)空间复杂度：O(1) 这段代码相当于是在计算 2&lt;=n，也就是 x 次之后循环结束那么 x=logn","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liuqh0609.github.io/blogs/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liuqh0609.github.io/blogs/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"","slug":"测试","date":"2021-02-03T08:00:49.814Z","updated":"2021-02-03T08:01:13.560Z","comments":true,"path":"2021/02/03/测试/","link":"","permalink":"https://liuqh0609.github.io/blogs/2021/02/03/%E6%B5%8B%E8%AF%95/","excerpt":"","text":"这是一个测试的页面哈哈哈哈内容是没什么内容的哈 测试用例1234const fn = () =&gt; &#123; console.log(1); arr.map((item) =&gt; item.a === 1);&#125;; 详情介绍其实没什么东西 这个也是随便写的你随便看看哈 11111 22222 二级目录三级牡蛎下面没东西","categories":[],"tags":[]},{"title":"demo","slug":"demo","date":"2021-02-02T13:54:12.000Z","updated":"2021-02-03T05:56:43.372Z","comments":true,"path":"2021/02/02/demo/","link":"","permalink":"https://liuqh0609.github.io/blogs/2021/02/02/demo/","excerpt":"","text":"这是一个测试的页面哈哈哈哈内容是没什么内容的哈 测试用例1234const fn = () =&gt; &#123; console.log(1); arr.map((item) =&gt; item.a === 1);&#125;; 详情介绍其实没什么东西 这个也是随便写的你随便看看哈 11111 22222 二级目录三级牡蛎下面没东西","categories":[{"name":"测试","slug":"测试","permalink":"https://liuqh0609.github.io/blogs/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://liuqh0609.github.io/blogs/tags/%E6%B5%8B%E8%AF%95/"}]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liuqh0609.github.io/blogs/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"测试","slug":"测试","permalink":"https://liuqh0609.github.io/blogs/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liuqh0609.github.io/blogs/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"测试","slug":"测试","permalink":"https://liuqh0609.github.io/blogs/tags/%E6%B5%8B%E8%AF%95/"}]}